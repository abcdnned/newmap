globals
//globals from ABC:
constant boolean LIBRARY_ABC=true
    constant integer ABC__HASH = 8191
    timer array ABC__TimerKeyA
    timer array ABC__TimerKeyB
    timer array ABC__TimerKeyC
    trigger array ABC__TriggerKeyA
    trigger array ABC__TriggerKeyB
    trigger array ABC__TriggerKeyC
    dialog array ABC__DialogKeyA
    dialog array ABC__DialogKeyB
    dialog array ABC__DialogKeyC
    region array ABC__RegionKeyA
    region array ABC__RegionKeyB
    region array ABC__RegionKeyC
    button array ABC__ButtonKeyA
    button array ABC__ButtonKeyB
    button array ABC__ButtonKeyC
    
    integer array ABC__TimerValueA
    integer array ABC__TimerValueB
    integer array ABC__TimerValueC
    integer array ABC__TriggerValueA
    integer array ABC__TriggerValueB
    integer array ABC__TriggerValueC
    integer array ABC__DialogValueA
    integer array ABC__DialogValueB
    integer array ABC__DialogValueC
    integer array ABC__RegionValueA
    integer array ABC__RegionValueB
    integer array ABC__RegionValueC
    integer array ABC__ButtonValueA
    integer array ABC__ButtonValueB
    integer array ABC__ButtonValueC
    integer array ABC__TimerCollisionA
    integer array ABC__TimerCollisionB
    integer array ABC__TimerCollisionC
    integer array ABC__TriggerCollisionA
    integer array ABC__TriggerCollisionB
    integer array ABC__TriggerCollisionC
    integer array ABC__DialogCollisionA
    integer array ABC__DialogCollisionB
    integer array ABC__DialogCollisionC
    integer array ABC__RegionCollisionA
    integer array ABC__RegionCollisionB
    integer array ABC__RegionCollisionC 
    integer array ABC__ButtonCollisionA
    integer array ABC__ButtonCollisionB
    integer array ABC__ButtonCollisionC
    
    integer ABC__TimerMaxCollisionA = 0
    integer ABC__TimerMaxCollisionB = 0
    integer ABC__TimerMaxCollisionC = 0
    integer ABC__TriggerMaxCollisionA = 0
    integer ABC__TriggerMaxCollisionB = 0
    integer ABC__TriggerMaxCollisionC = 0
    integer ABC__DialogMaxCollisionA = 0
    integer ABC__DialogMaxCollisionB = 0
    integer ABC__DialogMaxCollisionC = 0
    integer ABC__RegionMaxCollisionA = 0
    integer ABC__RegionMaxCollisionB = 0
    integer ABC__RegionMaxCollisionC = 0 
    integer ABC__ButtonMaxCollisionA = 0
    integer ABC__ButtonMaxCollisionB = 0
    integer ABC__ButtonMaxCollisionC = 0
    
    hashtable ABC__TimerHash
    hashtable ABC__TriggerHash
    hashtable ABC__DialogHash
    hashtable ABC__RegionHash
    hashtable ABC__ButtonHash
//endglobals from ABC
//globals from AIDS:
constant boolean LIBRARY_AIDS=true
        constant boolean AIDS__USE_PERIODIC_RECYCLER = false
        constant real AIDS__PERIOD = 0.03125 // Recycles 32 units/second max.
// Lower to be able to recycle faster.
// Only used if USE_PERIODIC_RECYCLER
// is set to true.

        constant integer AIDS__LEAVE_DETECTION_ABILITY = 'AIDS'
        // The unit stored at an index.
        unit array AIDS__IndexUnit
        integer array AIDS__LockLevel
        // Recycle stack
        integer array AIDS__RecycledIndex
        integer AIDS__MaxRecycledIndex = 0
        
        // Previous highest index
        integer AIDS__MaxIndex = 0
        integer array AIDS__DecayingIndex
        integer AIDS__MaxDecayingIndex=0
        integer AIDS__DecayChecker=0
        timer AIDS__UndefendTimer=CreateTimer()
        integer array AIDS__UndefendIndex
        integer AIDS__UndefendStackIndex=0
        integer array AIDS__UndefendExpiringIndex
        integer AIDS__UndefendExpiringIndexLevel=0
        // The Add/Remove stack (or assign/recycle stack).
        // 
        // Indexing can become recusive since units can be created on index
        // assignment or deallocation.
        // To support this, a stack is used to store the event response results.
        integer AIDS__ARStackLevel=0
        integer array AIDS__ARStackIndex
        unit array AIDS__ARStackUnit
        
        // A later discovery revealed that the Add/Remove stack did not need to be
        // used for deallocation. The alternative used works fine...
        // For structs and such which need to do things on unit index assignment.
        trigger AIDS__OnEnter=CreateTrigger()
        // The same, but for when units pass the initial filter anyway.
        trigger AIDS__OnEnterAllocated=CreateTrigger()
        // For structs and such which need to do things on unit index deallocation.
        trigger AIDS__OnDeallocate=CreateTrigger()
        integer AIDS__getindex
            integer AIDS__UndefendFilterIndex
//endglobals from AIDS
//globals from AIDriver:
constant boolean LIBRARY_AIDriver=true
//endglobals from AIDriver
//globals from AII:
constant boolean LIBRARY_AII=true
        constant integer AII__MAX_THRASH=100
        //Max threshold for leaked event for death detection trigger.
        trigger AII__alloItem=CreateTrigger()
        trigger AII__dealloItem=CreateTrigger() //Callback triggers
trigger AII__pickUpItem=CreateTrigger()
        trigger AII__sellItem=CreateTrigger()
        trigger AII__pawnItem=CreateTrigger() //Event triggers
integer AII__EventStruct=0 //Current callback data
item array AII__HashedItem
        boolean AII__IsInited=false
            trigger AII__dropItem=CreateTrigger()
        constant integer AII__HASH_NEXT=53
        constant integer AII__MAX_HASH_VALUE=8191
        integer array AII__HashedInt
//endglobals from AII
//globals from BOSS1:
constant boolean LIBRARY_BOSS1=true
//endglobals from BOSS1
//globals from BufferFunction:
constant boolean LIBRARY_BufferFunction=true
//endglobals from BufferFunction
//globals from Debuff:
constant boolean LIBRARY_Debuff=true
//endglobals from Debuff
//globals from Difficulty:
constant boolean LIBRARY_Difficulty=true
    integer D_HARD=1
    integer D_CRAZY=2
    integer D_HELL=3
    integer Difficulty=D_HARD
    integer GAME_LV = 1
    integer MAX_GAME_LV = 7
    real HORRO_DMG = 0.05
//endglobals from Difficulty
//globals from Distance:
constant boolean LIBRARY_Distance=true
//endglobals from Distance
//globals from DummyCaster:
constant boolean LIBRARY_DummyCaster=true
        // If this is changed, the object merger line must also be changed
        // before the second implementation step is followed.
        constant integer DUMMY_TYPE='dumy'
        
        // This shouldn't be changed, but in some maps perhaps it is necessary.
        constant player DUMMY_OWNER=Player(PLAYER_NEUTRAL_AGGRESSIVE)
        
        // Just because these belong here:
        constant real DummyCaster___CREATED_AT_X=0.0
        constant real DummyCaster___CREATED_AT_Y=0.0
//=====================================================================================
        unit DUMMY=null
//endglobals from DummyCaster
//globals from Effect:
constant boolean LIBRARY_Effect=true
//endglobals from Effect
//globals from EffectString:
constant boolean LIBRARY_EffectString=true
//endglobals from EffectString
//globals from EffectZ:
constant boolean LIBRARY_EffectZ=true
        destructable EffectZ__D
        effect EffectZ__E
//endglobals from EffectZ
//globals from Event:
constant boolean LIBRARY_Event=true
//endglobals from Event
//globals from FloatText:
constant boolean LIBRARY_FloatText=true
//endglobals from FloatText
//globals from HashKeyManager:
constant boolean LIBRARY_HashKeyManager=true
    integer currentKey=-1
//endglobals from HashKeyManager
//globals from HashTable:
constant boolean LIBRARY_HashTable=true
hashtable ht = null 
//endglobals from HashTable
//globals from Height:
constant boolean LIBRARY_Height=true
//endglobals from Height
//globals from HeroData:
constant boolean LIBRARY_HeroData=true
//endglobals from HeroData
//globals from HeroStatus:
constant boolean LIBRARY_HeroStatus=true
    trigger herostatus_t
//endglobals from HeroStatus
//globals from ItmTest:
constant boolean LIBRARY_ItmTest=true
    real itmtest_x
    real itmtest_y
//endglobals from ItmTest
//globals from ListModule:
constant boolean LIBRARY_ListModule=true
//endglobals from ListModule
//globals from Lock:
constant boolean LIBRARY_Lock=true
//endglobals from Lock
//globals from MissleFactory:
constant boolean LIBRARY_MissleFactory=true
//endglobals from MissleFactory
//globals from MonsterDead:
constant boolean LIBRARY_MonsterDead=true
trigger gtrgMonsterDead
//endglobals from MonsterDead
//globals from MonsterTypeData:
constant boolean LIBRARY_MonsterTypeData=true
//endglobals from MonsterTypeData
//globals from Movie:
constant boolean LIBRARY_Movie=true
//endglobals from Movie
//globals from OrderId:
constant boolean LIBRARY_OrderId=true
    integer OI_RIGHT_CLICK_MOVE = 851971
    integer OI_MOVE = 851983
    integer OI_STOP = 851972
    integer OI_JUST_MOVE = 851986
//endglobals from OrderId
//globals from PlayerHero:
constant boolean LIBRARY_PlayerHero=true
//endglobals from PlayerHero
//globals from RegisterSpell:
constant boolean LIBRARY_RegisterSpell=true
    integer kRegistedSpell
//endglobals from RegisterSpell
//globals from Resources:
constant boolean LIBRARY_Resources=true
//endglobals from Resources
//globals from ShootBack:
constant boolean LIBRARY_ShootBack=true
        trigger shoot_back_trg
//endglobals from ShootBack
//globals from ShootSpeed:
constant boolean LIBRARY_ShootSpeed=true
//endglobals from ShootSpeed
//globals from SkillLearn:
constant boolean LIBRARY_SkillLearn=true
//endglobals from SkillLearn
//globals from SummonUtil:
constant boolean LIBRARY_SummonUtil=true
//endglobals from SummonUtil
//globals from T32:
constant boolean LIBRARY_T32=true
        constant real T32_PERIOD=0.03125
        constant integer T32_FPS=R2I(1/T32_PERIOD)
        integer Tick=0 // very useful.

//==============================================================================
        trigger T32__Trig=CreateTrigger()
//endglobals from T32
//globals from Table:
constant boolean LIBRARY_Table=true
    hashtable Table__ht = InitHashtable() // The last hashtable you need
integer Table__grow = 2 // Index generation for Tables (above 2)
integer Table__keys = 0 // Index generation for TableArrays (below 0)
integer array Table__list
    integer Table__lpos = 0 // These two are used to recycle Tables
//endglobals from Table
//globals from TechData:
constant boolean LIBRARY_TechData=true
hashtable tdht = null 
integer tdht_cat = 1
integer tdht_name = 2
integer tdht_tech_need = 3
integer tdht_game_lv_need = 4
integer tdht_base_point = 5
    constant integer tKMANA = 'A004'
    constant integer tSTRONG = 'A010'
    constant integer tANTRAD = 'A01J'
    constant integer tDOGE = 'A00U'
    constant integer tFIRE_CHARGE = 'A00V'
    constant integer tSPEED_SHOOT = 'A00R'
    constant integer tAIM_SHOOT = 'A00Q'
    constant integer tFIRE = 'A00V'
    constant integer tFREZZ = 'A00W'
    constant integer tSAVE = 'A011'
    constant integer tMANA_BOOM = 'A013'
    constant integer TT_GENERAL = 0
    constant integer TT_BLADE = 1
    constant integer TT_MAGIC_HUNTER = 2
    constant integer TT_ICE = 3
    constant integer TT_COUNT = 4
    string array TECH_TREE_NAME[TT_COUNT]
    integer array TECH_TREE_COUNT[TT_COUNT]
    TechTree array TECH_TREES[TT_COUNT]
    integer TECH_COUNT = 0
//endglobals from TechData
//globals from TechUnit:
constant boolean LIBRARY_TechUnit=true
    trigger techUnit
    trigger techUnit2
    unit array bigU
    unit array health
//endglobals from TechUnit
//globals from Text:
constant boolean LIBRARY_Text=true
//endglobals from Text
//globals from TimerUtils:
constant boolean LIBRARY_TimerUtils=true
        constant integer TimerUtils__MAX_HANDLE_ID_COUNT = 408000
        // values lower than 8191: very fast, but very unsafe.
        // values bigger than 8191: not that fast, the bigger the number is the slower the function gets
        // Most maps don't really need a value bigger than 50000 here, but if you are unsure, leave it
        // as the rather inflated value of 408000
        integer array TimerUtils__data[TimerUtils__MAX_HANDLE_ID_COUNT]
        constant integer TimerUtils__MIN_HANDLE_ID=0x100000
        //use a totally random number here, the more improbable someone uses it, the better.
        constant integer TimerUtils__HELD=0x28829022
        timer array TimerUtils__tT
        integer TimerUtils__tN = 0
//endglobals from TimerUtils
//globals from Union:
constant boolean LIBRARY_Union=true
        filterfunc Union__FilterLeisure
//endglobals from Union
//globals from UnitId:
constant boolean LIBRARY_UnitId=true
    integer HERO = 'H002'
    integer ABI_LOCK = 'h005'
    integer ONE_WALL = 'h006'
    integer ONE_WALL_BREAKABLE = 'h007'
//endglobals from UnitId
//globals from Vector:
constant boolean LIBRARY_Vector=true
//endglobals from Vector
//globals from YDTriggerSaveLoadSystem:
constant boolean LIBRARY_YDTriggerSaveLoadSystem=true
       hashtable YDHT
//endglobals from YDTriggerSaveLoadSystem
//globals from YDWEBase:
constant boolean LIBRARY_YDWEBase=true
//全局哈希表 
	string bj_AllString=".................................!.#$%&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................"
//鍏ㄥ眬绯荤粺鍙橀噺
    unit bj_lastAbilityCastingUnit=null
    unit bj_lastAbilityTargetUnit=null
    unit bj_lastPoolAbstractedUnit=null
    unitpool bj_lastCreatedUnitPool=null
    item bj_lastPoolAbstractedItem=null
    itempool bj_lastCreatedItemPool=null
    attacktype bj_lastSetAttackType = ATTACK_TYPE_NORMAL
    damagetype bj_lastSetDamageType = DAMAGE_TYPE_NORMAL
    weapontype bj_lastSetWeaponType = WEAPON_TYPE_WHOKNOWS
    real yd_MapMaxX = 0
    real yd_MapMinX = 0
    real yd_MapMaxY = 0
    real yd_MapMinY = 0
    string array YDWEBase__yd_PlayerColor
    trigger array YDWEBase__AbilityCastingOverEventQueue
    integer array YDWEBase__AbilityCastingOverEventType
    integer YDWEBase__AbilityCastingOverEventNumber = 0
//endglobals from YDWEBase
//globals from YDWEPlaySoundNull:
constant boolean LIBRARY_YDWEPlaySoundNull=true
//endglobals from YDWEPlaySoundNull
//globals from YDWEPolledWaitNull:
constant boolean LIBRARY_YDWEPolledWaitNull=true
//endglobals from YDWEPolledWaitNull
//globals from YDWETriggerEvent:
constant boolean LIBRARY_YDWETriggerEvent=true
    trigger yd_DamageEventTrigger = null
    trigger array YDWETriggerEvent__DamageEventQueue
    integer YDWETriggerEvent__DamageEventNumber = 0
	
    item bj_lastMovedItemInItemSlot = null
	
    trigger YDWETriggerEvent__MoveItemEventTrigger = null
    trigger array YDWETriggerEvent__MoveItemEventQueue
    integer YDWETriggerEvent__MoveItemEventNumber = 0
//endglobals from YDWETriggerEvent
//globals from YDWETriggerRegisterEnterRectSimpleNull:
constant boolean LIBRARY_YDWETriggerRegisterEnterRectSimpleNull=true
    region yd_NullTempRegion
//endglobals from YDWETriggerRegisterEnterRectSimpleNull
//globals from YDWETriggerRegisterLeaveRectSimpleNull:
constant boolean LIBRARY_YDWETriggerRegisterLeaveRectSimpleNull=true
//endglobals from YDWETriggerRegisterLeaveRectSimpleNull
//globals from AutoIndex:
constant boolean LIBRARY_AutoIndex=true
//endglobals from AutoIndex
//globals from Constants:
constant boolean LIBRARY_Constants=true
//endglobals from Constants
//globals from Damage:
constant boolean LIBRARY_Damage=true
        constant integer Damage__LIFE_BONUS_ABIL='A000'
        Event Damage__OnDamageEvent
        boolean Damage__EventEnabled=true
        integer Damage__TypeStackLevel=0
        damagetype array Damage__TypeStackValue
        real array Damage__ToBlock
        integer Damage__BlockNum=0
        unit array Damage__BlockUnit
        real array Damage__BlockUnitLife
        real array Damage__BlockRedamage
        unit array Damage__BlockDamageSource
        
        timer Damage__BlockTimer=CreateTimer()
        unit array Damage__RemoveBoosted
        integer Damage__RemoveBoostedMax=0
        
        timer Damage__RemoveBoostedTimer=CreateTimer()
        real Damage__BoostedLifeTemp
        unit Damage__BoostedLifeUnit
        unit Damage__ForUnit
        real Damage__NextHealth
//endglobals from Damage
//globals from Direction:
constant boolean LIBRARY_Direction=true
//endglobals from Direction
//globals from DispatchTechLevel:
constant boolean LIBRARY_DispatchTechLevel=true
//endglobals from DispatchTechLevel
//globals from DoublePacket:
constant boolean LIBRARY_DoublePacket=true
        integer gpacauid='h001'
        integer gpacspl='A001'
        integer kpacau
        integer kRegedPac
//endglobals from DoublePacket
//globals from GroupUtils:
constant boolean LIBRARY_GroupUtils=true
        //* Group for use with all instant enumerations
        group ENUM_GROUP = CreateGroup()
        //* Temporary references for GroupRefresh
        boolean GroupUtils__Flag = false
        group GroupUtils__Refr = null
        //* Assorted constants
        constant integer GroupUtils__MAX_HANDLE_COUNT = 408000
        constant integer GroupUtils__MIN_HANDLE_ID = 0x100000
        //* Arrays and counter for the group stack
        group array GroupUtils__Groups
        integer array GroupUtils__Status[GroupUtils__MAX_HANDLE_COUNT]
        integer GroupUtils__Count = 0
//endglobals from GroupUtils
//globals from Gun:
constant boolean LIBRARY_Gun=true
//endglobals from Gun
//globals from Heal:
constant boolean LIBRARY_Heal=true
        HealType HEAL_TYPE_NORMAL
        boolean Heal__IsEventEnabled = true
        Event Heal__HealEvent
        unit array Heal__HealerStack
        unit array Heal__TargetStack
        real array Heal__HealAmountStack
        real array Heal__HealBlockStack
        HealType array Heal__TypeStack
        integer Heal__StackLevel = 0 //Prevent the returned value from messing up.
//endglobals from Heal
//globals from ItemData:
constant boolean LIBRARY_ItemData=true
hashtable idht = null 
hashtable ifht1 = null
hashtable ifht2 = null
hashtable ifht3 = null
hashtable ifht4 = null
hashtable ifht5 = null
integer idht_name = 1
integer idht_spell = 2
integer idht_item_type = 3
integer idht_s1 = 4
integer idht_s2 = 5
integer idht_s3 = 6
integer ifht_name = 1
integer ifht_origin = 2
integer ifht_step = 3
integer ifht_lv = 4
integer ifht_max_lv = 5
integer ifht_gold = 6
integer ifht_wood = 7
integer ifht_desc = 8
//endglobals from ItemData
//globals from Job:
constant boolean LIBRARY_Job=true
//endglobals from Job
//globals from JumpFacingStore:
constant boolean LIBRARY_JumpFacingStore=true
    trigger jumpPointFacing_t
//endglobals from JumpFacingStore
//globals from Material:
constant boolean LIBRARY_Material=true
    string MC_BULLET = "mc_bullet"
    string MC_UNIT = "mc_unit"
    string MC_ARROW = "mc_arrow"
    string MC_EFFECT = "mc_effect"
    string MC_BUILDING = "mc_building"
    string MC_STONE = "mc_stone"
    string MC_MINE = "mc_mine"
    string MC_WALL = "mc_wall"
    string MC_WALL_DESTORYABLE = "mc_wall_destoryable"
    string MC_RING = "mc_ring"
    string GROUND_SMOOTH = "GROUND_SMOOTH"
    string GROUND_DESTROY = "ground_destroy"
    string GROUND_BOUNCE = "ground_bounce"
    string GROUND_STICK = "ground_stick"
//endglobals from Material
//globals from MonsterBonus:
constant boolean LIBRARY_MonsterBonus=true
//endglobals from MonsterBonus
//globals from Move:
constant boolean LIBRARY_Move=true
    rect area
    real lx
    real ry
    real ly
    real rx
    real lz
    real rz
    region playable_region
//endglobals from Move
//globals from PUI:
constant boolean LIBRARY_PUI=true
//endglobals from PUI
//globals from Revive:
constant boolean LIBRARY_Revive=true
//endglobals from Revive
//globals from SpellStruct:
constant boolean LIBRARY_SpellStruct=true
        constant real SpellStruct__MAX_UNIT_COLLISION_SIZE=256.0
        group SpellStruct__GROUP=CreateGroup()
        hashtable SpellStruct__STORE=InitHashtable() // attaches to:
// abilid, methodkey
// abilid, unit
// timer, key
// trigger, key
// spellstruct, method (timer)
// spellstruct, method (trigger)
        constant key SpellStruct__ALLOCATOR
        SpellStruct__DefaultsInterface SpellStruct__ThisCastData
        integer SpellStruct__CastingAbility
        constant key SpellStruct__TIMER_DATA
        constant key SpellStruct__TRIGGER_DATA
//endglobals from SpellStruct
//globals from Status:
constant boolean LIBRARY_Status=true
        constant real Status___PERIOD=0.1 // for regen effects.
constant player Status___DUMMY_CASTER_OWNER=Player(PLAYER_NEUTRAL_PASSIVE)
        constant boolean Status___PERMENANTLY_REVEAL=true // reveal all units always, or only during dummy spells

        // To change these, change them also in the externalblock before executing it.
        constant integer Status___ABIL_STUN='A500'
        constant integer Status___ABIL_SILENCE='A501'
        constant integer Status___ABIL_DISARM_BOTH='A502'
        constant integer Status___ABIL_DISARM_MELEE='A503'
        constant integer Status___ABIL_DISARM_RANGE='A504'
        constant integer Status___ABIL_IMMOBOLISE='A505'
        constant integer Status___ABIL_INVISIBLE='A507'
        constant integer Status___ABIL_GHOST='A508'
        constant integer Status___ABIL_DOOM='A509'
        constant integer Status___ABIL_IMMUNITY='A50B'
        constant integer Status___ABIL_HEX='A50C'
        constant integer Status___ABIL_UNLOCUST='A50D'
        constant integer Status___ABIL_NEVER_MISS='A50F'
        constant integer Status___ABIL_ALWAYS_MISS='A50H'
        constant integer Status___ABIL_UNTOUCHABLE='A50J'
        constant integer Status___ABIL_BANISH='A50K'
        constant integer Status___ABIL_PHASE='A50L'
        //private constant integer ABIL_DOUBLE_ATTACK='A50O'
        constant integer Status___ABIL_RESISTANT_SKIN='A50Q'
        constant integer Status___ABIL_REFLECT_PIERCING='A50S'
        constant integer Status___ABIL_DISABLE='A50T'
        
        constant integer Status___ABIL_ARMOR='A5A@'
        constant integer Status___ABIL_DAMAGE='A5B@'
        constant integer Status___ABIL_STR='A5C@'
        constant integer Status___ABIL_AGI='A5D@'
        constant integer Status___ABIL_INT='A5E@'
        constant integer Status___ABIL_ATTACK_SPEED='A5F@'
        constant integer Status___ABIL_HEALTH='A5G@'
        constant integer Status___ABIL_MANA='A5H@'
        
        constant integer Status___LEVELS_ARMOR=10
        constant integer Status___LEVELS_DAMAGE=15
        constant integer Status___LEVELS_STR=10
        constant integer Status___LEVELS_AGI=10
        constant integer Status___LEVELS_INT=10
        constant integer Status___LEVELS_ATTACK_SPEED=9
        constant integer Status___LEVELS_HEALTH=20
        constant integer Status___LEVELS_MANA=20
        
        // To change these, change them also in the externalblock before executing it.
        constant integer Status___BUFF_STUN='B500'
        constant integer Status___BUFF_SILENCE='B501'
        constant integer Status___BUFF_DOOM='B509'
        constant integer Status___BUFF_DISARM_MELEE='B503'
        constant integer Status___BUFF_DISARM_RANGE='B504'
        constant integer Status___BUFF_DISARM_BOTH='B502'
        constant integer Status___BUFF_IMMOBOLISE_GROUND='B505'
        constant integer Status___BUFF_IMMOBOLISE_AIR='B506'
        constant integer Status___BUFF_HEX='B50C'
        constant integer Status___BUFF_BANISH='B50K'
        constant integer Status___BUFF_PHASE='B50L'
        constant integer Status___BUFF_DISABLE='B50T'
        
        constant integer Status___OID_STOP=851972 //stop
constant integer Status___OID_STUN=852231 //firebolt
constant integer Status___OID_SILENCE=852668 //soulburn
constant integer Status___OID_DISARM=852585 //drunkenhaze
constant integer Status___OID_IMMOBOLISE=852106 //ensnare
constant integer Status___OID_DOOM=852583 //doom
constant integer Status___OID_HEX=852502 //hex
constant integer Status___OID_UNLOCUST=852155 //ravenform
constant integer Status___OID_BANISH=852486 //banish
constant integer Status___OID_PHASE=852129 //windwalk
constant integer Status___OID_DISABLE=852252 //creepthunderbolt (hurlboulder)

        unit Status___CASTER_DISARM_BOTH=null
        unit Status___CASTER_DISARM_MELEE=null
        unit Status___CASTER_DISARM_RANGE=null
//endglobals from Status
//globals from TransportBuffer:
constant boolean LIBRARY_TransportBuffer=true
//endglobals from TransportBuffer
//globals from VectorLib:
constant boolean LIBRARY_VectorLib=true
//endglobals from VectorLib
//globals from YDWETimerSystem:
constant boolean LIBRARY_YDWETimerSystem=true
	integer YDWETimerSystem__CurrentTime
	integer YDWETimerSystem__CurrentIndex
    integer YDWETimerSystem__TaskListHead
    integer YDWETimerSystem__TaskListIdleHead
    integer YDWETimerSystem__TaskListIdleMax
    integer array YDWETimerSystem__TaskListIdle
    integer array YDWETimerSystem__TaskListNext
    integer array YDWETimerSystem__TaskListTime
    trigger array YDWETimerSystem__TaskListProc //函数组
trigger YDWETimerSystem__fnRemoveUnit //移除单位函数
trigger YDWETimerSystem__fnDestroyTimer //摧毁计时器
trigger YDWETimerSystem__fnRemoveItem //移除物品
trigger YDWETimerSystem__fnDestroyEffect //删除特效
trigger YDWETimerSystem__fnDestroyLightning //删除删掉特效
trigger YDWETimerSystem__fnRunTrigger //运行触发器
timer YDWETimerSystem__Timer //最小时间计时器  系统计时器  用于一些需要精确计时的功能
integer YDWETimerSystem__TimerHandle
	integer YDWETimerSystem__TimerSystem_RunIndex = 0
//endglobals from YDWETimerSystem
//globals from CameraLock:
constant boolean LIBRARY_CameraLock=true
    timer cltimer
//endglobals from CameraLock
//globals from FakeMan:
constant boolean LIBRARY_FakeMan=true
    string LV_FREEZ = "LV_FREEZ"
    string LV_ACTIVE = "LV_ACTIVE"
    string LV_DESTORY = "LV_DESTORY"
    real LV_FREEZ_DISTANCE = 300000000000000
//endglobals from FakeMan
//globals from FogControl:
constant boolean LIBRARY_FogControl=true
    timer fctimer
    fogmodifier array fogms[PLAYER_COUNT]
    fogmodifier array gfm[PLAYER_COUNT]
//endglobals from FogControl
//globals from ItemEquip:
constant boolean LIBRARY_ItemEquip=true
    integer kit
    trigger t
    trigger t2
//endglobals from ItemEquip
//globals from NetBuffer:
constant boolean LIBRARY_NetBuffer=true
//endglobals from NetBuffer
//globals from ShootTarget:
constant boolean LIBRARY_ShootTarget=true
trigger gtrgShootTarget
trigger gtrgShootMove
trigger gtrgShootChange
real lastshoot = 0
//endglobals from ShootTarget
//globals from Strong:
constant boolean LIBRARY_Strong=true
    trigger doStrong_t
//endglobals from Strong
//globals from Stun:
constant boolean LIBRARY_Stun=true
//endglobals from Stun
//globals from TargetFilter:
constant boolean LIBRARY_TargetFilter=true
//endglobals from TargetFilter
//globals from AIData:
constant boolean LIBRARY_AIData=true
//endglobals from AIData
//globals from AIGroup:
constant boolean LIBRARY_AIGroup=true
//endglobals from AIGroup
//globals from DialogSystem:
constant boolean LIBRARY_DialogSystem=true
//endglobals from DialogSystem
//globals from HorrorOrder:
constant boolean LIBRARY_HorrorOrder=true
//endglobals from HorrorOrder
//globals from AIStrategy:
constant boolean LIBRARY_AIStrategy=true
DefaultAIGroup gDefaultAIGroup
FleeGroup gFleeGroup
IAIStrategy gDefaultAIStrategy
IAIStrategy gBoss1AIStrategy
IAIStrategy gWandRanger
IAIStrategy gFleeRanger
//endglobals from AIStrategy
//globals from CustomDamage:
constant boolean LIBRARY_CustomDamage=true
//endglobals from CustomDamage
//globals from MonsterTargetGroup:
constant boolean LIBRARY_MonsterTargetGroup=true
    group MonsterTargetGroup
    MonsterTargetGroupManager mtm
    group MeleeGroup
//endglobals from MonsterTargetGroup
//globals from Transform:
constant boolean LIBRARY_Transform=true
    trigger transform_t
//endglobals from Transform
//globals from Buffer:
constant boolean LIBRARY_Buffer=true
    timer moveTimer
//endglobals from Buffer
//globals from Radiation:
constant boolean LIBRARY_Radiation=true
    trigger doRadiation_t
//endglobals from Radiation
//globals from Stage1:
constant boolean LIBRARY_Stage1=true
    integer s1w1c = 50
    integer s1w2c = 100
    integer s1w3c = 3
    boolean test = true
//endglobals from Stage1
//globals from PhysicsSystem:
constant boolean LIBRARY_PhysicsSystem=true
//endglobals from PhysicsSystem
//globals from EquipmentData:
constant boolean LIBRARY_EquipmentData=true
//endglobals from EquipmentData
//globals from Missle:
constant boolean LIBRARY_Missle=true
//endglobals from Missle
//globals from Shooter:
constant boolean LIBRARY_Shooter=true
//endglobals from Shooter
//globals from AIAttack:
constant boolean LIBRARY_AIAttack=true
trigger gtrgAIAttack
//endglobals from AIAttack
//globals from Velocity:
constant boolean LIBRARY_Velocity=true
    real u = 1.5
    real us = 3
    real g = 9.8
    group COLLISION_GROUP
    timer missleMoveTimer
    timer collisionGroupTimer
//endglobals from Velocity
    // User-defined
    real udg_r = 0
    // Generated
    rect gg_rct_lock_1 = null
    rect gg_rct_lock_2 = null
    rect gg_rct_lock_3 = null
    rect gg_rct_lock_11 = null
    rect gg_rct_start = null
    rect gg_rct_start_road_1 = null
    rect gg_rct_start_road_gate = null
    rect gg_rct_pow0 = null
    rect gg_rct_pow3 = null
    rect gg_rct_pow2 = null
    rect gg_rct_pow1 = null
    rect gg_rct_itmtest = null
    rect gg_rct_tower2 = null
    rect gg_rct_tower0 = null
    rect gg_rct_tower3 = null
    rect gg_rct_tower1 = null
    rect gg_rct_tech = null
    rect gg_rct_stage1_start = null
    rect gg_rct_pick_hero = null
    rect gg_rct_stage1 = null
    rect gg_rct_stage1_tlcannon = null
    rect gg_rct_mancome = null
    rect gg_rct_stage1_hero = null
    rect gg_rct_stag1_speed1 = null
    rect gg_rct_stag1_speed2 = null
    rect gg_rct_stag1_speed3 = null
    rect gg_rct_stage1_wall1 = null
    rect gg_rct_stage2_start = null
    rect gg_rct_stage1_exit = null
    rect gg_rct_stage2_1 = null
    rect gg_rct_stage2_2 = null
    rect gg_rct_stage2_3 = null
    rect gg_rct_stage2_jump1 = null
    rect gg_rct_stage2_fire1 = null
    rect gg_rct_stage2_fire2 = null
    rect gg_rct_stage2_fire3 = null
    rect gg_rct_stage2_refresh1 = null
    rect gg_rct_stage2_refresh2 = null
    rect gg_rct_stage2_refresh3 = null
    rect gg_rct_stage2_refresh4 = null
    rect gg_rct_stage2_refresh5 = null
    rect gg_rct_stage2_refresh6 = null
    rect gg_rct_stage2_refresh7 = null
    rect gg_rct_stage2_refresh8 = null
    rect gg_rct_stage2_refresh9 = null
    rect gg_rct_stage2_4 = null
    rect gg_rct_stage2_5 = null
    rect gg_rct_stage2_6 = null
    rect gg_rct_stage2_speed1 = null
    rect gg_rct_stage2_speed2 = null
    rect gg_rct_stage2_speed3 = null
    rect gg_rct_stage2_speed4 = null
    rect gg_rct_stage2_7 = null
    rect gg_rct_stage2_8 = null
    rect gg_rct_stage2_gate = null
    rect gg_rct_stage2_9 = null
    rect gg_rct_stage3_jump_up = null
    rect gg_rct_stage3_jump_down = null
    rect gg_rct_stage3_jump_right = null
    rect gg_rct_stage3_jump_left = null
    rect gg_rct_stage3_start = null
    rect gg_rct_stage3 = null
    rect gg_rct_stage3_pow_ul = null
    rect gg_rct_stage3_pow_ur = null
    rect gg_rct_stage3_pow_dr = null
    rect gg_rct_stage3_pow_dl = null
    rect gg_rct_stage3_center = null
    rect gg_rct_stage3_way = null
    rect gg_rct_stage3_end = null
    camerasetup gg_cam_lv1 = null
    sound gg_snd_clipin1 = null
    sound gg_snd_WindWalk = null
    sound gg_snd_AxeMissileLaunch1 = null
    sound gg_snd_alicebeep = null
    sound gg_snd_togglefiremode = null
    sound gg_snd_clipempty = null
    sound gg_snd_togglemeele = null
    sound gg_snd_reload = null
    sound gg_snd_equip2 = null
    sound gg_snd_equip1 = null
    sound gg_snd_transport = null
    sound gg_snd_opengate = null
    trigger gg_trg_Stage2Gate = null
    trigger gg_trg_Stage1 = null
    trigger gg_trg_Stage1T = null
    trigger gg_trg_PickHero = null
    trigger gg_trg_Resources = null
    trigger gg_trg_StartRoom = null
    trigger gg_trg_level1 = null
    trigger gg_trg_InitJobData = null
    trigger gg_trg_Save = null
    trigger gg_trg_Strong = null
    trigger gg_trg_TransportEnergy = null
    trigger gg_trg_HolyLight = null
    trigger gg_trg_ReviveSpell = null
    trigger gg_trg_DawnHammer = null
    trigger gg_trg_NetGun = null
    trigger gg_trg_ShootBost = null
    trigger gg_trg_PowerPunch = null
    trigger gg_trg_SelectHero = null
    trigger gg_trg_Reload = null
    trigger gg_trg_ItemJump = null
    trigger gg_trg_GunSpell = null
    trigger gg_trg_Jump = null
    trigger gg_trg_JumpFacingStore = null
    trigger gg_trg_InjectionSpeedUp = null
    trigger gg_trg_RegisterSpell = null
    trigger gg_trg_Darts = null
    trigger gg_trg_RetrunDarts = null
    trigger gg_trg_SmartDarts = null
    trigger gg_trg_ExplodeSmartDarts = null
    trigger gg_trg_ShoulderCannon = null
    trigger gg_trg_ItemRetrunDarts = null
    trigger gg_trg_LeaveDarts = null
    trigger gg_trg_DartsStorm = null
    trigger gg_trg_GuardDarts = null
    trigger gg_trg_BackGrenade = null
    trigger gg_trg_Mine = null
    trigger gg_trg_PushGrenade = null
    trigger gg_trg_Blink = null
    trigger gg_trg_Transport = null
    trigger gg_trg_ElectricWhip = null
    trigger gg_trg_AutoAim = null
    trigger gg_trg_ShootBack = null
    trigger gg_trg_TeckLock = null
    trigger gg_trg_Register = null
    trigger gg_trg_RegisterFly = null
    trigger gg_trg_FireRegion = null
    trigger gg_trg_SpeedUp = null
    trigger gg_trg_SummonUtil = null
    trigger gg_trg_Revive = null
    trigger gg_trg_ManaChange = null
    trigger gg_trg_ManaGrow = null
    trigger gg_trg_TechUnit = null
    trigger gg_trg_Effect = null
    trigger gg_trg_CameraAdjust = null
    trigger gg_trg_FogControl = null
    trigger gg_trg_CameraLock = null
    trigger gg_trg_Movie = null
    trigger gg_trg_GV = null
    trigger gg_trg_LearnAbility = null
    trigger gg_trg_TriggerKillHpBuff = null
    trigger gg_trg_TriggerHorro = null
    trigger gg_trg_HorrorOrderFilter = null
    trigger gg_trg_HorrorOrder = null
    trigger gg_trg_OrderId = null
    trigger gg_trg_ShootSpeed = null
    trigger gg_trg_Radiation = null
    trigger gg_trg_ArrayList = null
    trigger gg_trg_ChooseTech = null
    trigger gg_trg_ChooseBonus = null
    trigger gg_trg_TechLevelUp = null
    trigger gg_trg_TechData = null
    trigger gg_trg_Transform = null
    trigger gg_trg_ChangeAbility = null
    trigger gg_trg_DialogSystem = null
    trigger gg_trg_Buffer = null
    trigger gg_trg_TransportBuffer = null
    trigger gg_trg_SpeedStateBuffer = null
    trigger gg_trg_NetBuffer = null
    trigger gg_trg_ShootBostBuffer = null
    trigger gg_trg_SpeedColBuffer = null
    trigger gg_trg_BurnBuffer = null
    trigger gg_trg_HorroBuffer = null
    trigger gg_trg_FloatBuffer = null
    trigger gg_trg_BleedBuffer = null
    trigger gg_trg_IceSlowBuffer = null
    trigger gg_trg_AutoAimBuffer = null
    trigger gg_trg_Debuff = null
    trigger gg_trg_BufferFunction = null
    trigger gg_trg_Constants = null
    trigger gg_trg_PlayerHero = null
    trigger gg_trg_FocuseHero = null
    trigger gg_trg_ItemData = null
    trigger gg_trg_ItemEquip = null
    trigger gg_trg_ItemType = null
    trigger gg_trg_UnitId = null
    trigger gg_trg_FakeMan = null
    trigger gg_trg_MonsterDead = null
    trigger gg_trg_ShootTarget = null
    trigger gg_trg_MonsterTypeData = null
    trigger gg_trg_MonsterBonus = null
    trigger gg_trg_MonsterTargetGroup = null
    trigger gg_trg_DeathEffect = null
    trigger gg_trg_Difficulty = null
    trigger gg_trg_EffectString = null
    trigger gg_trg_SkillLearn = null
    trigger gg_trg_DoublePacket = null
    trigger gg_trg_Missle = null
    trigger gg_trg_MissleFactory = null
    trigger gg_trg_Gun = null
    trigger gg_trg_WallDeath = null
    trigger gg_trg_Shooter = null
    trigger gg_trg_HeroData = null
    trigger gg_trg_EquipmentData = null
    trigger gg_trg_EMData = null
    trigger gg_trg_EvilMarinData = null
    trigger gg_trg_HeroStatus = null
    trigger gg_trg_Velocity = null
    trigger gg_trg_Material = null
    trigger gg_trg_PhysicsSystem = null
    trigger gg_trg_bordercontrol = null
    trigger gg_trg_TargetFilter = null
    trigger gg_trg_ItemInfo = null
    trigger gg_trg_AIAttack = null
    trigger gg_trg_BOSS1 = null
    trigger gg_trg_AIStrategy = null
    trigger gg_trg_AIGroup = null
    trigger gg_trg_AIData = null
    trigger gg_trg_AIDriver = null
    trigger gg_trg_AIHurted = null
    trigger gg_trg_DummyCaster = null
    trigger gg_trg_Status = null
    trigger gg_trg_Heal = null
    trigger gg_trg_ABC = null
    trigger gg_trg_AII = null
    trigger gg_trg_Table = null
    trigger gg_trg_Height = null
    trigger gg_trg_AddEffectZ = null
    trigger gg_trg_Move = null
    trigger gg_trg_Vector = null
    trigger gg_trg_FloatText = null
    trigger gg_trg_Text = null
    trigger gg_trg_Direction = null
    trigger gg_trg_SpellStruck = null
    trigger gg_trg_Timer_Utils = null
    trigger gg_trg_HashKeyManager = null
    trigger gg_trg_T32 = null
    trigger gg_trg_HashTable = null
    trigger gg_trg_Distance = null
    trigger gg_trg_AIDS = null
    trigger gg_trg_AIDSCleaner = null
    trigger gg_trg_Event = null
    trigger gg_trg_Damage = null
    trigger gg_trg_CustomDamage = null
    trigger gg_trg_Custom_Congregation = null
    trigger gg_trg_List_Module = null
    trigger gg_trg_Group_Utils = null
    trigger gg_trg_ItmTest = null
    trigger gg_trg_CreateItem = null
    trigger gg_trg_cantmove = null
    trigger gg_trg_InitFloatText = null
    trigger gg_trg_3 = null
    trigger gg_trg_Demo_Usage = null
    trigger gg_trg_eventtest = null
    trigger gg_trg_AIListRunner = null
    trigger gg_trg_AIList = null
    trigger gg_trg_ListTEst = null
    trigger gg_trg_EnemyBugSystem2 = null
    trigger gg_trg_AIApproach = null
    trigger gg_trg____________________002 = null
    trigger gg_trg_TestGun = null
    trigger gg_trg____________________003 = null
    trigger gg_trg_camera = null
    trigger gg_trg_inittest = null
    trigger gg_trg____________________001_______u = null
    trigger gg_trg_Zero_Damage_All = null
    unit gg_unit_h00G_0050 = null
    destructable gg_dest_DTg5_0047 = null
    rect gg_rct_stage3_speeddown = null
    rect gg_rct_stage3_speedright = null
    rect gg_rct_stage3_speedup = null
    rect gg_rct_stage3_speedleft = null
    rect gg_rct_stage3_sr2 = null
    rect gg_rct_stage3_sr1 = null
    rect gg_rct_stage3_sr3 = null
    rect gg_rct_stage3_sr4 = null
    rect gg_rct_stage3_hide5 = null
    rect gg_rct_stage3_hide4 = null
    rect gg_rct_stage3_hide1 = null
    rect gg_rct_stage3_hide2 = null
    rect gg_rct_stage3_hide3 = null
constant integer kdamage=0
constant integer ksteps=4
constant integer ktex=13
    integer r_yaocao = 0
    integer r_m_yaocao = 10
    boolean g_ge = false
    region g_gr2
    real g_gx1
    real g_gx2
    real g_gy1
    real g_gy2
    ResourceManager gResourceManager
    trigger gResourcePickTrigger
    region fire_region
    group revgro
    trigger revtrg
    region g_cur_region
    integer cur_player = 0
    integer act1 = 0
    integer act2 = 1
    integer act3 = 2
    boolean g_camera_lock = false
    boolean g_fog = false
    real g_sd_th = 70
    real g_missle_damage = 50
    unit boss1 = null
    integer array camera[PLAYER_COUNT]
    real g_camera_start = 2000
    real g_camera_step = 170
    integer aiintervel = 3
    real buldmg_seed = 50
    real abidmg_seed = 500
    integer ranger='A025'
    integer meeler='A026'
    group netgroup
    constant integer ARRAY_SIZE = 1000
    constant real pi = Deg2Rad(180.0)
    
    constant integer iEXP = 'I00E'
    
    constant integer PLAYER_COUNT = 3
    constant integer iUPGADE = 'I004'
    constant integer iFREEUP = 'I00D'
    constant integer iSPEED = 'I003'
    constant integer iJUMP = 'I002'
    constant integer iRETURN = 'I006'
    constant integer iREACT = 'I007'
    constant integer iELECTRIC = 'I008'
    constant integer iBLINK = 'I009'
    constant integer iTRANSPORT = 'I00A'
    constant integer iAUTOAIM = 'I00B'
    constant integer i100G = 'I00C'
    constant integer iLEAVE = 'I00F'
    constant integer iBKGRENADE = 'I00G'
    constant integer iPSGRENADE = 'I00M'
    constant integer iMINE = 'I00J'
    constant integer bICE_MISSLE = 'e005'
    constant integer bFIRE_MISSLE = 'e006'
    constant integer bELECTRIC = 'e008'
    constant integer aRETURN = 'A002'
    constant integer aREACT = 'A00F'
    constant integer aELECTRIC = 'A00G'
    constant integer aBLINK = 'A00I'
    constant integer aTRANSPORT = 'A00J'
    constant integer aAUTOAIM = 'A00K'
    constant integer aLEAVE = 'A016'
    constant integer aBKGRENADE = 'A017'
    constant integer aPSGRENADE = 'A019'
    constant integer aMINE = 'A01B'
    constant integer aBAN_ATTACK = 'A01M'
    constant integer euCOLLISION = 'e004'
    //constant integer BULLET_MAX_SPEED = 180
    constant integer BULLET_RANGE_ADDON = 10
    constant integer LEAVE_COUNT = 10
    constant integer REDAMAGE_DISTANCE = 200
    constant integer WHO_PLAYER_ID = 7
    constant player WHO_PLAYER = Player(7)
    constant real DAMAGE_SPEED = 5
    constant integer MAGIC = 'u001'
    constant integer MAX_BURN_LV = 5000
    constant integer MAX_BLEED_LV = 5000
    constant integer TECH_UNIT = 'H004'
    constant integer sALL = 'A00M'
    constant integer sSTR = 'A00N'
    constant integer sAGI = 'A00O'
    constant integer sINT = 'A00P'
    constant integer SHOOT_SPEED = 'A015'
    constant real GRENADEDEG = Atan2(2, 1)
    constant integer DEFAULT_ARRAYLIST_SIZE = 64
    constant player MONSTER_PLAYER = Player(11)
    constant integer MONSTER_PLAYER_ID = 11
    constant integer EVIL_MARIN = 'h000'
    constant rect array gg_rct_lock
    constant integer SHOTHZ = 100
    constant string MAJOR_AB = "涓绘鍣?
    constant string MINOR_AB = "鍓鍣?
    unit array heros
    integer picked_hero = 0
    integer array herosType
    unit array techs
    integer array mode_tip
    boolean array refresh_tip
    integer SHOOT_GUN=5
    integer SNAKE_GUN=1
    integer MACHINE_GUN=2
    integer ASSASSINATE_GUN=3
    integer ROCKET_GUN=4
    integer GUN=4
    integer HAND=1
    integer ARMOR=2
    integer SHOE=3
    integer OTHER=5
    integer LONGTERM=7
    integer STATIC=6
    integer I_D = 8
    integer I_T = 9
    integer I_N = 10
    integer AB1 = 11
    integer AB2 = 12
    constant string SMALL_BLOOD="Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl"
    constant string HEAL_EFFECT = "Abilities\\Weapons\\FaerieDragonMissile\\FaerieDragonMissile.mdl"
    constant string BLADE_BLOOD = "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"
    constant string E_BLINK_CASTER = "Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
    constant string E_BLINK_TARGET = "Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
    constant string E_TRANSPORT_TARGET = "Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl"
    constant string E_TRANSPORT_CASTER = "Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl"
    constant string E_KILL_MANA = "Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl"
    constant string E_ELF_BLOOD = "Objects\\Spawnmodels\\Human\\HumanBlood\\HeroBloodElfBlood.mdl"
    constant string E_DOGE = "Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageCaster.mdl"
    constant string E_TUNDER_CLAP = "Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl"
    constant string E_CLAP = "Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"
    constant string E_MINE_EXPLODE = "Abilities\\Weapons\\Mortar\\MortarMissile.mdl"
    constant string E_MANA_BOOM = "Abilities\\Spells\\NightElf\\ManaBurn\\ManaBurnTarget.mdl"
    constant string E_GUN_SHOW = "Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl"

trigger l__library_init
endglobals
//library ABC:
//==============================================================================
//  Collision check functions
//==============================================================================
//------------------------------------------------------------------------------
function GetTimerCollisionA takes nothing returns integer
    return ABC__TimerMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetTimerCollisionB takes nothing returns integer
    return ABC__TimerMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetTimerCollisionC takes nothing returns integer
    return ABC__TimerMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetTriggerCollisionA takes nothing returns integer
    return ABC__TriggerMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetTriggerCollisionB takes nothing returns integer
    return ABC__TriggerMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetTriggerCollisionC takes nothing returns integer
    return ABC__TriggerMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetDialogCollisionA takes nothing returns integer
    return ABC__DialogMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetDialogCollisionB takes nothing returns integer
    return ABC__DialogMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetDialogCollisionC takes nothing returns integer
    return ABC__DialogMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetRegionCollisionA takes nothing returns integer
    return ABC__RegionMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetRegionCollisionB takes nothing returns integer
    return ABC__RegionMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetRegionCollisionC takes nothing returns integer
    return ABC__RegionMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetButtonCollisionA takes nothing returns integer
    return ABC__ButtonMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetButtonCollisionB takes nothing returns integer
    return ABC__ButtonMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetButtonCollisionC takes nothing returns integer
    return ABC__ButtonMaxCollisionC
endfunction
//==============================================================================
//  Set functions
//==============================================================================
//------------------------------------------------------------------------------
function SetTimerStructA takes timer key, integer value returns nothing
//textmacro instance: ABC_Set("A", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__TimerKeyA[i] == null then
        set ABC__TimerKeyA[i] = key
        set ABC__TimerValueA[i] = value
    else
        call SaveInteger(ABC__TimerHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function SetTimerStructB takes timer key, integer value returns nothing
//textmacro instance: ABC_Set("B", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__TimerKeyB[i] == null then
        set ABC__TimerKeyB[i] = key
        set ABC__TimerValueB[i] = value
    else
        call SaveInteger(ABC__TimerHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function SetTimerStructC takes timer key, integer value returns nothing
//textmacro instance: ABC_Set("C", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__TimerKeyC[i] == null then
        set ABC__TimerKeyC[i] = key
        set ABC__TimerValueC[i] = value
    else
        call SaveInteger(ABC__TimerHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function SetTriggerStructA takes trigger key, integer value returns nothing
//textmacro instance: ABC_Set("A", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__TriggerKeyA[i] == null then
        set ABC__TriggerKeyA[i] = key
        set ABC__TriggerValueA[i] = value
    else
        call SaveInteger(ABC__TriggerHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function SetTriggerStructB takes trigger key, integer value returns nothing
//textmacro instance: ABC_Set("B", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__TriggerKeyB[i] == null then
        set ABC__TriggerKeyB[i] = key
        set ABC__TriggerValueB[i] = value
    else
        call SaveInteger(ABC__TriggerHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function SetTriggerStructC takes trigger key, integer value returns nothing
//textmacro instance: ABC_Set("C", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__TriggerKeyC[i] == null then
        set ABC__TriggerKeyC[i] = key
        set ABC__TriggerValueC[i] = value
    else
        call SaveInteger(ABC__TriggerHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function SetDialogStructA takes dialog key, integer value returns nothing
//textmacro instance: ABC_Set("A", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__DialogKeyA[i] == null then
        set ABC__DialogKeyA[i] = key
        set ABC__DialogValueA[i] = value
    else
        call SaveInteger(ABC__DialogHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function SetDialogStructB takes dialog key, integer value returns nothing
//textmacro instance: ABC_Set("B", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__DialogKeyB[i] == null then
        set ABC__DialogKeyB[i] = key
        set ABC__DialogValueB[i] = value
    else
        call SaveInteger(ABC__DialogHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function SetDialogStructC takes dialog key, integer value returns nothing
//textmacro instance: ABC_Set("C", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__DialogKeyC[i] == null then
        set ABC__DialogKeyC[i] = key
        set ABC__DialogValueC[i] = value
    else
        call SaveInteger(ABC__DialogHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function SetRegionStructA takes region key, integer value returns nothing
//textmacro instance: ABC_Set("A", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__RegionKeyA[i] == null then
        set ABC__RegionKeyA[i] = key
        set ABC__RegionValueA[i] = value
    else
        call SaveInteger(ABC__RegionHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function SetRegionStructB takes region key, integer value returns nothing
//textmacro instance: ABC_Set("B", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__RegionKeyB[i] == null then
        set ABC__RegionKeyB[i] = key
        set ABC__RegionValueB[i] = value
    else
        call SaveInteger(ABC__RegionHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function SetRegionStructC takes region key, integer value returns nothing
//textmacro instance: ABC_Set("C", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__RegionKeyC[i] == null then
        set ABC__RegionKeyC[i] = key
        set ABC__RegionValueC[i] = value
    else
        call SaveInteger(ABC__RegionHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function SetButtonStructA takes button key, integer value returns nothing
//textmacro instance: ABC_Set("A", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__ButtonKeyA[i] == null then
        set ABC__ButtonKeyA[i] = key
        set ABC__ButtonValueA[i] = value
    else
        call SaveInteger(ABC__ButtonHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function SetButtonStructB takes button key, integer value returns nothing
//textmacro instance: ABC_Set("B", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__ButtonKeyB[i] == null then
        set ABC__ButtonKeyB[i] = key
        set ABC__ButtonValueB[i] = value
    else
        call SaveInteger(ABC__ButtonHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function SetButtonStructC takes button key, integer value returns nothing
//textmacro instance: ABC_Set("C", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
    if ABC__ButtonKeyC[i] == null then
        set ABC__ButtonKeyC[i] = key
        set ABC__ButtonValueC[i] = value
    else
        call SaveInteger(ABC__ButtonHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Button", "button")
endfunction
//==============================================================================
//  Get functions
//==============================================================================
//------------------------------------------------------------------------------
function GetTimerStructA takes timer key returns integer
//textmacro instance: ABC_Get("A", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TimerKeyA[i] == key then
        return ABC__TimerValueA[i]
    else
        return LoadInteger(ABC__TimerHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function GetTimerStructB takes timer key returns integer
//textmacro instance: ABC_Get("B", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TimerKeyB[i] == key then
        return ABC__TimerValueB[i]
    else
        return LoadInteger(ABC__TimerHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function GetTimerStructC takes timer key returns integer
//textmacro instance: ABC_Get("C", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TimerKeyC[i] == key then
        return ABC__TimerValueC[i]
    else
        return LoadInteger(ABC__TimerHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function GetTriggerStructA takes trigger key returns integer
//textmacro instance: ABC_Get("A", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TriggerKeyA[i] == key then
        return ABC__TriggerValueA[i]
    else
        return LoadInteger(ABC__TriggerHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function GetTriggerStructB takes trigger key returns integer
//textmacro instance: ABC_Get("B", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TriggerKeyB[i] == key then
        return ABC__TriggerValueB[i]
    else
        return LoadInteger(ABC__TriggerHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function GetTriggerStructC takes trigger key returns integer
//textmacro instance: ABC_Get("C", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TriggerKeyC[i] == key then
        return ABC__TriggerValueC[i]
    else
        return LoadInteger(ABC__TriggerHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function GetDialogStructA takes dialog key returns integer
//textmacro instance: ABC_Get("A", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__DialogKeyA[i] == key then
        return ABC__DialogValueA[i]
    else
        return LoadInteger(ABC__DialogHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function GetDialogStructB takes dialog key returns integer
//textmacro instance: ABC_Get("B", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__DialogKeyB[i] == key then
        return ABC__DialogValueB[i]
    else
        return LoadInteger(ABC__DialogHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function GetDialogStructC takes dialog key returns integer
//textmacro instance: ABC_Get("C", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__DialogKeyC[i] == key then
        return ABC__DialogValueC[i]
    else
        return LoadInteger(ABC__DialogHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function GetRegionStructA takes region key returns integer
//textmacro instance: ABC_Get("A", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__RegionKeyA[i] == key then
        return ABC__RegionValueA[i]
    else
        return LoadInteger(ABC__RegionHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function GetRegionStructB takes region key returns integer
//textmacro instance: ABC_Get("B", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__RegionKeyB[i] == key then
        return ABC__RegionValueB[i]
    else
        return LoadInteger(ABC__RegionHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function GetRegionStructC takes region key returns integer
//textmacro instance: ABC_Get("C", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__RegionKeyC[i] == key then
        return ABC__RegionValueC[i]
    else
        return LoadInteger(ABC__RegionHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function GetButtonStructA takes button key returns integer
//textmacro instance: ABC_Get("A", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__ButtonKeyA[i] == key then
        return ABC__ButtonValueA[i]
    else
        return LoadInteger(ABC__ButtonHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function GetButtonStructB takes button key returns integer
//textmacro instance: ABC_Get("B", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__ButtonKeyB[i] == key then
        return ABC__ButtonValueB[i]
    else
        return LoadInteger(ABC__ButtonHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function GetButtonStructC takes button key returns integer
//textmacro instance: ABC_Get("C", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__ButtonKeyC[i] == key then
        return ABC__ButtonValueC[i]
    else
        return LoadInteger(ABC__ButtonHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Button", "button")
endfunction
//==============================================================================
//  Clear functions
//==============================================================================
//------------------------------------------------------------------------------
function ClearTimerStructA takes timer key returns integer
//textmacro instance: ABC_Clear("A", "Timer", "timer")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TimerKeyA[i] == key then
        set ret = ABC__TimerValueA[i]
        set ABC__TimerKeyA[i] = null
        set ABC__TimerValueA[i] = 0
    else
        if HaveSavedInteger(ABC__TimerHash, 'A', GetHandleId(key)) then
            set ret = LoadInteger(ABC__TimerHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC__TimerHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTimerStructA("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function ClearTimerStructB takes timer key returns integer
//textmacro instance: ABC_Clear("B", "Timer", "timer")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TimerKeyB[i] == key then
        set ret = ABC__TimerValueB[i]
        set ABC__TimerKeyB[i] = null
        set ABC__TimerValueB[i] = 0
    else
        if HaveSavedInteger(ABC__TimerHash, 'B', GetHandleId(key)) then
            set ret = LoadInteger(ABC__TimerHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC__TimerHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTimerStructB("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function ClearTimerStructC takes timer key returns integer
//textmacro instance: ABC_Clear("C", "Timer", "timer")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TimerKeyC[i] == key then
        set ret = ABC__TimerValueC[i]
        set ABC__TimerKeyC[i] = null
        set ABC__TimerValueC[i] = 0
    else
        if HaveSavedInteger(ABC__TimerHash, 'C', GetHandleId(key)) then
            set ret = LoadInteger(ABC__TimerHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC__TimerHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTimerStructC("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function ClearTriggerStructA takes trigger key returns integer
//textmacro instance: ABC_Clear("A", "Trigger", "trigger")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TriggerKeyA[i] == key then
        set ret = ABC__TriggerValueA[i]
        set ABC__TriggerKeyA[i] = null
        set ABC__TriggerValueA[i] = 0
    else
        if HaveSavedInteger(ABC__TriggerHash, 'A', GetHandleId(key)) then
            set ret = LoadInteger(ABC__TriggerHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC__TriggerHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTriggerStructA("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function ClearTriggerStructB takes trigger key returns integer
//textmacro instance: ABC_Clear("B", "Trigger", "trigger")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TriggerKeyB[i] == key then
        set ret = ABC__TriggerValueB[i]
        set ABC__TriggerKeyB[i] = null
        set ABC__TriggerValueB[i] = 0
    else
        if HaveSavedInteger(ABC__TriggerHash, 'B', GetHandleId(key)) then
            set ret = LoadInteger(ABC__TriggerHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC__TriggerHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTriggerStructB("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function ClearTriggerStructC takes trigger key returns integer
//textmacro instance: ABC_Clear("C", "Trigger", "trigger")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__TriggerKeyC[i] == key then
        set ret = ABC__TriggerValueC[i]
        set ABC__TriggerKeyC[i] = null
        set ABC__TriggerValueC[i] = 0
    else
        if HaveSavedInteger(ABC__TriggerHash, 'C', GetHandleId(key)) then
            set ret = LoadInteger(ABC__TriggerHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC__TriggerHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTriggerStructC("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function ClearDialogStructA takes dialog key returns integer
//textmacro instance: ABC_Clear("A", "Dialog", "dialog")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__DialogKeyA[i] == key then
        set ret = ABC__DialogValueA[i]
        set ABC__DialogKeyA[i] = null
        set ABC__DialogValueA[i] = 0
    else
        if HaveSavedInteger(ABC__DialogHash, 'A', GetHandleId(key)) then
            set ret = LoadInteger(ABC__DialogHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC__DialogHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearDialogStructA("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function ClearDialogStructB takes dialog key returns integer
//textmacro instance: ABC_Clear("B", "Dialog", "dialog")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__DialogKeyB[i] == key then
        set ret = ABC__DialogValueB[i]
        set ABC__DialogKeyB[i] = null
        set ABC__DialogValueB[i] = 0
    else
        if HaveSavedInteger(ABC__DialogHash, 'B', GetHandleId(key)) then
            set ret = LoadInteger(ABC__DialogHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC__DialogHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearDialogStructB("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function ClearDialogStructC takes dialog key returns integer
//textmacro instance: ABC_Clear("C", "Dialog", "dialog")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__DialogKeyC[i] == key then
        set ret = ABC__DialogValueC[i]
        set ABC__DialogKeyC[i] = null
        set ABC__DialogValueC[i] = 0
    else
        if HaveSavedInteger(ABC__DialogHash, 'C', GetHandleId(key)) then
            set ret = LoadInteger(ABC__DialogHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC__DialogHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearDialogStructC("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function ClearRegionStructA takes region key returns integer
//textmacro instance: ABC_Clear("A", "Region", "region")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__RegionKeyA[i] == key then
        set ret = ABC__RegionValueA[i]
        set ABC__RegionKeyA[i] = null
        set ABC__RegionValueA[i] = 0
    else
        if HaveSavedInteger(ABC__RegionHash, 'A', GetHandleId(key)) then
            set ret = LoadInteger(ABC__RegionHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC__RegionHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearRegionStructA("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function ClearRegionStructB takes region key returns integer
//textmacro instance: ABC_Clear("B", "Region", "region")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__RegionKeyB[i] == key then
        set ret = ABC__RegionValueB[i]
        set ABC__RegionKeyB[i] = null
        set ABC__RegionValueB[i] = 0
    else
        if HaveSavedInteger(ABC__RegionHash, 'B', GetHandleId(key)) then
            set ret = LoadInteger(ABC__RegionHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC__RegionHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearRegionStructB("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function ClearRegionStructC takes region key returns integer
//textmacro instance: ABC_Clear("C", "Region", "region")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__RegionKeyC[i] == key then
        set ret = ABC__RegionValueC[i]
        set ABC__RegionKeyC[i] = null
        set ABC__RegionValueC[i] = 0
    else
        if HaveSavedInteger(ABC__RegionHash, 'C', GetHandleId(key)) then
            set ret = LoadInteger(ABC__RegionHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC__RegionHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearRegionStructC("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function ClearButtonStructA takes button key returns integer
//textmacro instance: ABC_Clear("A", "Button", "button")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__ButtonKeyA[i] == key then
        set ret = ABC__ButtonValueA[i]
        set ABC__ButtonKeyA[i] = null
        set ABC__ButtonValueA[i] = 0
    else
        if HaveSavedInteger(ABC__ButtonHash, 'A', GetHandleId(key)) then
            set ret = LoadInteger(ABC__ButtonHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC__ButtonHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearButtonStructA("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function ClearButtonStructB takes button key returns integer
//textmacro instance: ABC_Clear("B", "Button", "button")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__ButtonKeyB[i] == key then
        set ret = ABC__ButtonValueB[i]
        set ABC__ButtonKeyB[i] = null
        set ABC__ButtonValueB[i] = 0
    else
        if HaveSavedInteger(ABC__ButtonHash, 'B', GetHandleId(key)) then
            set ret = LoadInteger(ABC__ButtonHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC__ButtonHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearButtonStructB("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function ClearButtonStructC takes button key returns integer
//textmacro instance: ABC_Clear("C", "Button", "button")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC__HASH) * ABC__HASH
	
    if ABC__ButtonKeyC[i] == key then
        set ret = ABC__ButtonValueC[i]
        set ABC__ButtonKeyC[i] = null
        set ABC__ButtonValueC[i] = 0
    else
        if HaveSavedInteger(ABC__ButtonHash, 'C', GetHandleId(key)) then
            set ret = LoadInteger(ABC__ButtonHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC__ButtonHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearButtonStructC("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Button", "button")
endfunction
//==============================================================================
//  Initialization
//==============================================================================
function ABC__Init takes nothing returns nothing
    set ABC__TimerKeyA[ABC__HASH-1] = null
    set ABC__TimerKeyB[ABC__HASH-1] = null
    set ABC__TimerKeyC[ABC__HASH-1] = null
    set ABC__TriggerKeyA[ABC__HASH-1] = null
    set ABC__TriggerKeyB[ABC__HASH-1] = null
    set ABC__TriggerKeyC[ABC__HASH-1] = null
    set ABC__DialogKeyA[ABC__HASH-1] = null
    set ABC__DialogKeyB[ABC__HASH-1] = null
    set ABC__DialogKeyC[ABC__HASH-1] = null
    set ABC__RegionKeyA[ABC__HASH-1] = null
    set ABC__RegionKeyB[ABC__HASH-1] = null
    set ABC__RegionKeyC[ABC__HASH-1] = null
    set ABC__ButtonKeyA[ABC__HASH-1] = null
    set ABC__ButtonKeyB[ABC__HASH-1] = null
    set ABC__ButtonKeyC[ABC__HASH-1] = null
    
    set ABC__TimerValueA[ABC__HASH-1] = 0
    set ABC__TimerValueB[ABC__HASH-1] = 0
    set ABC__TimerValueC[ABC__HASH-1] = 0
    set ABC__TriggerValueA[ABC__HASH-1] = 0
    set ABC__TriggerValueB[ABC__HASH-1] = 0
    set ABC__TriggerValueC[ABC__HASH-1] = 0
    set ABC__DialogValueA[ABC__HASH-1] = 0
    set ABC__DialogValueB[ABC__HASH-1] = 0
    set ABC__DialogValueC[ABC__HASH-1] = 0
    set ABC__RegionValueA[ABC__HASH-1] = 0
    set ABC__RegionValueB[ABC__HASH-1] = 0
    set ABC__RegionValueC[ABC__HASH-1] = 0 
    set ABC__ButtonValueA[ABC__HASH-1] = 0
    set ABC__ButtonValueB[ABC__HASH-1] = 0
    set ABC__ButtonValueC[ABC__HASH-1] = 0
    
    set ABC__TimerCollisionA[ABC__HASH-1] = 0
    set ABC__TimerCollisionB[ABC__HASH-1] = 0
    set ABC__TimerCollisionC[ABC__HASH-1] = 0
    set ABC__TriggerCollisionA[ABC__HASH-1] = 0
    set ABC__TriggerCollisionB[ABC__HASH-1] = 0
    set ABC__TriggerCollisionC[ABC__HASH-1] = 0
    set ABC__DialogCollisionA[ABC__HASH-1] = 0
    set ABC__DialogCollisionB[ABC__HASH-1] = 0
    set ABC__DialogCollisionC[ABC__HASH-1] = 0
    set ABC__RegionCollisionA[ABC__HASH-1] = 0
    set ABC__RegionCollisionB[ABC__HASH-1] = 0
    set ABC__RegionCollisionC[ABC__HASH-1] = 0 
    set ABC__ButtonCollisionA[ABC__HASH-1] = 0
    set ABC__ButtonCollisionB[ABC__HASH-1] = 0
    set ABC__ButtonCollisionC[ABC__HASH-1] = 0
    
    set ABC__TimerHash = InitHashtable()
    set ABC__TriggerHash = InitHashtable()
    set ABC__DialogHash = InitHashtable()
    set ABC__RegionHash = InitHashtable()
    set ABC__ButtonHash = InitHashtable()
endfunction

//library ABC ends
//library AIDS:
    //==============================================================================
    // Configurables
    //
    
    function AIDS__UnitIndexingFilter takes unit u returns boolean
        return true
    endfunction
    
    //==============================================================================
    // System code
    //
    
    //==============================================================================
    
    //==============================================================================
    
    
    //==============================================================================
    
    constant function AIDS_GetEnteringIndexUnit takes nothing returns unit
        return AIDS__ARStackUnit[AIDS__ARStackLevel]
    endfunction
    
    function AIDS_GetIndexOfEnteringUnit takes nothing returns integer
        // Called in AIDS structs when units do not pass the initial AIDS filter.
        
        if AIDS__ARStackIndex[AIDS__ARStackLevel]==0 then
            // Get new index, from recycler first, else new.
            // Store the current index on the (new) top level of the AR stack.
            if AIDS__MaxRecycledIndex==0 then // Get new.
set AIDS__MaxIndex=AIDS__MaxIndex+1
                set AIDS__ARStackIndex[AIDS__ARStackLevel]=AIDS__MaxIndex
            else // Get from recycle stack.
set AIDS__ARStackIndex[AIDS__ARStackLevel]=AIDS__RecycledIndex[AIDS__MaxRecycledIndex]
                set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex-1
            endif
            
            // Store index on unit.
            call SetUnitUserData(AIDS__ARStackUnit[AIDS__ARStackLevel],AIDS__ARStackIndex[AIDS__ARStackLevel])
            set AIDS__IndexUnit[AIDS__ARStackIndex[AIDS__ARStackLevel]]=AIDS__ARStackUnit[AIDS__ARStackLevel]
            
            // Add index to recycle list.
            set AIDS__MaxDecayingIndex=AIDS__MaxDecayingIndex+1
            set AIDS__DecayingIndex[AIDS__MaxDecayingIndex]=AIDS__ARStackIndex[AIDS__ARStackLevel]
        endif
        
        return AIDS__ARStackIndex[AIDS__ARStackLevel]
    endfunction
    
    constant function AIDS_GetIndexOfEnteringUnitAllocated takes nothing returns integer
        // Called in AIDS structs when units have passed the initial AIDS filter.
        return AIDS__ARStackIndex[AIDS__ARStackLevel]
    endfunction
    constant function AIDS_GetDecayingIndex takes nothing returns integer
        static if AIDS__USE_PERIODIC_RECYCLER then
            return AIDS__DecayingIndex[AIDS__DecayChecker]
        else
            return AIDS__UndefendExpiringIndex[AIDS__UndefendExpiringIndexLevel]
        endif
    endfunction
    
    //==============================================================================
    
    function AIDS_RegisterOnEnter takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS__OnEnter,b)
    endfunction
    function AIDS_RegisterOnEnterAllocated takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS__OnEnterAllocated,b)
    endfunction
    function AIDS_RegisterOnDeallocate takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS__OnDeallocate,b)
    endfunction
    
    //==============================================================================
    function GetIndexUnit takes integer index returns unit
        
        return AIDS__IndexUnit[index]
    endfunction
    
    function GetUnitId takes unit u returns integer
        
        return GetUnitUserData(u)
    endfunction
    
    function GetUnitIndex takes unit u returns integer // Cannot be recursive.
        
        set AIDS__getindex=GetUnitUserData(u)
        
        if AIDS__getindex==0 then
            // Get new index, from recycler first, else new.
            // Store the current index in getindex.
            if AIDS__MaxRecycledIndex==0 then // Get new.
set AIDS__MaxIndex=AIDS__MaxIndex+1
                set AIDS__getindex=AIDS__MaxIndex
            else // Get from recycle stack.
set AIDS__getindex=AIDS__RecycledIndex[AIDS__MaxRecycledIndex]
                set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex-1
            endif
            
            // Store index on unit.
            call SetUnitUserData(u,AIDS__getindex)
            set AIDS__IndexUnit[AIDS__getindex]=u
            
            static if AIDS__USE_PERIODIC_RECYCLER then
                
                // Add index to recycle list.
                set AIDS__MaxDecayingIndex=AIDS__MaxDecayingIndex+1
                set AIDS__DecayingIndex[AIDS__MaxDecayingIndex]=AIDS__getindex
                
            else
            
                // Add leave detection ability.
                call UnitAddAbility(AIDS__ARStackUnit[AIDS__ARStackLevel],AIDS__LEAVE_DETECTION_ABILITY)
                call UnitMakeAbilityPermanent(AIDS__ARStackUnit[AIDS__ARStackLevel],true,AIDS__LEAVE_DETECTION_ABILITY)
                
            endif
            
            // Do not fire things here. No AIDS structs will be made at this point.
        endif
        
        return AIDS__getindex
    endfunction
    
    //==============================================================================
    function AIDS_AddLock takes integer index returns nothing
        set AIDS__LockLevel[index]=AIDS__LockLevel[index]+1
    endfunction
    function AIDS_RemoveLock takes integer index returns nothing
        set AIDS__LockLevel[index]=AIDS__LockLevel[index]-1
        
        static if not AIDS__USE_PERIODIC_RECYCLER then
            if GetUnitUserData(AIDS__IndexUnit[index])==0 and AIDS__LockLevel[index]==0 then
                
                // Increment stack for recursion.
                set AIDS__UndefendExpiringIndexLevel=AIDS__UndefendExpiringIndexLevel+1
                set AIDS__UndefendExpiringIndex[AIDS__UndefendExpiringIndexLevel]=index
                
                // Fire things.
                call TriggerEvaluate(AIDS__OnDeallocate)
                
                // Decrement stack for recursion.
                set AIDS__UndefendExpiringIndexLevel=AIDS__UndefendExpiringIndexLevel-1
                
                // Add the index to the recycler stack.
                set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex+1
                set AIDS__RecycledIndex[AIDS__MaxRecycledIndex]=index
                
                // Null the unit.
                set AIDS__IndexUnit[index]=null
                
            endif
        endif
    endfunction
    
    //==============================================================================
    static if AIDS__USE_PERIODIC_RECYCLER then
        
        function AIDS__PeriodicRecycler takes nothing returns nothing
            if AIDS__MaxDecayingIndex>0 then
                set AIDS__DecayChecker=AIDS__DecayChecker+1
                if AIDS__DecayChecker>AIDS__MaxDecayingIndex then
                    set AIDS__DecayChecker=1
                endif
                if GetUnitUserData(AIDS__IndexUnit[AIDS__DecayingIndex[AIDS__DecayChecker]])==0 then
                if AIDS__LockLevel[AIDS__DecayingIndex[AIDS__DecayChecker]]==0 then
                    
                    // Fire things.
                    call TriggerEvaluate(AIDS__OnDeallocate)
                    
                    // Add the index to the recycler stack.
                    set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex+1
                    set AIDS__RecycledIndex[AIDS__MaxRecycledIndex]=AIDS__DecayingIndex[AIDS__DecayChecker]
                    
                    // Null the unit.
                    set AIDS__IndexUnit[AIDS__DecayingIndex[AIDS__DecayChecker]]=null
                    
                    // Remove index from decay list.
                    set AIDS__DecayingIndex[AIDS__DecayChecker]=AIDS__DecayingIndex[AIDS__MaxDecayingIndex]
                    set AIDS__MaxDecayingIndex=AIDS__MaxDecayingIndex-1
                    
                endif
                endif
            endif
        endfunction
        
    else
        
        function AIDS__UndefendFilter takes nothing returns boolean
            return IsUnitType(GetFilterUnit(),UNIT_TYPE_DEAD)
        endfunction
        
        function AIDS__OnUndefendTimer takes nothing returns nothing
            loop
                exitwhen AIDS__UndefendStackIndex==0
                
                set AIDS__UndefendStackIndex=AIDS__UndefendStackIndex-1
                set AIDS__UndefendExpiringIndex[0]=AIDS__UndefendIndex[AIDS__UndefendStackIndex]
                
                if AIDS__IndexUnit[AIDS__UndefendExpiringIndex[0]]!=null then
                if GetUnitUserData(AIDS__IndexUnit[AIDS__UndefendExpiringIndex[0]])==0 then
                if AIDS__LockLevel[AIDS__UndefendExpiringIndex[0]]==0 then
                    
                    // Fire things.
                    call TriggerEvaluate(AIDS__OnDeallocate)
                    
                    // Add the index to the recycler stack.
                    set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex+1
                    set AIDS__RecycledIndex[AIDS__MaxRecycledIndex]=AIDS__UndefendExpiringIndex[0]
                    
                    // Null the unit.
                    set AIDS__IndexUnit[AIDS__UndefendExpiringIndex[0]]=null
                    
                endif
                endif
                endif
                
            endloop
        endfunction
        
        function AIDS__OnUndefend takes nothing returns boolean
            if GetIssuedOrderId()==852056 then // If undefend then...
set AIDS__UndefendFilterIndex=GetUnitUserData(GetOrderedUnit())
                
                if AIDS__UndefendIndex[AIDS__UndefendStackIndex-1]!=AIDS__UndefendFilterIndex then // Efficiency perk.
set AIDS__UndefendIndex[AIDS__UndefendStackIndex]=AIDS__UndefendFilterIndex
                    set AIDS__UndefendStackIndex=AIDS__UndefendStackIndex+1
                    
                    call TimerStart(AIDS__UndefendTimer,0,false,function AIDS__OnUndefendTimer)
                endif
            endif
            
            return false
        endfunction
        
    endif
    
    //==============================================================================
    function AIDS_IndexEnum takes nothing returns boolean // Can be recursive...
// Start by adding another level on the AR stack (for recursion's sake).
set AIDS__ARStackLevel=AIDS__ARStackLevel+1
        
        // Store the current unit on the (new) top level of the AR stack.
        set AIDS__ARStackUnit[AIDS__ARStackLevel]=GetFilterUnit()
        
        if GetUnitUserData(AIDS__ARStackUnit[AIDS__ARStackLevel])==0 then // Has not been indexed.

            if AIDS__UnitIndexingFilter(AIDS__ARStackUnit[AIDS__ARStackLevel]) then
                
                // Get new index, from recycler first, else new.
                // Store the current index on the (new) top level of the AR stack.
                if AIDS__MaxRecycledIndex==0 then // Get new.
set AIDS__MaxIndex=AIDS__MaxIndex+1
                    set AIDS__ARStackIndex[AIDS__ARStackLevel]=AIDS__MaxIndex
                else // Get from recycle stack.
set AIDS__ARStackIndex[AIDS__ARStackLevel]=AIDS__RecycledIndex[AIDS__MaxRecycledIndex]
                    set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex-1
                endif
                
                // Store index on unit.
                call SetUnitUserData(AIDS__ARStackUnit[AIDS__ARStackLevel],AIDS__ARStackIndex[AIDS__ARStackLevel])
                set AIDS__IndexUnit[AIDS__ARStackIndex[AIDS__ARStackLevel]]=AIDS__ARStackUnit[AIDS__ARStackLevel]
                
                static if AIDS__USE_PERIODIC_RECYCLER then
                    
                    // Add index to recycle list.
                    set AIDS__MaxDecayingIndex=AIDS__MaxDecayingIndex+1
                    set AIDS__DecayingIndex[AIDS__MaxDecayingIndex]=AIDS__ARStackIndex[AIDS__ARStackLevel]
                    
                else
                    
                    // Add leave detection ability.
                    call UnitAddAbility(AIDS__ARStackUnit[AIDS__ARStackLevel],AIDS__LEAVE_DETECTION_ABILITY)
                    call UnitMakeAbilityPermanent(AIDS__ARStackUnit[AIDS__ARStackLevel],true,AIDS__LEAVE_DETECTION_ABILITY)
                    
                endif
                
                // Fire things.
                call TriggerEvaluate(AIDS__OnEnter)
                
            else
                
                // The unit did not pass the filters, so does not need to be auto indexed.
                // However, for certain AIDS structs, it may still require indexing.
                // These structs may index the unit on their creation.
                // We flag that an index must be assigned by setting the current index to 0.
                set AIDS__ARStackIndex[AIDS__ARStackLevel]=0
                
                // Fire things.
                call TriggerEvaluate(AIDS__OnEnter)
                
            endif
            
        endif
        
        // Decrement the stack.
        set AIDS__ARStackLevel=AIDS__ARStackLevel-1
        
        return false
    endfunction
    
    //==============================================================================
    function AIDS__InitAIDS takes nothing returns nothing
        local region r=CreateRegion()
        
        local group g=CreateGroup()
        local integer n=15
        
        static if AIDS__USE_PERIODIC_RECYCLER then
            
            call TimerStart(AIDS__UndefendTimer,AIDS__PERIOD,true,function AIDS__PeriodicRecycler)
            
        else
            
            local trigger t=CreateTrigger()
            
            loop
                call TriggerRegisterPlayerUnitEvent(t,Player(n),EVENT_PLAYER_UNIT_ISSUED_ORDER,Filter(function AIDS__UndefendFilter))
                call SetPlayerAbilityAvailable(Player(n),AIDS__LEAVE_DETECTION_ABILITY,false)
                // Capture "undefend" orders.
                exitwhen n==0
                set n=n-1
            endloop
            set n=15
            
            call TriggerAddCondition(t,Filter(function AIDS__OnUndefend))
            set t=null
            
        endif
        
        // This must be done first, due to recursion. :)
        call RegionAddRect(r,GetWorldBounds())
        call TriggerRegisterEnterRegion(CreateTrigger(),r,Filter(function AIDS_IndexEnum))
        set r=null
        
        loop
            call GroupEnumUnitsOfPlayer(g,Player(n),Filter(function AIDS_IndexEnum))
            //Enum every non-filtered unit on the map during initialization and assign it a unique
            //index. By using GroupEnumUnitsOfPlayer, even units with Locust can be detected.
            exitwhen n==0
            set n=n-1
        endloop
        call DestroyGroup(g)
        set g=null
    endfunction
    
    //==============================================================================
    struct AIDS_DEFAULT extends array
        method AIDS_onCreate takes nothing returns nothing
        endmethod
        method AIDS_onDestroy takes nothing returns nothing
        endmethod
        
        static method AIDS_filter takes unit u returns boolean
            return AIDS__UnitIndexingFilter(u)
        endmethod
        
        static method AIDS_onInit takes nothing returns nothing
        endmethod
    endstruct
    
    //===========================================================================
    //  Never create or destroy AIDS structs directly.
    //  Also, do not initialise members except by using the AIDS_onCreate method.
    //===========================================================================

//library AIDS ends
//library AIDriver:
function AIDriver___GetStrategy takes unit u returns IAIStrategy
return AIData[u].strategy
endfunction
function TargetInRange takes unit u, unit tu ,real r returns nothing
    call AIData[u].strategy.targetInRange(u, tu, r)
endfunction
function TargetOutRange takes unit u returns nothing
    call AIData[u].strategy.targetOutRange(u)
endfunction
function PostAttack takes unit u returns nothing
    call AIData[u].strategy.postAttack(u)
endfunction
function BeHurted takes unit u, unit ds returns nothing
    //call BJDebugMsg("hurted")
    call AIData[u].strategy.beHurted(u,ds)
endfunction
function GetInMap takes unit u returns nothing
call AIData[u].strategy.getInMap(u)
endfunction

//library AIDriver ends
//library AII:


    
    
    static if LIBRARY_UID then
    endif
    
    function AII__FireEvent takes trigger trig, integer dat returns nothing
        local integer old=AII__EventStruct
        set AII__EventStruct=dat
        call TriggerEvaluate(trig)
        set AII__EventStruct=old
        //Bye bye to stack. :)
    endfunction
    
    function AII__Hash takes widget w returns integer
        local integer int=GetHandleId(w)
        local integer hash=int-(int/AII__MAX_HASH_VALUE)*AII__MAX_HASH_VALUE
        loop
            exitwhen AII__HashedInt[hash]==int
            if AII__HashedInt[hash]==0 then
                set AII__HashedInt[hash]=int
                return hash
            endif
            set hash=hash+AII__HASH_NEXT
            if hash>=AII__MAX_HASH_VALUE then
                set hash=hash-AII__MAX_HASH_VALUE
            endif
        endloop
        return hash
    endfunction
    //Handy function from Jesus4Lyf
    
    function AII__RemoveHash takes integer int returns nothing
        local integer hash=int-(int/AII__MAX_HASH_VALUE)*AII__MAX_HASH_VALUE
        loop
            if AII__HashedInt[hash]==int then
                set AII__HashedInt[hash]=0
                return
            endif
            set hash=hash+AII__HASH_NEXT
            if hash>=AII__MAX_HASH_VALUE then
                set hash=hash-AII__MAX_HASH_VALUE
            endif
        endloop
        //To cleaned up unused values.
    endfunction
    
    struct AII__ItemStruct
        private static trigger trig=CreateTrigger()
        private static integer thrashCount=0
        item it
        private integer hid
        private integer lockLevel
        private thistype prevA //A=Active, B=Thrash
private thistype nextA
        
        private static method refreshEventTrigger takes nothing returns nothing
            //See if the thrash is trigger is necessary to clean or not.
            local thistype this
            set thistype.thrashCount=thistype.thrashCount+1
            if thistype.thrashCount>=AII__MAX_THRASH then
            //If the thrash is over the default number, refresh the trigger. 
                call DisableTrigger(this.trig)
                call TriggerClearConditions(this.trig)
                call DestroyTrigger(this.trig)
                set thistype.trig=CreateTrigger()
                call TriggerAddCondition(thistype.trig,Condition(function thistype.onDeath))
                //Reset the trigger.
                set this=thistype(0).nextA
                loop
                    exitwhen this==0
                    call TriggerRegisterDeathEvent(this.trig,this.it)
                    //Reregister back the event.
                    set this=this.nextA
                endloop
                set thistype.thrashCount=0
            endif
        endmethod
        
        private static method onDeath takes nothing returns boolean
            call thistype(GetItemUserData(AII__HashedItem[AII__Hash(GetTriggerWidget())])).manageLock(false) //Get the attached item.
//Item is removed.
return false
        endmethod
        
        private static thistype array toFireDeallocate
        private static integer tFDCount=0
        
        private method addToActive takes nothing returns nothing
            set thistype(0).nextA.prevA=this
            set this.nextA=thistype(0).nextA
            set thistype(0).nextA=this
            set this.prevA=thistype(0)
        endmethod
        
        private method removeFromActive takes nothing returns nothing
            set this.prevA.nextA=this.nextA
            set this.nextA.prevA=this.prevA
        endmethod
        
        method remove takes nothing returns nothing
            call AII__FireEvent(AII__dealloItem,this)
            call this.removeFromActive()
            call AII__RemoveHash(this.hid)
            call thistype.refreshEventTrigger()
            set this.it=null
            if AII__IsInited then
                call this.deallocate()
            else
                set tFDCount=tFDCount+1
                set toFireDeallocate[tFDCount]=this
            endif
        endmethod
        
        method manageLock takes boolean b returns nothing
            if b then
                set this.lockLevel=this.lockLevel+1
            else
                set this.lockLevel=this.lockLevel-1
                if this.lockLevel==0 then
                    call this.remove()
                endif
            endif
        endmethod
        
        static method load takes item i returns thistype
            local thistype this
            set this=GetItemUserData(i)
            if i==null then //If item is null, then no point to index it..
return 0
            endif
            if this==0 then //Okay, the item is not indexed.
set this=thistype.allocate()
                set this.it=i
                set this.hid=GetHandleId(this.it)
                call TriggerRegisterDeathEvent(thistype.trig,this.it) //Register item death event.
set AII__HashedItem[AII__Hash(this.it)]=this.it//Attach the item to itself.
                set this.lockLevel=1
                
                call SetItemUserData(i,this)
                call AII__FireEvent(AII__alloItem,this) //Fire event!

                call this.addToActive()
            endif
            return this
        endmethod
        
        static method refireAllocateCallback takes conditionfunc c returns nothing
            local trigger trig=CreateTrigger()
            local thistype this=thistype(0).nextA
            call TriggerAddCondition(trig,c)
            loop
                exitwhen this==0
                call AII__FireEvent(trig,this)
                set this=this.nextA
            endloop
            call DestroyTrigger(trig)
            set trig=null
        endmethod
        
        static method refireDeallocateCallback takes conditionfunc c returns nothing
            local trigger trig=CreateTrigger()
            local integer count=tFDCount
            call TriggerAddCondition(trig,c)
            loop
            exitwhen count==0
                call AII__FireEvent(trig,toFireDeallocate[count])
                set count=count-1
            endloop
            call DestroyTrigger(trig)
            set trig=null
        endmethod
        
        private static method flag takes nothing returns nothing
            //Indicates the game is initialized.
            local integer count=tFDCount
            loop
            exitwhen count==0
                call toFireDeallocate[count].deallocate()
                set count=count-1
            endloop
            set AII__IsInited=true
            call PauseTimer(GetExpiredTimer())
            call DestroyTimer(GetExpiredTimer())
        endmethod
        
        private static method onInit takes nothing returns nothing
            call TriggerAddCondition(thistype.trig,Condition(function thistype.onDeath))
            call TimerStart(CreateTimer(),0.0,false,function thistype.flag)
        endmethod
    endstruct
    function GetItemId takes item i returns integer
        return GetItemUserData(i)
    endfunction
    
    function GetItemById takes integer i returns item
        return AII__ItemStruct(i).it
    endfunction
    
    function CreateItemEx takes integer itemid, real x, real y returns item
        return AII__ItemStruct.load(CreateItem(itemid,x,y)).it
    endfunction
    
    module AII__AIIInit
        private static method onInit takes nothing returns nothing
            local group g=CreateGroup()
            local rect world=GetWorldBounds()
            
            call EnumItemsInRect(world,Condition(function thistype.indexPreplaced),null)
            call GroupEnumUnitsInRect(g,world,Condition(function thistype.indexItemOnUnit))
            call RemoveRect(world)
            call DestroyGroup(g)
            set g=null
            set world=null
        
            call TriggerRegisterAnyUnitEventBJ(AII__pickUpItem,EVENT_PLAYER_UNIT_PICKUP_ITEM)
            call TriggerRegisterAnyUnitEventBJ(AII__sellItem,EVENT_PLAYER_UNIT_SELL_ITEM)
            call TriggerRegisterAnyUnitEventBJ(AII__pawnItem,EVENT_PLAYER_UNIT_PAWN_ITEM)
            
            call TriggerAddCondition(AII__pickUpItem,Condition(function thistype.onPickUp))
            call TriggerAddCondition(AII__sellItem,Condition(function thistype.onSell))
            call TriggerAddCondition(AII__pawnItem,Condition(function thistype.onPawn))
        endmethod
    endmodule
    
    struct AII__Initializer extends array
        private static method onPickUp takes nothing returns boolean
            call AII__ItemStruct.load(GetManipulatedItem())
            return false
        endmethod
        
        private static method onSell takes nothing returns boolean
            call AII__ItemStruct.load(GetSoldItem())
            return false
        endmethod
        
        private static method onPawn takes nothing returns boolean
            static if LIBRARY_UID then
                call AII__FireEvent(AII__dropItem,AII__ItemStruct.load(GetSoldItem()))
            endif
            call AII__ItemStruct.load(GetSoldItem()).manageLock(false)
            return false
        endmethod
        
        private static method indexPreplaced takes nothing returns boolean
            call AII__ItemStruct.load(GetFilterItem())
            return false
        endmethod
        
        private static method indexItemOnUnit takes nothing returns boolean
            local unit u=GetFilterUnit()
            local integer i = 0
            local integer maxSize = UnitInventorySize(u)
            local AII__ItemStruct it
            loop
            exitwhen i == maxSize
                call AII__ItemStruct.load(UnitItemInSlot(u,i))
                set i = i + 1
            endloop
            set u=null
            return false
        endmethod
    
        implement AII__AIIInit
    endstruct
    
    module AII
        readonly boolean flag
        method operator item takes nothing returns item
            return AII__ItemStruct(this).it
        endmethod
        method AII_addLock takes nothing returns nothing
            call AII__ItemStruct(this).manageLock(true)
        endmethod
        method AII_removeLock takes nothing returns nothing
            call AII__ItemStruct(this).manageLock(false) 
        endmethod
        static method operator [] takes item i returns thistype
            return GetItemId(i)
        endmethod
        
        private static method aiicreate takes nothing returns boolean
            local thistype this=AII__EventStruct
            static if thistype.AII_filter.exists then
                if thistype.AII_filter(this.item) then
                    static if thistype.AII_onCreate.exists then
                        call this.AII_onCreate()
                    endif
                    set this.flag=true
                endif
            else
                static if thistype.AII_onCreate.exists then
                    call this.AII_onCreate()
                endif
                set this.flag=true
            endif
            return false
        endmethod
        private static method aiidestroy takes nothing returns boolean
            local thistype this=AII__EventStruct
            if this.flag then
                static if thistype.AII_onDestroy.exists then
                    call this.AII_onDestroy()
                endif
                set this.flag=false
            endif
            return false
        endmethod
        
        static if thistype.AII_onDrop.exists then
            private static method aiidrophook takes nothing returns boolean
                if thistype(AII__EventStruct).flag then
                    call thistype(AII__EventStruct).AII_onDrop()
                endif
                return false
            endmethod
        endif
        
        private static method onInit takes nothing returns nothing
            call TriggerAddCondition(AII__alloItem,Condition(function thistype.aiicreate))
            call TriggerAddCondition(AII__dealloItem,Condition(function thistype.aiidestroy))
            static if thistype.AII_onDrop.exists then
                call TriggerAddCondition(AII__dropItem,Condition(function thistype.aiidrophook))
            endif
            if AII__IsInited==false then
                call AII__ItemStruct.refireAllocateCallback(Condition(function thistype.aiicreate))
                call AII__ItemStruct.refireDeallocateCallback(Condition(function thistype.aiidestroy))
            endif
        endmethod
    endmodule

//library AII ends
//library BOSS1:
function changeMelee takes nothing returns nothing
    call UnitAddAbility( boss1, 'A01Q' )
    call UnitRemoveAbility( boss1, 'A01Q' )
endfunction
function changeRange takes nothing returns nothing
    call UnitAddAbility( boss1, 'A01R' )
    call UnitRemoveAbility( boss1, 'A01R' )
endfunction

//library BOSS1 ends
//library BufferFunction:
function ApplyBurn takes unit source, unit target, real dam, real time returns nothing
    local integer burnlv = Material[target].burnlv
    local BurnBuffer debuff
    if burnlv < MAX_BURN_LV then
        set debuff = BurnBuffer.create(target,R2I(time*50),source,dam/2)
        call debuff.start()
    endif
endfunction
function ApplyBleed takes unit source, unit target, real dam, real time returns nothing
    local integer bleedlv = Material[target].bleedlv
    local BleedBuffer debuff
    if bleedlv < MAX_BLEED_LV then
        set debuff = BleedBuffer.create(target,R2I(time*50),source,dam/2)
        call debuff.start()
    endif
endfunction
function ApplyIceSlow takes unit target, real time returns nothing
    call IceSlowBuffer.create(target,R2I(time*50)).start()
endfunction
function ApplyHorro takes unit source, unit target, real time returns nothing
    local boolean status = Material[target].horro
    local HorroBuffer debuff
    if not status then
        set debuff = HorroBuffer.create(target,source,R2I(time*50))
        call debuff.start()
    endif
endfunction
function ApplyFloat takes unit target, real dur returns nothing
    call FloatBuffer.create(target, R2I(dur*50)).start()
endfunction

//library BufferFunction ends
//library Debuff:
function IceStar takes unit s, unit target returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call IssueTargetOrderById( dummy, 852226,target )
    set dummy = null
endfunction
function ElectricBlow takes unit s, unit target returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call IssueTargetOrderById( dummy, 852111,target )
    set dummy = null
endfunction
function Clap takes unit s, unit target, integer lv returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call SetUnitAbilityLevel(dummy, 'A01A', lv)
    call IssueImmediateOrderById( dummy, 852096 )
    set dummy = null
endfunction
function Clap3000 takes unit s, integer lv returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(s),GetUnitY(s),0)
    call UnitAddAbility(dummy, 'A020')
    call SetUnitAbilityLevel(dummy, 'A020', lv)
    call IssueImmediateOrderById( dummy, 852096 )
    set dummy = null
endfunction
function Stun takes unit s, unit target, integer lv returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call SetUnitAbilityLevel(dummy, 'A018', lv)
    call IssueTargetOrderById( dummy, 852095,target )
    set dummy = null
endfunction
function Net takes unit s, unit target, integer lv returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call SetUnitAbilityLevel(dummy, 'A022', lv)
    call IssueTargetOrderById( dummy, 852106,target )
    set dummy = null
endfunction
function Frezz takes unit s, unit target, integer lv returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call SetUnitAbilityLevel(dummy, 'A01C', lv)
    call IssueTargetOrderById( dummy, 852231,target )
    set dummy = null
endfunction

//library Debuff ends
//library Difficulty:
function SetDifficulty takes integer diff returns nothing 
    if diff==D_HARD or diff==D_CRAZY or diff==D_HELL then
        set Difficulty=diff
    endif
endfunction

//library Difficulty ends
//library Distance:
    function DistanceTwoUnits takes unit u,unit t returns real
        local real ux=GetUnitX(u)
        local real uy=GetUnitY(u)
        local real tx=GetUnitX(t)
        local real ty=GetUnitY(t)
        local real dis=SquareRoot(Pow(ty-uy,2)+Pow(tx-ux,2))
        return dis
    endfunction
    
    function DistanceUnitAndXY takes unit u, real x, real y returns real
        local real ux=GetUnitX(u)
        local real uy=GetUnitY(u)
        local real dis=SquareRoot(Pow(y-uy,2)+Pow(x-ux,2))
        return dis
    endfunction
    
    function DistanceTwo takes real ux,real uy, real tx, real ty returns real
        return SquareRoot(Pow(ty-uy,2)+Pow(tx-ux,2))
    endfunction

//library Distance ends
//library DummyCaster:
    // If you're looking for where the 'dumy' type is declared, it is declared
    // in the object merger line at the end of "How to implement?" in the above
    // documentation.
    
    struct DummyCaster___Initializer extends array // "extends array" removes
// create/destoy methods.
// The initialisation is done this way because struct initialisers are
// called before library initialisers, making this important for adding
// abilities on map initialisation.
private static method onInit takes nothing returns nothing
            set DUMMY=CreateUnit(DUMMY_OWNER,DUMMY_TYPE,DummyCaster___CREATED_AT_X,DummyCaster___CREATED_AT_Y,0)
        endmethod
    endstruct

//library DummyCaster ends
//library Effect:
function FlowerDestroy takes real x, real y, string e returns nothing
    local integer i = 1
    local integer j = 0
    local integer s = 0
    local real tx = 0
    local real ty = 0
    call DestroyEffect(AddSpecialEffect(e, x, y))
    loop
        exitwhen i > 2
        if i == 1 then
            set s = 6
        elseif i == 2 then
            set s = 8
        endif
        set j = s
        loop
            exitwhen j < 0
            set tx = x + i*100 * Cos(6.283/s * j)
            set ty = y + i*100 * Sin(6.283/s * j)
            call DestroyEffect(AddSpecialEffect(e, tx, ty))
            set j = j - 1
        endloop
        set i = i + 1
    endloop
endfunction

//library Effect ends
//library EffectString:
function CreateEffect takes string e, real x, real y returns nothing
    call DestroyEffect( AddSpecialEffect(e,x,y))
endfunction

//library EffectString ends
//library EffectZ:
//  _________________________________________
// +-----------------------------------------+
// |             E F F E C T   Z             |
// +-----------------------------------------+
// | - Feel free to take these out of this   |
// |   library and put them directly into    |
// |   your code.                            |
// | - I don't care about credit. I haven't  |
// |   even included my name here. :]        |
// +-----------------------------------------+
//  藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
    function AddSpecialEffectZ takes string modelName, real x, real y, real z returns effect
        set EffectZ__D = CreateDestructableZ( 'OTip', x, y, z, 0., 1., 0)
        set EffectZ__E = AddSpecialEffect(modelName, x, y)
        call RemoveDestructable(EffectZ__D)
        return EffectZ__E
    endfunction
    
    function AddSpecialEffectLocZ takes string modelName, location where, real z returns effect
        set EffectZ__D = CreateDestructableZ( 'OTip', GetLocationX(where), GetLocationY(where), z, 0., 1., 0)
        set EffectZ__E = AddSpecialEffectLoc(modelName, where)
        call RemoveDestructable(EffectZ__D)
        return EffectZ__E
    endfunction

//library EffectZ ends
//library Event:
    ///////////////
    // EventRegs //
    ////////////////////////////////////////////////////////////////////////////
    // For reading this far, you can learn one thing more.
    // Unlike normal Warcraft III events, you can attach to Event registries.
    // 
    // Event Registries are registrations of one trigger on one event.
    // These cannot be created or destroyed, just attached to.
    //
    // It is VERY efficient for loading and saving data.
    // 
    //  Functions:
    //         - set eventReg.data = someStruct --> Store data.
    //         - eventReg.data                  --> Retreive data.
    //         - Event.getTriggeringEventReg()  --> Get the triggering EventReg.
    //         - eventReg.destroy()             --> Undo this registration.
    // 
    struct EventReg extends array
        integer data
        method clear takes nothing returns nothing
            set this.data=0
        endmethod
        method destroy takes nothing returns nothing
            call Event(this).Event__destroyNode()
        endmethod
    endstruct
    
    module Event__Stack
        static thistype top=0
        static method increment takes nothing returns nothing
            set thistype.top=thistype(thistype.top+1)
        endmethod
        static method decrement takes nothing returns nothing
            set thistype.top=thistype(thistype.top-1)
        endmethod
    endmodule
    
    struct Event__EventStack extends array
        implement Event__Stack
        Event current
    endstruct
    
    struct Event
        private trigger trig
        private thistype next
        private thistype prev
        
        static method getTriggeringEventReg takes nothing returns EventReg
            return Event__EventStack.top.current
        endmethod
        
        static method create takes nothing returns Event
            local Event this=Event.allocate()
            set this.next=this
            set this.prev=this
            return this
        endmethod
        
        private static trigger currentTrigger
        method fire takes nothing returns nothing
            local thistype curr=this.next
            call Event__EventStack.increment()
            loop
                exitwhen curr==this
                set thistype.currentTrigger=curr.trig
                if IsTriggerEnabled(thistype.currentTrigger) then
                    set Event__EventStack.top.current=curr
                    if TriggerEvaluate(thistype.currentTrigger) then
                        call TriggerExecute(thistype.currentTrigger)
                    endif
                else
                    call EnableTrigger(thistype.currentTrigger) // Was trigger destroyed?
if IsTriggerEnabled(thistype.currentTrigger) then
                        call DisableTrigger(thistype.currentTrigger)
                    else // If trigger destroyed...
set curr.next.prev=curr.prev
                        set curr.prev.next=curr.next
                        call curr.deallocate()
                    endif
                endif
                set curr=curr.next
            endloop
            call Event__EventStack.decrement()
        endmethod
        method register takes trigger t returns EventReg
            local Event new=Event.allocate()
            set new.prev=this.prev
            set this.prev.next=new
            set this.prev=new
            set new.next=this
            
            set new.trig=t
            
            call EventReg(new).clear()
            return new
        endmethod
        method Event__destroyNode takes nothing returns nothing // called on EventReg
set this.prev.next=this.next
            set this.next.prev=this.prev
            call this.deallocate()
        endmethod
        method unregister takes trigger t returns nothing
            local thistype curr=this.next
            loop
                exitwhen curr==this
                if curr.trig==t then
                    set curr.next.prev=curr.prev
                    set curr.prev.next=curr.next
                    call curr.deallocate()
                    return
                endif
                set curr=curr.next
            endloop
        endmethod
        
        method destroy takes nothing returns nothing
            local thistype curr=this.next
            loop
                call curr.deallocate()
                exitwhen curr==this
                set curr=curr.next
            endloop
        endmethod
        method chainDestroy takes nothing returns nothing
            call this.destroy() // backwards compatability.
endmethod
    endstruct
    
    /////////////////////////////////////////////////////
    // Demonstration Functions & Alternative Interface //
    ////////////////////////////////////////////////////////////////////////////
    // What this would look like in normal WC3 style JASS (should all inline).
    // 
    function CreateEvent takes nothing returns Event
        return Event.create()
    endfunction
    function DestroyEvent takes Event whichEvent returns nothing
        call whichEvent.chainDestroy()
    endfunction
    function FireEvent takes Event whichEvent returns nothing
        call whichEvent.fire()
    endfunction
    function TriggerRegisterEvent takes trigger whichTrigger, Event whichEvent returns EventReg
        return whichEvent.register(whichTrigger)
    endfunction
    
    // And for EventRegs...
    function SetEventRegData takes EventReg whichEventReg, integer data returns nothing
        set whichEventReg.data=data
    endfunction
    function GetEventRegData takes EventReg whichEventReg returns integer
        return whichEventReg.data
    endfunction
    function GetTriggeringEventReg takes nothing returns integer
        return Event.getTriggeringEventReg()
    endfunction

//library Event ends
//library FloatText:
function DisplayFloatText takes real x, real y, string msg, real life returns nothing
    local location p = Location(x, y)
    call CreateTextTagLocBJ( msg, p, 100, 10, 100, 100, 100, 0 )
    call SetTextTagPermanent( GetLastCreatedTextTag(), false )
    call SetTextTagLifespan( GetLastCreatedTextTag(), life )
    set p = null
endfunction
function DisplayManaCost takes unit u, integer l returns nothing
    local location p = Location(GetUnitX(u), GetUnitY(u))
    call CreateTextTagLocBJ( "-" + I2S(l), p, 100, 10, 70, 70, 100, 0 )
    call SetTextTagPermanent( GetLastCreatedTextTag(), false )
    call SetTextTagLifespan( GetLastCreatedTextTag(), 1 )
    set p = null
endfunction
function DisplayManaCostSmall takes unit u, real l returns nothing
    local location p = Location(GetUnitX(u), GetUnitY(u))
    call CreateTextTagLocBJ( "-" + R2S(l), p, 100, 6, 70, 70, 100, 0 )
    call SetTextTagPermanent( GetLastCreatedTextTag(), false )
    call SetTextTagLifespan( GetLastCreatedTextTag(), 1 )
    set p = null
endfunction

//library FloatText ends
//library HashKeyManager:
function GetNewKey takes nothing returns integer
    set currentKey=currentKey+1
    return currentKey
endfunction

//library HashKeyManager ends
//library HashTable:
function InitHashTable takes nothing returns nothing
    call FlushParentHashtable( ht )
    set ht = InitHashtable() 
endfunction

//library HashTable ends
//library Height:
    function getTerrianHeight takes real x, real y returns real
        local location l = Location(x, y)
        local real h = GetLocationZ(l)
        call RemoveLocation(l)
        set l = null
        return h
    endfunction
    
    function getUnitHeight takes unit u returns real
        local real x = GetUnitX(u)
        local real y = GetUnitY(u)
        local real f = GetUnitFlyHeight(u)
        local real h = getTerrianHeight(x, y)
        return f + h
    endfunction

//library Height ends
//library HeroData:
//textmacro instance: CreateArrayList("TechRecord")
struct TechRecord
    integer size
    integer array itms[DEFAULT_ARRAYLIST_SIZE]
    
    static method create takes nothing returns TechRecord
        local TechRecord m=TechRecord.allocate()
        set m.size = 0
        return m
    endmethod
    
    method addItem takes integer itm returns nothing
        set itms[size] = itm
        set size = size + 1
    endmethod
endstruct
//end of: CreateArrayList("TechRecord")
struct TechCounter
    integer array cnt[TT_COUNT]
    integer size
endstruct
struct IHeroData
    real shoot_energy_max
    real shoot_energy_reg
    real shoot_energy
    unit shoot_target
    real shoot_range_buff
    //real shoot_speed_buff
    real shoot_rist
    real a_shoot_back
    real a_shoot_back_log
    //integer last_shoot_tick
    boolean reload
    real kill_mana_percent
    real mana_boom_percent
    TechRecord tech_record
    TechCounter tech_counter
    integer up_point
    integer bonus_point
    integer bullets
    real shoot_split
    real save
    real beforesave
    real strong
    real antrad
    real doge
    real frezz
    real fire_charge
    real machine_gun_buff
    real jump_direction
    unit abi_lock
    real vision
    integer array equips[20]
    effect reloade
    effect ee
    effect fe
    real mx
    real my
    real mdir
    real mr
    SmartDarts array smartDarts[5]
    integer smartDartsCount
    real gamble_buf
    real bullet_buf
    unit aimu
    integer shoot_count
    integer shoot_buffer
    integer shoot_tick
    integer clip_size
    integer melee_cooldown
    integer melee_interval
    integer reload_cost
    real stx
    real sty
    real stz
    real energy_consum
    boolean speedup
    boolean jump_refresh
    boolean transport
endstruct

//library HeroData ends
//library HeroStatus:
function HeroStatusCondition takes nothing returns nothing
    local unit u = GetTriggerUnit()
    local integer s = GetLearnedSkillBJ()
    if s == sALL then
        call SetHeroStr( u, ( GetHeroStr(u, false) + 1 ), true )
        call SetHeroAgi( u, ( GetHeroAgi(u, false) + 1 ), true )
        call SetHeroInt( u, ( GetHeroInt(u, false) + 1 ), true )
    elseif s == sSTR then
        call SetHeroStr( u, ( GetHeroStr(u, false) + 2 ), true )
    elseif s == sAGI then
        call SetHeroAgi( u, ( GetHeroAgi(u, false) + 2 ), true )
    elseif s == sINT then
        call SetHeroInt( u, ( GetHeroInt(u, false) + 2 ), true )
    endif
    set u = null
endfunction
function InitHeroStatus takes nothing returns nothing
local trigger herostatus_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ( herostatus_t, EVENT_PLAYER_HERO_SKILL )
call TriggerAddCondition(herostatus_t,function HeroStatusCondition)
set herostatus_t=null
endfunction

//library HeroStatus ends
//library ItmTest:
function StartItmTest takes nothing returns nothing
    local integer i = 0
    set itmtest_x = GetRectCenterX(gg_rct_itmtest)
    set itmtest_y = GetRectCenterY(gg_rct_itmtest)
    call SetUnitX(heros[0], itmtest_x)
    call SetUnitY(heros[0], itmtest_y)
    call CreateItemEx('I00Q',itmtest_x+10,itmtest_y+10)
    call CreateItemEx('I00P',itmtest_x+100,itmtest_y+100)
    call CreateItemEx('I00Z',itmtest_x+200,itmtest_y+100)
    call CreateItemEx('I00Y',itmtest_x+100,itmtest_y+200)
    call CreateItemEx('I012',itmtest_x+100,itmtest_y+300)
    call CreateItemEx(iSPEED,itmtest_x+100,itmtest_y+300)
    loop
        exitwhen i > 10
        call CreateItemEx('I00D',itmtest_x-200,itmtest_y-200)
        set i = i + 1
    endloop
    set i = 0
    loop
        exitwhen i > 10
        call CreateItemEx('I010',itmtest_x-500,itmtest_y-200)
        set i = i + 1
    endloop
    set i = 0
    loop
        exitwhen i > 0
        call CreateUnit( Player(11), 'u000', itmtest_x + 1500 + (i * 10), itmtest_y + 1500, bj_UNIT_FACING )
        set i = i + 1
    endloop
    set i = 0
    loop
        exitwhen i > 0
        call CreateUnit( Player(11), 'u005', itmtest_x + 1500 + (i * 10), itmtest_y + 1500, bj_UNIT_FACING )
        set i = i + 1
    endloop
    call SetPlayerStateBJ( Player(0), PLAYER_STATE_RESOURCE_LUMBER, 100)
endfunction

//library ItmTest ends
//library ListModule:
//===========================================================================
// Information: 
//==============
//
//     This module allows you to create a linked list containing all of the allocated
// instances of a struct. Iterating through a linked list is slightly faster than the
// typical method of looping through an array containing all of the instances. However,
// getting a random struct from a list is an O(n) operation instead of O(1) as with
// SetModule. This should be a good trade as most systems don't need random access.
//
//     There is no speed loss while iterating through structs compared to doing
// it yourself, since all of method calls used while iterating get inlined. The best
// use for this module is to hide a lot of ugly low-level code from your systems.
//
// How to use List:
//==================
//
//     Implement the List module in your struct. Your struct will gain all of the
// following methods:
//
// (static) getLength: Returns an integer indicating the number of structs in the list.
//
// (static) getRandom: Returns a random struct from the list. Note that this is rather
//                     slow due to the fact that this is a linked list implementation.
//
// (static) getFirst: Returns the first struct in the list.
//
// (static) getLast: Returns the last struct in the list.
//
// getNext: Returns the next struct in the list.
//
// getPrev: Returns the previous struct in the list.
//
// inList: Returns a boolean indicating whether this struct is in the list.
//
// addList: Adds this struct to the list. Returns false if adding failed because the
//          list is being destroyed or the struct was already in the list.
//
// removeList: Removes this struct from the list. Returns false if removal failed 
//             because the struct was not in the list.
//
// (static) destroyList: Destroys all of the structs in the list.
//
// Example of List usage:
//========================
//
// struct YourStruct
//     implement List
//
//     static method create takes nothing returns YourStruct
//         local YourStruct ys = .allocate()
//             call ys.addList()
//         return ys
//     endmethod
//
//     method onDestroy takes nothing returns nothing
//         call .removeList()
//     endmethod
//
//     static method GetRandomStruct takes nothing returns YourStruct
//         return .getRandom() //That was easy... but slow.
//     endmethod
//
//     static method LoopThroughAllYourStructs takes nothing returns nothing
//         local YourStruct ys = .getFirst() //This is inlined to a variable read.
//             loop
//                 exitwhen ys == 0
//                 //Do something with the YourStruct instance here.
//                 set ys = ys.getNext() //This is inlined to an array read.
//             endloop
//     endmethod
// endstruct
//
//===========================================================================
    module List
    
        private static boolean destroyinglist = false
        private static thistype length = 0
        private static thistype first = 0
        private static thistype last = 0
    
        private thistype prev = 0
        private thistype next = 0
        private boolean inlist = false
    
        static method getLength takes nothing returns integer
            return .length
        endmethod
    
        static method getFirst takes nothing returns thistype
            return .first
        endmethod
    
        static method getLast takes nothing returns thistype
            return .last
        endmethod
    
        static method getRandom takes nothing returns thistype
            local thistype s = .first
            local thistype array list
            local integer n = -1
            loop
                exitwhen s == 0
                set n = n + 1
                set list[n] = s
                set s = s.next
            endloop
            if n == -1 then
                return 0
            endif
            return list[GetRandomInt(0, n)]
        endmethod
    
        method getNext takes nothing returns thistype
            return .next
        endmethod
    
        method getPrev takes nothing returns thistype
            return .prev
        endmethod
    
        method inList takes nothing returns boolean
            return .inlist
        endmethod
        method addList takes nothing returns boolean
            if not .inlist and not .destroyinglist then
                set .inlist = true
                if .first == 0 then
                    set .first = this
                else
                    set .prev = .last
                    set .prev.next = this
                endif
                set .last = this
                set .length = .length + 1
                return true
            endif
            return false
        endmethod
    
        method removeList takes nothing returns boolean
            if .inlist then
                if .destroyinglist then
                    return true
                endif
                set .inlist = false
                if .first == this then
                    set .first = .next
                endif
                if .last == this then
                    set .last = .prev
                endif
                set .prev.next = .next
                set .next.prev = .prev
                set .length = .length - 1
                return true
            endif
            return false
        endmethod
    
        static method destroyList takes nothing returns nothing
            local thistype s = .first
            if not .destroyinglist then
                loop
                    exitwhen s == 0
                    set .destroyinglist = false
                    call s.removeList()
                    set .destroyinglist = true
                    call s.destroy()
                    set s = s.next
                endloop
                set .destroyinglist = false
            endif
        endmethod
    
    endmodule

//library ListModule ends
//library Lock:
function EnableAllAbi takes unit u returns nothing
    local integer i = 'A000'
    loop
        exitwhen i > 'A020'
        call SetPlayerAbilityAvailable( GetOwningPlayer(u), i, true)
        set i = i + 1
    endloop
endfunction
function DisableAllAbi takes unit u returns nothing
    local integer i = 'A000'
    loop
        exitwhen i > 'A020'
        call SetPlayerAbilityAvailable( GetOwningPlayer(u), i, false)
        set i = i + 1
    endloop
endfunction
function EnableAbiLock takes integer i returns nothing
    set EquipmentData[heros[i]].heroData.abi_lock = CreateUnit(Player(i), ABI_LOCK, GetRectCenterX(gg_rct_lock[i]), GetRectCenterY(gg_rct_lock[i]), 0)
endfunction
function DisableAbiLock takes integer i returns nothing
    call RemoveUnit(EquipmentData[heros[i]].heroData.abi_lock)
endfunction

//library Lock ends
//library MissleFactory:
interface IMissleFactory
    method createMissle takes unit owner returns IMissle
endinterface
struct SmartDartsFactory extends IMissleFactory
    unit t
    static method create takes unit target returns thistype
        local thistype s = thistype.allocate()
        set s.t = target
        return s
    endmethod
    method createMissle takes unit owner returns IMissle
        local IMissle m = SmartDarts.create(owner, t)
        return m
    endmethod
endstruct
//textmacro instance: MissleFactory("DefaultMissleFactory","Missle")
struct DefaultMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=Missle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("DefaultMissleFactory","Missle")
//textmacro instance: MissleFactory("ShootGunMissleFactory","ShootGunMissle")
struct ShootGunMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=ShootGunMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("ShootGunMissleFactory","ShootGunMissle")
//textmacro instance: MissleFactory("SmallDartsFactory","SmallDarts")
struct SmallDartsFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=SmallDarts.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("SmallDartsFactory","SmallDarts")
//textmacro instance: MissleFactory("ReturnDartsFactory","ReturnDarts")
struct ReturnDartsFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=ReturnDarts.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("ReturnDartsFactory","ReturnDarts")
//textmacro instance: MissleFactory("LeaveDartsFactory","LeaveDarts")
struct LeaveDartsFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=LeaveDarts.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("LeaveDartsFactory","LeaveDarts")
//textmacro instance: MissleFactory("LeaveDartsFactoryV2","LeaveDartsV2")
struct LeaveDartsFactoryV2 extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=LeaveDartsV2.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("LeaveDartsFactoryV2","LeaveDartsV2")
//textmacro instance: MissleFactory("IceMissleFactory","IceMissle")
struct IceMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=IceMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("IceMissleFactory","IceMissle")
//textmacro instance: MissleFactory("FireMissleFactory","FireMissle")
struct FireMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=FireMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("FireMissleFactory","FireMissle")
//textmacro instance: MissleFactory("ElectricWhipFactory","ElectricWhip")
struct ElectricWhipFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=ElectricWhip.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("ElectricWhipFactory","ElectricWhip")
//textmacro instance: MissleFactory("BackGrenadeFactory","BackGrenade")
struct BackGrenadeFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=BackGrenade.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("BackGrenadeFactory","BackGrenade")
//textmacro instance: MissleFactory("PushGrenadeFactory","PushGrenade")
struct PushGrenadeFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=PushGrenade.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("PushGrenadeFactory","PushGrenade")
//textmacro instance: MissleFactory("MineFactory","Mine")
struct MineFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=Mine.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("MineFactory","Mine")
//textmacro instance: MissleFactory("ShoulderCannonFactory","ShoulderCannonMissle")
struct ShoulderCannonFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=ShoulderCannonMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("ShoulderCannonFactory","ShoulderCannonMissle")
//textmacro instance: MissleFactory("SpearMissleFactory","SpearMissle")
struct SpearMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=SpearMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("SpearMissleFactory","SpearMissle")
//textmacro instance: MissleFactory("AcidMissleFactory","AcidMissle")
struct AcidMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=AcidMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("AcidMissleFactory","AcidMissle")
//textmacro instance: MissleFactory("NetMissleFactory","NetMissle")
struct NetMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=NetMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("NetMissleFactory","NetMissle")

//library MissleFactory ends
//library MonsterDead:
function InitMonsterDead takes nothing returns nothing
set gtrgMonsterDead=CreateTrigger()
call TriggerRegisterPlayerUnitEventSimple( gtrgMonsterDead, Player(11), EVENT_PLAYER_UNIT_DEATH )
endfunction

//library MonsterDead ends
//library MonsterTypeData:
function InitMonsterTypeData takes nothing returns nothing
call DefaultTypeData.create()
endfunction
interface IMonsterTypeData 
method getDeadGold takes nothing returns integer
method getDeadWood takes nothing returns integer
method getTypeId takes nothing returns integer
endinterface
struct DefaultTypeData extends IMonsterTypeData
implement List
static method create takes nothing returns DefaultTypeData
local DefaultTypeData s=DefaultTypeData.allocate()
call s.addList()
return s
endmethod
method onDestroy takes nothing returns nothing
call removeList()
endmethod
method getTypeId takes nothing returns integer
return 123
endmethod
method getDeadGold takes nothing returns integer
return 2
endmethod
method getDeadWood takes nothing returns integer
return 0
endmethod
static method findTypeData takes integer typeid returns IMonsterTypeData
local DefaultTypeData p=getFirst()
loop
    exitwhen p==0
    if p.getTypeId()==typeid then
        return p
    endif
    set p=p.getNext()
endloop
return getFirst()
endmethod
endstruct

//library MonsterTypeData ends
//library Movie:
function MovieSay takes integer id, string msg returns nothing
    call TransmissionFromUnitWithNameBJ( GetPlayersAll(), heros[id], GetPlayerName(Player(id)), null, msg, bj_TIMETYPE_ADD, 1, true )
endfunction
function MovieStart takes nothing returns nothing
    call CinematicModeExBJ( true, GetPlayersAll(), 0.2 )
endfunction
function MovieEnd takes nothing returns nothing
    call CinematicModeExBJ( false, GetPlayersAll(), 0.2 )
endfunction
function UnSeen takes nothing returns nothing
    local integer i = 0
    loop
        exitwhen i >= PLAYER_COUNT
        if gfm[i] != null then
            call FogModifierStop(gfm[i])
            call DestroyFogModifier(gfm[i])
            set gfm[i] = null
        endif
        set i = i + 1
    endloop
endfunction
function Seen takes rect r, integer sec returns nothing
    local integer i = 0
    local timer t
    loop
        exitwhen i >= PLAYER_COUNT
        if heros[i] != null then
            set gfm[i] = CreateFogModifierRectBJ( true, Player(i), FOG_OF_WAR_VISIBLE, r)
        endif
        set i = i + 1
    endloop
    set t = CreateTimer()
    call TimerStart(t, sec, false, function UnSeen)
    set t = null
endfunction
function LockAgain takes nothing returns nothing
    local integer i = 0
    local location l = null
    loop
        exitwhen i >= 3
        if heros[i] != null then
            call ResetToGameCameraForPlayer(Player(i), 0)
            set l = Location(GetUnitX(heros[i]), GetUnitY(heros[i]))
            call PanCameraToTimedLocForPlayer(Player(i), l, 0)
            call RemoveLocation(l)
            set l = null
            call SetCameraFieldForPlayer( Player(i), CAMERA_FIELD_TARGET_DISTANCE, 2350.00, 0.50 )
        endif
        set i = i + 1
    endloop
endfunction
function StopShake takes nothing returns nothing
    local integer i = 0
    loop
        exitwhen i >= 3
        call CameraClearNoiseForPlayer( Player(i) )
        set i = i + 1
    endloop
endfunction
function StartShake takes nothing returns nothing
    local integer i = 0
    loop
        exitwhen i >= 3
        call CameraSetEQNoiseForPlayer( Player(i), 3 )
        if heros[i] != null then
            call IssueImmediateOrderById(heros[i], OI_STOP)
        endif
        set i = i + 1
    endloop
endfunction
function MoveCamera takes real x, real y returns nothing
    call PanCameraToTimed( x,y, 0.50 )
endfunction

//library Movie ends
//library OrderId:

//library OrderId ends
//library PlayerHero:
function CreateHero takes integer pid, real x, real y returns unit
    local unit hero = CreateUnit(Player(pid),HERO,x,y,0)
    //local unit tech = CreateUnit(Player(pid),TECH_UNIT,x,y,0)
    call UnitAddAbility(hero, SHOOT_SPEED)
    call SetUnitAbilityLevel(hero, SHOOT_SPEED, 21)
    set heros[pid] = hero
    set mode_tip[pid] = 3
    set refresh_tip[pid] = false
    //set techs[pid] = tech
    //set tech = null
    return hero
endfunction
function CurrentPlaying takes player p returns boolean
    return (GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING) and (GetPlayerController(p) == MAP_CONTROL_USER)
endfunction
function CurrentPlayerCount takes nothing returns integer
    local integer i = 0
    local integer r = 0
    loop
        exitwhen i >= PLAYER_COUNT
        if CurrentPlaying(Player(i)) then
            set r = r + 1
        endif
        set i = i + 1
    endloop
    return r
endfunction

//library PlayerHero ends
//library RegisterSpell:
function InitRegisterSpell takes nothing returns nothing
    set kRegistedSpell=GetNewKey()
endfunction
function RegisterSpell takes unit u returns nothing
local boolean registed=LoadBoolean(ht,GetHandleId(u),kRegistedSpell)
if registed==false then
//textmacro instance: RegisterSpell("'A002'")
call UnitAddAbility(u,'A002')
call SetPlayerAbilityAvailable( GetOwningPlayer(u), 'A002', false )
//end of: RegisterSpell("'A002'")
//textmacro instance: RegisterSpell("'A003'")
call UnitAddAbility(u,'A003')
call SetPlayerAbilityAvailable( GetOwningPlayer(u), 'A003', false )
//end of: RegisterSpell("'A003'")
//textmacro instance: RegisterSpell("'A004'")
call UnitAddAbility(u,'A004')
call SetPlayerAbilityAvailable( GetOwningPlayer(u), 'A004', false )
//end of: RegisterSpell("'A004'")
//textmacro instance: RegisterSpell("'A005'")
call UnitAddAbility(u,'A005')
call SetPlayerAbilityAvailable( GetOwningPlayer(u), 'A005', false )
//end of: RegisterSpell("'A005'")
//textmacro instance: RegisterSpell("'A006'")
call UnitAddAbility(u,'A006')
call SetPlayerAbilityAvailable( GetOwningPlayer(u), 'A006', false )
//end of: RegisterSpell("'A006'")
call SaveBoolean(ht,GetHandleId(u),kRegistedSpell,true)
endif
endfunction

//library RegisterSpell ends
//library Resources:
function SetGenerateParameters takes real x1, real x2, real y1, real y2, region r, integer max returns nothing
    set g_gx1 = x1
    set g_gx2 = x2
    set g_gy1 = y1
    set g_gy2 = y2
    set g_gr2 = r
    set r_m_yaocao = max
    set r_yaocao = 0
endfunction
function GenerateEnergy takes nothing returns nothing
    local real x = GetRandomReal(g_gx1, g_gx2)
    local real y = GetRandomReal(g_gy1, g_gy2)
    loop
        exitwhen IsPointInRegion(g_gr2, x, y)
        set x = GetRandomReal(g_gx1, g_gx2)
        set y = GetRandomReal(g_gy1, g_gy2)
    endloop
    call CreateItem('I018', x, y)
endfunction
function ResourcePickAction takes nothing returns nothing
    local item i = GetManipulatedItem()
    local unit u = GetTriggerUnit()
    if GetItemTypeId(i) == 'I018' then
        set r_yaocao = r_yaocao - 1
    endif
    set i = null
endfunction
function InitResources takes nothing returns nothing
    set gResourceManager = ResourceManager.create()
    set gResourcePickTrigger = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gResourcePickTrigger, EVENT_PLAYER_UNIT_PICKUP_ITEM )
    call TriggerAddAction(gResourcePickTrigger, function ResourcePickAction)
endfunction
struct ResourceManager
implement T32x
static method create takes nothing returns ResourceManager
    local ResourceManager dag=ResourceManager.allocate()
    call dag.startPeriodic()
    return dag
endmethod
method onDestroy takes nothing returns nothing
    call stopPeriodic()
endmethod
method periodic takes nothing returns nothing
    local integer c = 0
    local integer i = 0
    if g_ge and ModuloInteger(Tick,100)==0 then
        if r_yaocao < r_m_yaocao then
            set c = r_m_yaocao - r_yaocao
            set i = 0
            loop
                exitwhen i >= c
                set i = i + 1
                call GenerateEnergy()
                set r_yaocao = r_yaocao + 1
                //call BJDebugMsg("r_yaocao " + I2S(r_yaocao))
                //call BJDebugMsg("generate energy " + I2S(r_yaocao))
            endloop
        endif
    endif
endmethod
endstruct

//library Resources ends
//library ShootBack:
function ShootBackCondition takes nothing returns boolean
    local unit tu = GetTriggerUnit()
    if GetIssuedOrderIdBJ() == String2OrderIdBJ("unimmolation") and GetUnitTypeId(tu) == HERO then
        set EquipmentData[tu].heroData.a_shoot_back = EquipmentData[tu].heroData.a_shoot_back - EquipmentData[tu].heroData.a_shoot_back_log
        set EquipmentData[tu].heroData.a_shoot_back_log = 0.0
    endif
    set tu = null
    return false
endfunction
function ShootBackInitializer takes nothing returns nothing
    set shoot_back_trg = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( shoot_back_trg, EVENT_PLAYER_UNIT_ISSUED_ORDER )
    call TriggerAddCondition(shoot_back_trg, Condition(function ShootBackCondition))
endfunction

//library ShootBack ends
//library ShootSpeed:
    function IncShootSpeed takes integer pid returns nothing
        call IncUnitAbilityLevel(heros[pid],SHOOT_SPEED)
    endfunction

//library ShootSpeed ends
//library SkillLearn:
function InitSpellBook takes nothing returns nothing
    local integer ut = GetUnitTypeId(GetTriggerUnit())
    if ut == HERO then
    call BJDebugMsg("init spell book")
    endif
endfunction
function GetSkillId takes integer it returns integer
    return -1
endfunction
function LearnSkill takes nothing returns nothing
    local integer it = GetItemTypeId(GetManipulatedItem())
    local integer skill = GetSkillId(it)
    if skill != -1 then
    endif
endfunction
function InitSkillLearn takes nothing returns nothing
local trigger t=CreateTrigger()
local trigger t2=CreateTrigger()
local region rectRegion = CreateRegion()
call RegionAddRect(rectRegion, GetPlayableMapRect())
call TriggerRegisterEnterRegion(t, rectRegion, null)
call TriggerAddCondition(t,function InitSpellBook)
call TriggerRegisterAnyUnitEventBJ( t2, EVENT_PLAYER_UNIT_USE_ITEM )
call TriggerAddCondition(t2,function LearnSkill)
set t=null
set t2=null
set rectRegion = null
endfunction

//library SkillLearn ends
//library SummonUtil:
function SummonMonster takes integer uid, rect rct returns nothing
    local location l = GetRandomLocInRect(rct)
    local real x = GetLocationX(l)
    local real y = GetLocationY(l)
    local integer i = 0
    loop
        exitwhen i > 2
        if CurrentPlaying(Player(i)) and IsUnitAliveBJ(heros[i]) and GetUnitAbilityLevel(heros[i], 'A02H') == 0 then
            if DistanceTwo(x, y, GetUnitX(heros[i]), GetUnitY(heros[i])) <= EquipmentData[heros[i]].heroData.vision then
                set l = GetRandomLocInRect(rct)
                set x = GetLocationX(l)
                set y = GetLocationY(l)
                set i = -1
                //call BJDebugMsg("reloc")
            endif
        endif
        set i = i + 1
    endloop
    call CreateUnit( Player(11), uid, x, y, bj_UNIT_FACING )
    set l = null
endfunction

//library SummonUtil ends
//library T32:
    
    //==============================================================================
    // The standard T32 module, T32x.
    //
    module T32x
        private thistype next
        private thistype prev
        
        private static method PeriodicLoop takes nothing returns boolean
            local thistype this=thistype(0).next
            loop
                exitwhen this==0
                call this.periodic()
                set this=this.next
            endloop
            return false
        endmethod
        method startPeriodic takes nothing returns nothing
            set thistype(0).next.prev=this
            set this.next=thistype(0).next
            set thistype(0).next=this
            set this.prev=thistype(0)
        endmethod
        
        method stopPeriodic takes nothing returns nothing
            // This is some real magic.
            set this.prev.next=this.next
            set this.next.prev=this.prev
            // This will even work for the starting element.
        endmethod
        
        private static method onInit takes nothing returns nothing
            call TriggerAddCondition(T32__Trig,Condition(function thistype.PeriodicLoop))
        endmethod
    endmodule
    
    //==============================================================================
    // The standard T32 module with added safety checks on .startPeriodic() and
    // .stopPeriodic(), T32xs.
    //
    module T32xs
        private thistype next
        private thistype prev
        private boolean runningPeriodic
        
        private static method PeriodicLoop takes nothing returns boolean
            local thistype this=thistype(0).next
            loop
                exitwhen this==0
                call this.periodic()
                set this=this.next
            endloop
            return false
        endmethod
        method startPeriodic takes nothing returns nothing
            if not this.runningPeriodic then
                set thistype(0).next.prev=this
                set this.next=thistype(0).next
                set thistype(0).next=this
                set this.prev=thistype(0)
                
                set this.runningPeriodic=true
            endif
        endmethod
        
        method stopPeriodic takes nothing returns nothing
            if this.runningPeriodic then
                // This is some real magic.
                set this.prev.next=this.next
                set this.next.prev=this.prev
                // This will even work for the starting element.
                
                set this.runningPeriodic=false
            endif
        endmethod
        
        private static method onInit takes nothing returns nothing
            call TriggerAddCondition(T32__Trig,Condition(function thistype.PeriodicLoop))
        endmethod
    endmodule
    
    //==============================================================================
    // The original T32 module, for backwards compatability only.
    //
    module T32 // deprecated.
private thistype next
        private thistype prev
        
        private static method PeriodicLoop takes nothing returns boolean
            local thistype this=thistype(0).next
            loop
                exitwhen this==0
                if this.periodic() then
                    // This is some real magic.
                    set this.prev.next=this.next
                    set this.next.prev=this.prev
                    // This will even work for the starting element.
                endif
                set this=this.next
            endloop
            return false
        endmethod
        method startPeriodic takes nothing returns nothing
            set thistype(0).next.prev=this
            set this.next=thistype(0).next
            set thistype(0).next=this
            set this.prev=thistype(0)
        endmethod
        
        private static method onInit takes nothing returns nothing
            call TriggerAddCondition(T32__Trig,Condition(function thistype.PeriodicLoop))
        endmethod
    endmodule
    
    //==============================================================================
    // System Core.
    //
    function T32__OnExpire takes nothing returns nothing
        set Tick=Tick+1
        call TriggerEvaluate(T32__Trig)
    endfunction
    
    function T32__OnInit takes nothing returns nothing
        call TimerStart(CreateTimer(),T32_PERIOD,true,function T32__OnExpire)
    endfunction

//library T32 ends
//library Table:

    
    
//textmacro instance: NEW_TABLE("Real", "Real", "real", "true")
struct Table__reals extends array
    static if (true) then
        method operator [] takes integer key returns real
            return LoadReal(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, real value returns nothing
        call SaveReal(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedReal(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedReal(Table__ht, this, key)
    endmethod
endstruct
module Table__realm
    method operator real takes nothing returns Table__reals
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Real", "Real", "real", "true")
//textmacro instance: NEW_TABLE("Boolean", "Boolean", "boolean", "true")
struct Table__booleans extends array
    static if (true) then
        method operator [] takes integer key returns boolean
            return LoadBoolean(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, boolean value returns nothing
        call SaveBoolean(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedBoolean(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedBoolean(Table__ht, this, key)
    endmethod
endstruct
module Table__booleanm
    method operator boolean takes nothing returns Table__booleans
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Boolean", "Boolean", "boolean", "true")
//textmacro instance: NEW_TABLE("String", "Str", "string", "true")
struct Table__strings extends array
    static if (true) then
        method operator [] takes integer key returns string
            return LoadStr(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, string value returns nothing
        call SaveStr(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedString(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedString(Table__ht, this, key)
    endmethod
endstruct
module Table__stringm
    method operator string takes nothing returns Table__strings
        return this
    endmethod
endmodule
//end of: NEW_TABLE("String", "Str", "string", "true")
//textmacro instance: NEW_TABLE("Handle", "PlayerHandle", "player", "true")
struct Table__players extends array
    static if (true) then
        method operator [] takes integer key returns player
            return LoadPlayerHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, player value returns nothing
        call SavePlayerHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__playerm
    method operator player takes nothing returns Table__players
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "PlayerHandle", "player", "true")
//textmacro instance: NEW_TABLE("Handle", "WidgetHandle", "widget", "true")
struct Table__widgets extends array
    static if (true) then
        method operator [] takes integer key returns widget
            return LoadWidgetHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, widget value returns nothing
        call SaveWidgetHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__widgetm
    method operator widget takes nothing returns Table__widgets
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "WidgetHandle", "widget", "true")
//textmacro instance: NEW_TABLE("Handle", "DestructableHandle", "destructable", "true")
struct Table__destructables extends array
    static if (true) then
        method operator [] takes integer key returns destructable
            return LoadDestructableHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, destructable value returns nothing
        call SaveDestructableHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__destructablem
    method operator destructable takes nothing returns Table__destructables
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "DestructableHandle", "destructable", "true")
//textmacro instance: NEW_TABLE("Handle", "ItemHandle", "item", "true")
struct Table__items extends array
    static if (true) then
        method operator [] takes integer key returns item
            return LoadItemHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, item value returns nothing
        call SaveItemHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__itemm
    method operator item takes nothing returns Table__items
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "ItemHandle", "item", "true")
//textmacro instance: NEW_TABLE("Handle", "UnitHandle", "unit", "true")
struct Table__units extends array
    static if (true) then
        method operator [] takes integer key returns unit
            return LoadUnitHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, unit value returns nothing
        call SaveUnitHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__unitm
    method operator unit takes nothing returns Table__units
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "UnitHandle", "unit", "true")
//textmacro instance: NEW_TABLE("Handle", "AbilityHandle", "ability", "true")
struct Table__abilitys extends array
    static if (true) then
        method operator [] takes integer key returns ability
            return LoadAbilityHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, ability value returns nothing
        call SaveAbilityHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__abilitym
    method operator ability takes nothing returns Table__abilitys
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "AbilityHandle", "ability", "true")
//textmacro instance: NEW_TABLE("Handle", "TimerHandle", "timer", "true")
struct Table__timers extends array
    static if (true) then
        method operator [] takes integer key returns timer
            return LoadTimerHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, timer value returns nothing
        call SaveTimerHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__timerm
    method operator timer takes nothing returns Table__timers
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TimerHandle", "timer", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerHandle", "trigger", "true")
struct Table__triggers extends array
    static if (true) then
        method operator [] takes integer key returns trigger
            return LoadTriggerHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, trigger value returns nothing
        call SaveTriggerHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__triggerm
    method operator trigger takes nothing returns Table__triggers
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TriggerHandle", "trigger", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerConditionHandle", "triggercondition", "true")
struct Table__triggerconditions extends array
    static if (true) then
        method operator [] takes integer key returns triggercondition
            return LoadTriggerConditionHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, triggercondition value returns nothing
        call SaveTriggerConditionHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__triggerconditionm
    method operator triggercondition takes nothing returns Table__triggerconditions
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TriggerConditionHandle", "triggercondition", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerActionHandle", "triggeraction", "true")
struct Table__triggeractions extends array
    static if (true) then
        method operator [] takes integer key returns triggeraction
            return LoadTriggerActionHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, triggeraction value returns nothing
        call SaveTriggerActionHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__triggeractionm
    method operator triggeraction takes nothing returns Table__triggeractions
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TriggerActionHandle", "triggeraction", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerEventHandle", "event", "true")
struct Table__events extends array
    static if (true) then
        method operator [] takes integer key returns event
            return LoadTriggerEventHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, event value returns nothing
        call SaveTriggerEventHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__eventm
    method operator event takes nothing returns Table__events
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TriggerEventHandle", "event", "true")
//textmacro instance: NEW_TABLE("Handle", "ForceHandle", "force", "true")
struct Table__forces extends array
    static if (true) then
        method operator [] takes integer key returns force
            return LoadForceHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, force value returns nothing
        call SaveForceHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__forcem
    method operator force takes nothing returns Table__forces
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "ForceHandle", "force", "true")
//textmacro instance: NEW_TABLE("Handle", "GroupHandle", "group", "true")
struct Table__groups extends array
    static if (true) then
        method operator [] takes integer key returns group
            return LoadGroupHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, group value returns nothing
        call SaveGroupHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__groupm
    method operator group takes nothing returns Table__groups
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "GroupHandle", "group", "true")
//textmacro instance: NEW_TABLE("Handle", "LocationHandle", "location", "true")
struct Table__locations extends array
    static if (true) then
        method operator [] takes integer key returns location
            return LoadLocationHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, location value returns nothing
        call SaveLocationHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__locationm
    method operator location takes nothing returns Table__locations
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "LocationHandle", "location", "true")
//textmacro instance: NEW_TABLE("Handle", "RectHandle", "rect", "true")
struct Table__rects extends array
    static if (true) then
        method operator [] takes integer key returns rect
            return LoadRectHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, rect value returns nothing
        call SaveRectHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__rectm
    method operator rect takes nothing returns Table__rects
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "RectHandle", "rect", "true")
//textmacro instance: NEW_TABLE("Handle", "BooleanExprHandle", "boolexpr", "true")
struct Table__boolexprs extends array
    static if (true) then
        method operator [] takes integer key returns boolexpr
            return LoadBooleanExprHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, boolexpr value returns nothing
        call SaveBooleanExprHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__boolexprm
    method operator boolexpr takes nothing returns Table__boolexprs
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "BooleanExprHandle", "boolexpr", "true")
//textmacro instance: NEW_TABLE("Handle", "SoundHandle", "sound", "true")
struct Table__sounds extends array
    static if (true) then
        method operator [] takes integer key returns sound
            return LoadSoundHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, sound value returns nothing
        call SaveSoundHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__soundm
    method operator sound takes nothing returns Table__sounds
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "SoundHandle", "sound", "true")
//textmacro instance: NEW_TABLE("Handle", "EffectHandle", "effect", "true")
struct Table__effects extends array
    static if (true) then
        method operator [] takes integer key returns effect
            return LoadEffectHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, effect value returns nothing
        call SaveEffectHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__effectm
    method operator effect takes nothing returns Table__effects
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "EffectHandle", "effect", "true")
//textmacro instance: NEW_TABLE("Handle", "UnitPoolHandle", "unitpool", "true")
struct Table__unitpools extends array
    static if (true) then
        method operator [] takes integer key returns unitpool
            return LoadUnitPoolHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, unitpool value returns nothing
        call SaveUnitPoolHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__unitpoolm
    method operator unitpool takes nothing returns Table__unitpools
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "UnitPoolHandle", "unitpool", "true")
//textmacro instance: NEW_TABLE("Handle", "ItemPoolHandle", "itempool", "true")
struct Table__itempools extends array
    static if (true) then
        method operator [] takes integer key returns itempool
            return LoadItemPoolHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, itempool value returns nothing
        call SaveItemPoolHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__itempoolm
    method operator itempool takes nothing returns Table__itempools
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "ItemPoolHandle", "itempool", "true")
//textmacro instance: NEW_TABLE("Handle", "QuestHandle", "quest", "true")
struct Table__quests extends array
    static if (true) then
        method operator [] takes integer key returns quest
            return LoadQuestHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, quest value returns nothing
        call SaveQuestHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__questm
    method operator quest takes nothing returns Table__quests
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "QuestHandle", "quest", "true")
//textmacro instance: NEW_TABLE("Handle", "QuestItemHandle", "questitem", "true")
struct Table__questitems extends array
    static if (true) then
        method operator [] takes integer key returns questitem
            return LoadQuestItemHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, questitem value returns nothing
        call SaveQuestItemHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__questitemm
    method operator questitem takes nothing returns Table__questitems
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "QuestItemHandle", "questitem", "true")
//textmacro instance: NEW_TABLE("Handle", "DefeatConditionHandle", "defeatcondition", "true")
struct Table__defeatconditions extends array
    static if (true) then
        method operator [] takes integer key returns defeatcondition
            return LoadDefeatConditionHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, defeatcondition value returns nothing
        call SaveDefeatConditionHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__defeatconditionm
    method operator defeatcondition takes nothing returns Table__defeatconditions
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "DefeatConditionHandle", "defeatcondition", "true")
//textmacro instance: NEW_TABLE("Handle", "TimerDialogHandle", "timerdialog", "true")
struct Table__timerdialogs extends array
    static if (true) then
        method operator [] takes integer key returns timerdialog
            return LoadTimerDialogHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, timerdialog value returns nothing
        call SaveTimerDialogHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__timerdialogm
    method operator timerdialog takes nothing returns Table__timerdialogs
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TimerDialogHandle", "timerdialog", "true")
//textmacro instance: NEW_TABLE("Handle", "LeaderboardHandle", "leaderboard", "true")
struct Table__leaderboards extends array
    static if (true) then
        method operator [] takes integer key returns leaderboard
            return LoadLeaderboardHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, leaderboard value returns nothing
        call SaveLeaderboardHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__leaderboardm
    method operator leaderboard takes nothing returns Table__leaderboards
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "LeaderboardHandle", "leaderboard", "true")
//textmacro instance: NEW_TABLE("Handle", "MultiboardHandle", "multiboard", "true")
struct Table__multiboards extends array
    static if (true) then
        method operator [] takes integer key returns multiboard
            return LoadMultiboardHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, multiboard value returns nothing
        call SaveMultiboardHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__multiboardm
    method operator multiboard takes nothing returns Table__multiboards
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "MultiboardHandle", "multiboard", "true")
//textmacro instance: NEW_TABLE("Handle", "MultiboardItemHandle", "multiboarditem", "true")
struct Table__multiboarditems extends array
    static if (true) then
        method operator [] takes integer key returns multiboarditem
            return LoadMultiboardItemHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, multiboarditem value returns nothing
        call SaveMultiboardItemHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__multiboarditemm
    method operator multiboarditem takes nothing returns Table__multiboarditems
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "MultiboardItemHandle", "multiboarditem", "true")
//textmacro instance: NEW_TABLE("Handle", "TrackableHandle", "trackable", "true")
struct Table__trackables extends array
    static if (true) then
        method operator [] takes integer key returns trackable
            return LoadTrackableHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, trackable value returns nothing
        call SaveTrackableHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__trackablem
    method operator trackable takes nothing returns Table__trackables
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TrackableHandle", "trackable", "true")
//textmacro instance: NEW_TABLE("Handle", "DialogHandle", "dialog", "true")
struct Table__dialogs extends array
    static if (true) then
        method operator [] takes integer key returns dialog
            return LoadDialogHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, dialog value returns nothing
        call SaveDialogHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__dialogm
    method operator dialog takes nothing returns Table__dialogs
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "DialogHandle", "dialog", "true")
//textmacro instance: NEW_TABLE("Handle", "ButtonHandle", "button", "true")
struct Table__buttons extends array
    static if (true) then
        method operator [] takes integer key returns button
            return LoadButtonHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, button value returns nothing
        call SaveButtonHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__buttonm
    method operator button takes nothing returns Table__buttons
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "ButtonHandle", "button", "true")
//textmacro instance: NEW_TABLE("Handle", "TextTagHandle", "texttag", "true")
struct Table__texttags extends array
    static if (true) then
        method operator [] takes integer key returns texttag
            return LoadTextTagHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, texttag value returns nothing
        call SaveTextTagHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__texttagm
    method operator texttag takes nothing returns Table__texttags
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TextTagHandle", "texttag", "true")
//textmacro instance: NEW_TABLE("Handle", "LightningHandle", "lightning", "true")
struct Table__lightnings extends array
    static if (true) then
        method operator [] takes integer key returns lightning
            return LoadLightningHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, lightning value returns nothing
        call SaveLightningHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__lightningm
    method operator lightning takes nothing returns Table__lightnings
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "LightningHandle", "lightning", "true")
//textmacro instance: NEW_TABLE("Handle", "ImageHandle", "image", "true")
struct Table__images extends array
    static if (true) then
        method operator [] takes integer key returns image
            return LoadImageHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, image value returns nothing
        call SaveImageHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__imagem
    method operator image takes nothing returns Table__images
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "ImageHandle", "image", "true")
//textmacro instance: NEW_TABLE("Handle", "UbersplatHandle", "ubersplat", "true")
struct Table__ubersplats extends array
    static if (true) then
        method operator [] takes integer key returns ubersplat
            return LoadUbersplatHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, ubersplat value returns nothing
        call SaveUbersplatHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__ubersplatm
    method operator ubersplat takes nothing returns Table__ubersplats
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "UbersplatHandle", "ubersplat", "true")
//textmacro instance: NEW_TABLE("Handle", "RegionHandle", "region", "true")
struct Table__regions extends array
    static if (true) then
        method operator [] takes integer key returns region
            return LoadRegionHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, region value returns nothing
        call SaveRegionHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__regionm
    method operator region takes nothing returns Table__regions
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "RegionHandle", "region", "true")
//textmacro instance: NEW_TABLE("Handle", "FogStateHandle", "fogstate", "true")
struct Table__fogstates extends array
    static if (true) then
        method operator [] takes integer key returns fogstate
            return LoadFogStateHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, fogstate value returns nothing
        call SaveFogStateHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__fogstatem
    method operator fogstate takes nothing returns Table__fogstates
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "FogStateHandle", "fogstate", "true")
//textmacro instance: NEW_TABLE("Handle", "FogModifierHandle", "fogmodifier", "true")
struct Table__fogmodifiers extends array
    static if (true) then
        method operator [] takes integer key returns fogmodifier
            return LoadFogModifierHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, fogmodifier value returns nothing
        call SaveFogModifierHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__fogmodifierm
    method operator fogmodifier takes nothing returns Table__fogmodifiers
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "FogModifierHandle", "fogmodifier", "true")
//textmacro instance: NEW_TABLE("Handle", "AgentHandle", "agent", "false")
struct Table__agents extends array
    static if (false) then
        method operator [] takes integer key returns agent
            return LoadAgentHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, agent value returns nothing
        call SaveAgentHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__agentm
    method operator agent takes nothing returns Table__agents
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "AgentHandle", "agent", "false")
//textmacro instance: NEW_TABLE("Handle", "HashtableHandle", "hashtable", "true")
struct Table__hashtables extends array
    static if (true) then
        method operator [] takes integer key returns hashtable
            return LoadHashtableHandle(Table__ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, hashtable value returns nothing
        call SaveHashtableHandle(Table__ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endmethod
endstruct
module Table__hashtablem
    method operator hashtable takes nothing returns Table__hashtables
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "HashtableHandle", "hashtable", "true")
struct Table extends array
    
    // Implement modules for intuitive type-syntax
    implement Table__realm
    implement Table__booleanm
    implement Table__stringm
    implement Table__playerm
    implement Table__widgetm
    implement Table__destructablem
    implement Table__itemm
    implement Table__unitm
    implement Table__abilitym
    implement Table__timerm
    implement Table__triggerm
    implement Table__triggerconditionm
    implement Table__triggeractionm
    implement Table__eventm
    implement Table__forcem
    implement Table__groupm
    implement Table__locationm
    implement Table__rectm
    implement Table__boolexprm
    implement Table__soundm
    implement Table__effectm
    implement Table__unitpoolm
    implement Table__itempoolm
    implement Table__questm
    implement Table__questitemm
    implement Table__defeatconditionm
    implement Table__timerdialogm
    implement Table__leaderboardm
    implement Table__multiboardm
    implement Table__multiboarditemm
    implement Table__trackablem
    implement Table__dialogm
    implement Table__buttonm
    implement Table__texttagm
    implement Table__lightningm
    implement Table__imagem
    implement Table__ubersplatm
    implement Table__regionm
    implement Table__fogstatem
    implement Table__fogmodifierm
    implement Table__agentm
    implement Table__hashtablem
    
    
    // set this = tb[GetSpellAbilityId()]
    method operator [] takes integer key returns Table
        return LoadInteger(Table__ht, this, key)
    endmethod
    
    // set tb[389034] = 8192
    method operator []= takes integer key, Table tb returns nothing
        call SaveInteger(Table__ht, this, key, tb)
    endmethod
    
    // set b = tb.has(2493223)
    method has takes integer key returns boolean
        return HaveSavedInteger(Table__ht, this, key)
    endmethod
    
    // call tb.remove(294080)
    method remove takes integer key returns nothing
        call RemoveSavedInteger(Table__ht, this, key)
    endmethod
    
    // Remove all data from a Table instance
    method flush takes nothing returns nothing
        call FlushChildHashtable(Table__ht, this)
    endmethod
    
    // local Table tb = Table.create()
    static method create takes nothing returns Table
        if (Table__lpos == 0) then
            set Table__grow = Table__grow + 1
            return Table__grow
        endif
        set Table__lpos = Table__lpos - 1
        return Table__list[Table__lpos]
    endmethod
    
    // Removes all data from a Table instance and recycles its index.
    //
    //     call tb.destroy()
    //
    method destroy takes nothing returns nothing
        call this.flush()
        static if (false) then
            if (integer(this) < 3) then
                call BJDebugMsg("Table Error: Tried to destroy an invalid Table instance: " + I2S(this))
                return
            elseif (Table(2).boolean[this]) then
                call BJDebugMsg("Table Error: Tried to double-free instance: " + I2S(this))
                return
            endif
            // The reserved Table(2) index detects double-free of instances
            // if running in debug mode.
            set Table(2).boolean[this] = true
        endif
        if (Table__lpos < 8191) then
            set Table__list[Table__lpos] = this
            set Table__lpos = Table__lpos + 1
        endif
    endmethod
    
//ignored textmacro command: TABLE_BC_METHODS()
    
endstruct
    
//ignored textmacro command: TABLE_BC_STRUCTS()
    
struct TableArray extends array
    
    // Returns a new TableArray to do your bidding. Simply use:
    //
    //     local TableArray ta = TableArray[arraySize]
    //
    static method operator [] takes integer arraySize returns TableArray
        local Table tb = Table(1)[arraySize] // Table(1) indexes arraySizes
local TableArray ta // and instances.
local integer i
        if (integer(tb) == 0 or tb[0] == 0) then
            set Table__keys = Table__keys - arraySize // Negative values are reserved...
set Table(1)[Table__keys] = arraySize // This remembers the array size
set ta = Table__keys // All TableArray IDs are below 0
else
            set i = tb[0] // Get the last-destroyed TableArray's index
call tb.remove(0) // Clear data as we go along
set tb[0] = i - 1 // Decrease and save the recycle count
set ta = tb[i] // Retrieve the old TableArray's instance
call tb.remove(i) // Remove the old TableArray's node
        endif
        return ta
    endmethod
    
    // Returns the size of the TableArray (arraySize)
    method operator size takes nothing returns integer
        return Table(1)[this]
    endmethod
    
    // ta[integer a].unit[integer b] = unit u
    // ta[integer a][integer c] = integer d
    //
    // Inline-friendly when not running in debug mode
    //
    method operator [] takes integer key returns Table
        static if (false) then
            if (integer(this) >= 0) then
                call BJDebugMsg("TableArray Error: " + I2S(this) + " is not a valid TableArray instance")
                return 0
            endif
            if (key < 0 or key >= this.size) then
                call BJDebugMsg("TableArray Error: Tried to lookup key [" + I2S(key) + "] which is outside array bounds [" + I2S(this.size) + "]")
                return 0
            endif
        endif
        return this + key
    endmethod
    
    // Destroys a TableArray without flushing it; assumed you'd call .flush()
    // if you want it flushed too. This is public so that if you are flushing
    // instances the whole time you don't waste efficiency when disposing the
    // TableArray.
    //
    method destroy takes nothing returns nothing
        local integer i
        local Table tb = Table(1)[this.size]
        static if (false) then
            if (integer(this) >= 0 or this.size <= 0) then
                call BJDebugMsg("TableArray Error: Tried to destroy an invalid instance (" + I2S(this) + ")")
                return
            elseif (Table(2).boolean[this]) then
                call BJDebugMsg("TableArray Error: Tried to double-free instance: " + I2S(this))
                return
            endif
            set Table(2).boolean[this] = true
        endif
        if (integer(tb) == 0) then
            set tb = Table.create() // A Table to remember old indexes
set Table(1)[this.size] = tb // Save it in the reserved key (1)
set i = 1 // The recycle count is initially 1
else
            set i = tb[0] + 1 // Increase recycle count
call tb.remove(0) // Remove the "recycle count" node
endif
        set tb[0] = i // Save recycle count
set tb[i] = this // Save this under recycle count's index
endmethod
    
    // All you need to know about this one is that it won't hit the op limit.
    private static method clean takes Table tb, integer end returns nothing
        local integer i = tb + 4096
        if (i < end) then
            call clean.evaluate(i, end)
            set end = i
        endif
        loop
            call tb.flush()
            set tb = tb + 1
            exitwhen integer(tb) == end
        endloop
    endmethod
    
    // Flushes the TableArray and also destroys it. Doesn't get any more
    // similar to the FlushParentHashtable native than this.
    //
    method flush takes nothing returns nothing
        local integer end = this.size + this
        if (integer(this) < end) then
            call clean.evaluate(this, end)
            call this.destroy()
        endif
    endmethod
    
endstruct
    

//library Table ends
//library TechData:
struct TechData
    string name
    integer cat
    static method create takes string name, integer cat returns TechData
        local TechData m=TechData.allocate()
        set m.name = name
        set m.cat = cat
        return m
    endmethod
endstruct
//textmacro instance: CreateArrayList("TechTree")
struct TechTree
    integer size
    integer array itms[DEFAULT_ARRAYLIST_SIZE]
    
    static method create takes nothing returns TechTree
        local TechTree m=TechTree.allocate()
        set m.size = 0
        return m
    endmethod
    
    method addItem takes integer itm returns nothing
        set itms[size] = itm
        set size = size + 1
    endmethod
endstruct
//end of: CreateArrayList("TechTree")
function InitTechData takes nothing returns nothing
    local integer i = 0
    
    set TECH_TREE_NAME[0] = "TREE_GENERAL"
    set TECH_TREE_NAME[1] = "TREE_BLADE"
    set TECH_TREE_NAME[2] = "TREE_MAGIC_HUNTER"
    
    loop
        exitwhen i >= TT_COUNT
        set TECH_TREE_COUNT[i] = 0
        set TECH_TREES[i] = TechTree.create()
        set i = i + 1
    endloop
    
    call FlushParentHashtable(tdht)
    set tdht = InitHashtable()
//textmacro instance: InitTechData("tKMANA", "閫€榄斿垉", "TT_MAGIC_HUNTER", "0","1","0")
    call SaveStr(tdht,tKMANA,tdht_name,"閫€榄斿垉")
    call SaveInteger(tdht,tKMANA,tdht_cat,TT_MAGIC_HUNTER)
    call SaveInteger(tdht,tKMANA,tdht_tech_need,0)
    call SaveInteger(tdht,tKMANA,tdht_game_lv_need,1)
    call SaveInteger(tdht,tKMANA,tdht_base_point,0)
    call TECH_TREES[TT_MAGIC_HUNTER].addItem(tKMANA)
    set TECH_TREE_COUNT[TT_MAGIC_HUNTER] = TECH_TREE_COUNT[TT_MAGIC_HUNTER] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tKMANA", "閫€榄斿垉", "TT_MAGIC_HUNTER", "0","1","0")
//textmacro instance: InitTechData("tSTRONG", "浣撹川澧炲己", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tSTRONG,tdht_name,"浣撹川澧炲己")
    call SaveInteger(tdht,tSTRONG,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tSTRONG,tdht_tech_need,0)
    call SaveInteger(tdht,tSTRONG,tdht_game_lv_need,1)
    call SaveInteger(tdht,tSTRONG,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tSTRONG)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tSTRONG", "浣撹川澧炲己", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tDOGE", "闂伩", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tDOGE,tdht_name,"闂伩")
    call SaveInteger(tdht,tDOGE,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tDOGE,tdht_tech_need,0)
    call SaveInteger(tdht,tDOGE,tdht_game_lv_need,1)
    call SaveInteger(tdht,tDOGE,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tDOGE)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tDOGE", "闂伩", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tSPEED_SHOOT", "鎬ラ€熷皠鍑?, "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tSPEED_SHOOT,tdht_name,"鎬ラ€熷皠鍑?)
    call SaveInteger(tdht,tSPEED_SHOOT,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tSPEED_SHOOT,tdht_tech_need,0)
    call SaveInteger(tdht,tSPEED_SHOOT,tdht_game_lv_need,1)
    call SaveInteger(tdht,tSPEED_SHOOT,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tSPEED_SHOOT)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tSPEED_SHOOT", "鎬ラ€熷皠鍑?, "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tAIM_SHOOT", "绮惧噯灏勫嚮", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tAIM_SHOOT,tdht_name,"绮惧噯灏勫嚮")
    call SaveInteger(tdht,tAIM_SHOOT,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tAIM_SHOOT,tdht_tech_need,0)
    call SaveInteger(tdht,tAIM_SHOOT,tdht_game_lv_need,1)
    call SaveInteger(tdht,tAIM_SHOOT,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tAIM_SHOOT)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tAIM_SHOOT", "绮惧噯灏勫嚮", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tSAVE", "鑺傝兘", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tSAVE,tdht_name,"鑺傝兘")
    call SaveInteger(tdht,tSAVE,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tSAVE,tdht_tech_need,0)
    call SaveInteger(tdht,tSAVE,tdht_game_lv_need,1)
    call SaveInteger(tdht,tSAVE,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tSAVE)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tSAVE", "鑺傝兘", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tFREZZ", "鎬ュ喕", "TT_ICE", "0","1","0")
    call SaveStr(tdht,tFREZZ,tdht_name,"鎬ュ喕")
    call SaveInteger(tdht,tFREZZ,tdht_cat,TT_ICE)
    call SaveInteger(tdht,tFREZZ,tdht_tech_need,0)
    call SaveInteger(tdht,tFREZZ,tdht_game_lv_need,1)
    call SaveInteger(tdht,tFREZZ,tdht_base_point,0)
    call TECH_TREES[TT_ICE].addItem(tFREZZ)
    set TECH_TREE_COUNT[TT_ICE] = TECH_TREE_COUNT[TT_ICE] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tFREZZ", "鎬ュ喕", "TT_ICE", "0","1","0")
//textmacro instance: InitTechData("tMANA_BOOM", "鑳介噺鐖嗙偢", "TT_MAGIC_HUNTER", "0","1","0")
    call SaveStr(tdht,tMANA_BOOM,tdht_name,"鑳介噺鐖嗙偢")
    call SaveInteger(tdht,tMANA_BOOM,tdht_cat,TT_MAGIC_HUNTER)
    call SaveInteger(tdht,tMANA_BOOM,tdht_tech_need,0)
    call SaveInteger(tdht,tMANA_BOOM,tdht_game_lv_need,1)
    call SaveInteger(tdht,tMANA_BOOM,tdht_base_point,0)
    call TECH_TREES[TT_MAGIC_HUNTER].addItem(tMANA_BOOM)
    set TECH_TREE_COUNT[TT_MAGIC_HUNTER] = TECH_TREE_COUNT[TT_MAGIC_HUNTER] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tMANA_BOOM", "鑳介噺鐖嗙偢", "TT_MAGIC_HUNTER", "0","1","0")
//textmacro instance: InitTechData("tANTRAD", "杈愬皠鎶垫姉", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tANTRAD,tdht_name,"杈愬皠鎶垫姉")
    call SaveInteger(tdht,tANTRAD,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tANTRAD,tdht_tech_need,0)
    call SaveInteger(tdht,tANTRAD,tdht_game_lv_need,1)
    call SaveInteger(tdht,tANTRAD,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tANTRAD)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tANTRAD", "杈愬皠鎶垫姉", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tFIRE_CHARGE", "鐑堢劙鍏呰兘", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tFIRE_CHARGE,tdht_name,"鐑堢劙鍏呰兘")
    call SaveInteger(tdht,tFIRE_CHARGE,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tFIRE_CHARGE,tdht_tech_need,0)
    call SaveInteger(tdht,tFIRE_CHARGE,tdht_game_lv_need,1)
    call SaveInteger(tdht,tFIRE_CHARGE,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tFIRE_CHARGE)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tFIRE_CHARGE", "鐑堢劙鍏呰兘", "TT_GENERAL", "0","1","0")
endfunction

//library TechData ends
//library TechUnit:
function TechUnitCondition takes nothing returns boolean
    local player p = GetTriggerPlayer()
    local integer i = GetPlayerId(p)
    if bigU[i] != null and IsUnitAliveBJ(bigU[i]) then
    else
        set bigU[i] = CreateUnit(p, 'h00A', GetRectCenterX(gg_rct_tech),GetRectCenterY(gg_rct_tech),0)
    endif
    set p = null
    return false
endfunction
function TechUnitCondition2 takes nothing returns boolean
    local player p = GetTriggerPlayer()
    local integer i = GetPlayerId(p)
    if bigU[i] != null and IsUnitAliveBJ(bigU[i]) then
        call KillUnit(bigU[i])
    else
    endif
    set p = null
    return false
endfunction
function InitTechUnit takes nothing returns nothing
    set techUnit = CreateTrigger()
    set techUnit2 = CreateTrigger()
    call TriggerRegisterPlayerStateEvent( techUnit, Player(0), PLAYER_STATE_RESOURCE_LUMBER, GREATER_THAN_OR_EQUAL, 5.00 )
    call TriggerRegisterPlayerStateEvent( techUnit, Player(1), PLAYER_STATE_RESOURCE_LUMBER, GREATER_THAN_OR_EQUAL, 5.00 )
    call TriggerRegisterPlayerStateEvent( techUnit, Player(2), PLAYER_STATE_RESOURCE_LUMBER, GREATER_THAN_OR_EQUAL, 5.00 )
    call TriggerAddCondition(techUnit, function TechUnitCondition)
    call TriggerRegisterPlayerStateEvent( techUnit2, Player(0), PLAYER_STATE_RESOURCE_LUMBER, LESS_THAN, 5.00 )
    call TriggerRegisterPlayerStateEvent( techUnit2, Player(1), PLAYER_STATE_RESOURCE_LUMBER, LESS_THAN, 5.00 )
    call TriggerRegisterPlayerStateEvent( techUnit2, Player(2), PLAYER_STATE_RESOURCE_LUMBER, LESS_THAN, 5.00 )
    call TriggerAddCondition(techUnit2, function TechUnitCondition2)
endfunction
function NotHealth takes integer i returns nothing
    call KillUnit(health[i])
    set EquipmentData[GetTriggerUnit()].heroData.shoot_buffer = 0
    set health[i] = null
endfunction
function BeHealth takes integer i returns nothing
    set health[i] = CreateUnit(Player(i), 'h00F', GetRectCenterX(gg_rct_tech),GetRectCenterY(gg_rct_tech),0)
    call UnitRemoveAbility(heros[i], 'Avul')
    call UnitRemoveAbility(heros[i], 'A02H')
    call SetUnitState(heros[i], UNIT_STATE_LIFE, 100.0)
    call SetUnitState(heros[i], UNIT_STATE_MANA, 100.0)
endfunction

//library TechUnit ends
//library Text:
function DisplayText takes player p, string msg returns nothing
    call DisplayTextToPlayer( p, 0, 0, msg )
endfunction
function DisplayInfo takes player p, string msg returns nothing
    call DisplayTextToPlayer( p, 0, 0, "|cFFFFFF00"+msg+"|r" )
endfunction
function DisplayWarning takes player p, string msg returns nothing
    call DisplayTextToPlayer( p, 0, 0, "|cFFFF6666"+msg+"|r" )
endfunction
function DisplayInfoAll takes string msg returns nothing
    local integer i = 0
    loop
        exitwhen i >= PLAYER_COUNT
        call DisplayInfo(Player(i), msg)
        set i = i + 1
    endloop
endfunction

//library Text ends
//library TimerUtils:
//*********************************************************************
//* TimerUtils (Purple flavor for 1.23b or later)
//* ----------
//*
//*  To implement it , create a custom text trigger called TimerUtils
//* and paste the contents of this script there.
//*
//*  To copy from a map to another, copy the trigger holding this
//* library to your map.
//*
//* (requires vJass)   More scripts: http://www.wc3c.net/
//*
//* For your timer needs:
//*  * Attaching
//*  * Recycling (with double-free protection)
//*
//* set t=NewTimer()      : Get a timer (alternative to CreateTimer)
//* ReleaseTimer(t)       : Relese a timer (alt to DestroyTimer)
//* SetTimerData(t,2)     : Attach value 2 to timer
//* GetTimerData(t)       : Get the timer's value.
//*                         You can assume a timer's value is 0
//*                         after NewTimer.
//*
//* Purple Flavor: Slower than the red flavor by a multiplication and a
//*             division, and as such faster than the blue flavor. Has
//*             a theoretical limit of timers, which is HASH_SIZE, but
//*             you should keep your timer count below 3/4 of that to
//*             insure good performance of the NewTimer function.
//*
//* Credits:  * Hash algorithm by Cohadar (used in an early version
//*             of his ABCT timer system)
//*
//*           * TimerUtils "interface" by Vexorian.
//*
//*           * This library by Iron_Doors.
//*
//********************************************************************
//================================================================
    //It is dependent on jasshelper's recent inlining optimization in order to perform correctly.
    function SetTimerData takes timer t, integer value returns nothing
        set TimerUtils__data[GetHandleId(t)-TimerUtils__MIN_HANDLE_ID]=value
    endfunction
    function GetTimerData takes timer t returns integer
        return TimerUtils__data[GetHandleId(t)-TimerUtils__MIN_HANDLE_ID]
    endfunction
    function NewTimer takes nothing returns timer
        if (TimerUtils__tN==0) then
            set TimerUtils__tT[0]=CreateTimer()
        else
            set TimerUtils__tN=TimerUtils__tN-1
        endif
        call SetTimerData(TimerUtils__tT[TimerUtils__tN],0)
     return TimerUtils__tT[TimerUtils__tN]
    endfunction
    function ReleaseTimer takes timer t returns nothing
        if(t==null) then
            return
        endif
        if (TimerUtils__tN==8191) then
            //stack is full, the map already has much more troubles than the chance of bug
            call DestroyTimer(t)
        else
            call PauseTimer(t)
            if(GetTimerData(t)==TimerUtils__HELD) then
                return
            endif
            call SetTimerData(t,TimerUtils__HELD)
            set TimerUtils__tT[TimerUtils__tN]=t
            set TimerUtils__tN=TimerUtils__tN+1
        endif 
    endfunction

//library TimerUtils ends
//library Union:
    
    
    // If your Warcraft version isn`t 1.24 delete it, or must preserve the function.
   // function GetHandleId takes handle h returns integer
    //    return h
    //    return 0
    //endfunction
    function Adaptation takes nothing returns boolean
        return true
    endfunction
    
    function Incident takes playerunitevent case, conditionfunc cond, code act returns nothing
        local trigger t = CreateTrigger()
        local integer index = 0
        loop
            call TriggerRegisterPlayerUnitEvent(t, Player(index), case, Union__FilterLeisure)
            set index = index + 1
            exitwhen index == 12
        endloop
        call TriggerAddCondition(t, cond)
        call TriggerAddAction(t, act)
        set t = null
    endfunction
    
    function Init takes nothing returns nothing
        set Union__FilterLeisure = Filter(function Adaptation)
    endfunction
    

//library Union ends
//library UnitId:
function IsHero takes unit u returns boolean
    return GetUnitTypeId(u) == HERO
endfunction
function IsWall takes unit u returns boolean
    return GetUnitTypeId(u) == ONE_WALL
endfunction
function IsWall2 takes unit u returns boolean
    return GetUnitTypeId(u) == ONE_WALL_BREAKABLE
endfunction
function IsBoss takes unit u returns boolean
    local integer t = GetUnitTypeId(u)
    if t == 'u002' or t == 'u004' then
        return true
    endif
    return false
endfunction

//library UnitId ends
//library Vector:
//*****************************************************************
//*  VECTOR LIBRARY
//*
//*  written by: Anitarf
//*
//*  The library contains a struct named vector, which represents a
//*  point in 3D space. As such, it has three real members, one for
//*  each coordinate: x, y, z. It also has the following methods:
//*
//*        static method create takes real x, real y, real z returns vector
//*  Creates a new vector with the given coordinates.
//*
//*        method getLength takes nothing returns real
//*  Returns the length of the vector it is called on.
//*
//*        static method sum takes vector augend, vector addend returns vector
//*  Returns the sum of two vectors as a new vector.
//*
//*        method add takes vector addend returns nothing
//*  Similar to sum, except that it doesn't create a new vector for the result,
//*  but changes the vector it is called on by adding the "added" to it.
//*
//*        static method difference takes vector minuend, vector subtrahend returns vector
//*  Returns the difference between two vectors as a new vector.
//*
//*        method subtract takes vector subtrahend returns nothing
//*  Similar to difference, except that it doesn't create a new vector for the result,
//*  but changes the vector it is called on by subtracting the "subtrahend" from it.
//*
//*        method scale takes real factor returns nothing
//*  Scales the vector it is called on by the given factor.
//*
//*        method setLength takes real length returns nothing
//*  Sets the length of the vector it is called on to the given value, maintaining its orientation.
//*
//*        static method dotProduct takes vector a, vector b returns real
//*  Calculates the dot product (also called scalar product) of two vectors.
//*
//*        static method crossProduct takes vector a, vector b returns vector
//*  Calculates the cross product (also called vector product) of two vectors
//*  and returns it as a new vector.
//*
//*        static method tripleProductScalar takes vector a, vector b, vector c returns real
//*  Calculates the triple scalar product of three vectors.
//*
//*        static method tripleProductVector takes vector a, vector b, vector c returns vector
//*  Calculates the triple vector product of three vectors and returns it as a new vector.
//*
//*
//*        static method projectionVector takes vector projected, vector direction returns vector
//*  Calculates the projection of the vector "projected" onto the vector "direction"
//*  and returns it as a new vector.
//*  Returns null if the vector "direction" has a length of 0.
//*
//*        method projectVector takes vector direction returns nothing
//*  Projects the vector it is called on onto the vector "direction".
//*  Does nothing if the vector "direction" has a length of 0.
//*
//*        static method projectionPlane takes vector projected, vector normal returns vector
//*  Calculates the projection of the vector "projected" onto a plane defined by
//*  its normal vector and returns it as a new vector.
//*  Returns null if the vector "normal" has a length of 0.
//*
//*        method projectPlane takes vector normal returns nothing
//*  Projects the vector it is called on onto a plane defined by its normal vector.
//*  Does nothing if the vector "normal" has a length of 0.
//*
//*        static method getAngle takes vector a, vector b returns real
//*  Returns the angle between two vectors, in radians, returns a value between 0 and pi.
//*  Returns 0.0 if any of the vectors are 0 units long.
//*
//*        method rotate takes vector axis, real angle returns nothing
//*  Rotates the vector it is called on around the axis defined by the vector "axis"
//*  by the given angle, which should be input in radians.
//*  Does nothing if axis is 0 units long.
//*
//*
//*        static method createTerrainPoint takes real x, real y returns vector
//*  Creates a vector to the given terrain coordinate, taking its z height into account.
//*
//*        method getTerrainPoint takes real x, real y returns nothing
//*  Sets the vector it is called on to the given terrain coordinate, taking its z height into account.
//*
//*        static method createTerrainNormal takes real x, real y, real sampleRadius returns vector
//*  Creates the normal vector of the terrain at given coordinates. "sampleRadius" defines
//*  how far apart the reference points will be, if they are further apart, the result will
//*  be an impression of smoother terrain; normaly the value should be between 0 and 128.
//*
//*        method getTerrainNormal takes real x, real y, real sampleRadius returns nothing
//*  Sets the vector it is called on to the normal of the terrain at given coordinates.
//*
//*
//*        method isInCylinder takes vector cylinderOrigin, vector cylinderHeight, real cylinderRadius returns boolean
//*  Determines if a point is within a given cylinder. The cylinder's origin vector points
//*  to the center of one of the two paralel circular sides, and the height vector points
//*  from the origin point to the center of the other of the two paralel circular sides.
//*  Returns false if the point is not in the cylinder or if the vector cylinderHeight is 0 units long.
//*
//*        method isInCone takes vector coneOrigin, vector coneHeight, real coneRadius returns boolean
//*  Determines if a point is within a given cone. The cone's origin vector points to the
//*  center of the circular side, and the height vector points from the origin point to
//*  the tip of the cone.
//*  Returns false if the point is not in the cylinder or if the vector coneHeight is 0 units long.
//*
//*        method isInSphere takes vector sphereOrigin, real sphereRadius returns boolean
//*  Determines if a point is within a give sphere. The sphere's origin vector points to the
//*  center of the sphere.
//*  Returns false if the point is not in the sphere.
//*****************************************************************
    struct vector
        real x
        real y
        real z
        
        static method create takes real x, real y, real z returns vector
            local vector v = vector.allocate()
            set v.x=x
            set v.y=y
            set v.z=z
            return v
        endmethod
        
        method getLength takes nothing returns real
          return SquareRoot(.x*.x + .y*.y + .z*.z)
        endmethod
        
        method reverse takes nothing returns nothing
            set this.x = -this.x
            set this.y = -this.y
            set this.z = -this.z
        endmethod
        
        static method unitVector takes vector v returns vector
            local vector uv = vector.allocate()
            local real length = v.getLength()
            if length == 0 then
                return vector.create(0,0,0)
            endif
            set uv.x = v.x/length
            set uv.y = v.y/length
            set uv.z = v.z/length
            return uv
        endmethod
        
        static method sum takes vector augend, vector addend returns vector
            local vector v = vector.allocate()
            set v.x = augend.x+addend.x
            set v.y = augend.y+addend.y
            set v.z = augend.z+addend.z
            return v
        endmethod
        method add takes vector addend returns nothing
            set this.x=this.x+addend.x
            set this.y=this.y+addend.y
            set this.z=this.z+addend.z
        endmethod
        
        static method difference takes vector minuend, vector subtrahend returns vector
            local vector v = vector.allocate()
            set v.x = minuend.x-subtrahend.x
            set v.y = minuend.y-subtrahend.y
            set v.z = minuend.z-subtrahend.z
            return v
        endmethod
        method subtract takes vector subtrahend returns nothing
            set this.x=this.x-subtrahend.x
            set this.y=this.y-subtrahend.y
            set this.z=this.z-subtrahend.z
        endmethod
        
        method scale takes real factor returns nothing
            set this.x=this.x*factor
            set this.y=this.y*factor
            set this.z=this.z*factor
        endmethod
        
        static method scale2 takes vector v, real factor returns vector
            local vector r = vector.allocate()
            set r.x=v.x*factor
            set r.y=v.y*factor
            set r.z=v.z*factor
            return r
        endmethod
        
        method setLength takes real length returns nothing
            local real l = SquareRoot(.x*.x + .y*.y + .z*.z)
            if l == 0.0 then
                return
            endif
            set l = length/l
            set this.x = this.x*l
            set this.y = this.y*l
            set this.z = this.z*l
        endmethod
        
        static method dotProduct takes vector a, vector b returns real
            return (a.x*b.x+a.y*b.y+a.z*b.z)
        endmethod
        
        static method crossProduct takes vector a, vector b returns vector
            local vector v = vector.allocate()
            set v.x = a.y*b.z - a.z*b.y
            set v.y = a.z*b.x - a.x*b.z
            set v.z = a.x*b.y - a.y*b.x
            return v
        endmethod
        static method tripleProductScalar takes vector a, vector b, vector c returns real
            return ((a.y*b.z - a.z*b.y)*c.x+(a.z*b.x - a.x*b.z)*c.y+(a.x*b.y - a.y*b.x)*c.z)
        endmethod
        static method tripleProductVector takes vector a, vector b, vector c returns vector
            local vector v = vector.allocate()
            local real n = a.x*c.x+a.y*c.y+a.z*c.z
            local real m = a.x*b.x+a.y*b.y+a.z*b.z
            set v.x = b.x*n-c.x*m
            set v.y = b.y*n-c.y*m
            set v.z = b.z*n-c.z*m
            return v
        endmethod
// ================================================================
        static method projectionVector takes vector projected, vector direction returns vector
            local vector v = vector.allocate()
            local real l = direction.x*direction.x+direction.y*direction.y+direction.z*direction.z
            if l == 0.0 then
                call v.destroy()
                return 0
            endif
            set l = (projected.x*direction.x+projected.y*direction.y+projected.z*direction.z) / l
            set v.x = direction.x*l
            set v.y = direction.y*l
            set v.z = direction.z*l
            return v
        endmethod
        method projectVector takes vector direction returns nothing
            local real l = direction.x*direction.x+direction.y*direction.y+direction.z*direction.z
            if l == 0.0 then
                return
            endif
            set l = (this.x*direction.x+this.y*direction.y+this.z*direction.z) / l
            set this.x = direction.x*l
            set this.y = direction.y*l
            set this.z = direction.z*l
        endmethod
        static method projectionPlane takes vector projected, vector normal returns vector
            local vector v = vector.allocate()
            local real l = normal.x*normal.x+normal.y*normal.y+normal.z*normal.z
            if l == 0.0 then
                call v.destroy()
                return 0
            endif
            set l = (projected.x*normal.x+projected.y*normal.y+projected.z*normal.z) / l
            set v.x = projected.x - normal.x*l
            set v.y = projected.y - normal.y*l
            set v.z = projected.z - normal.z*l
            return v
        endmethod
        method projectPlane takes vector normal returns nothing
            local real l = normal.x*normal.x+normal.y*normal.y+normal.z*normal.z
            if l == 0.0 then
                return
            endif
            set l = (this.x*normal.x+this.y*normal.y+this.z*normal.z) / l
            set this.x = this.x - normal.x*l
            set this.y = this.y - normal.y*l
            set this.z = this.z - normal.z*l
        endmethod
        static method getAngle takes vector a, vector b returns real
            local real l = SquareRoot(a.x*a.x + a.y*a.y + a.z*a.z)*SquareRoot(b.x*b.x + b.y*b.y + b.z*b.z)
            if l == 0 then
                return 0.0
            endif
            return Acos((a.x*b.x+a.y*b.y+a.z*b.z)/l) //angle is returned in radians
endmethod
        
        method rotate takes vector axis, real angle returns nothing //angle is taken in radians
local real xx
            local real xy
            local real xz
            local real yx
            local real yy
            local real yz
            local real zx
            local real zy
            local real zz
            local real al = axis.x*axis.x+axis.y*axis.y+axis.z*axis.z //axis length^2
local real f
            local real c = Cos(angle)
            local real s = Sin(angle)
            if al == 0.0 then
                return
            endif
            set f = (this.x*axis.x+this.y*axis.y+this.z*axis.z) / al
            set zx = axis.x*f
            set zy = axis.y*f
            set zz = axis.z*f //axis component of rotated vector
set xx = this.x-zx
            set xy = this.y-zy
            set xz = this.z-zz //component of vector perpendicular to axis
set al = SquareRoot(al)
            set yx = (axis.y*xz - axis.z*xy)/al
            set yy = (axis.z*xx - axis.x*xz)/al //y same length as x by using cross product and dividing with axis length
set yz = (axis.x*xy - axis.y*xx)/al //x,y - coordinate system in which we rotate
set this.x=xx*c+yx*s+zx
            set this.y=xy*c+yy*s+zy
            set this.z=xz*c+yz*s+zz
        endmethod
        
// ================================================================
        private static location loc = Location(0.0,0.0)
        static method createTerrainPoint takes real x, real y returns vector
            local vector v = vector.allocate()
            call MoveLocation(vector.loc,x,y)
            set v.x=x
            set v.y=y
            set v.z=GetLocationZ(loc)
            return v
        endmethod
        method getTerrainPoint takes real x, real y returns nothing
            call MoveLocation(vector.loc,x,y)
            set this.x=x
            set this.y=y
            set this.z=GetLocationZ(loc)
        endmethod
        static method createTerrainNormal takes real x, real y, real sampleRadius returns vector
            local vector v = vector.allocate()
            local real zx
            local real zy
            call MoveLocation(vector.loc, x-sampleRadius, y)
            set zx=GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x+sampleRadius, y)
            set zx=zx-GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x, y-sampleRadius)
            set zy=GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x, y+sampleRadius)
            set zy=zy-GetLocationZ(vector.loc)
            set sampleRadius=2*sampleRadius
            set v.x = zx*sampleRadius
            set v.y = zy*sampleRadius
            set v.z = sampleRadius*sampleRadius
            return v
        endmethod
        method getTerrainNormal takes real x, real y, real sampleRadius returns nothing
            local real zx
            local real zy
            call MoveLocation(vector.loc, x-sampleRadius, y)
            set zx=GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x+sampleRadius, y)
            set zx=zx-GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x, y-sampleRadius)
            set zy=GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x, y+sampleRadius)
            set zy=zy-GetLocationZ(vector.loc)
            set sampleRadius=2*sampleRadius
            set this.x = zx*sampleRadius
            set this.y = zy*sampleRadius
            set this.z = sampleRadius*sampleRadius
        endmethod
// ================================================================
        method isInCylinder takes vector cylinderOrigin, vector cylinderHeight, real cylinderRadius returns boolean
            local real l
            local real x = this.x-cylinderOrigin.x
            local real y = this.y-cylinderOrigin.y
            local real z = this.z-cylinderOrigin.z
            if x*cylinderHeight.x+y*cylinderHeight.y+z*cylinderHeight.z < 0.0 then //point below cylinder
return false
            endif
            
            set x = x-cylinderHeight.x
            set y = y-cylinderHeight.y
            set z = z-cylinderHeight.z
            if x*cylinderHeight.x+y*cylinderHeight.y+z*cylinderHeight.z > 0.0 then //point above cylinder
return false
            endif
            
            set l = cylinderHeight.x*cylinderHeight.x+cylinderHeight.y*cylinderHeight.y+cylinderHeight.z*cylinderHeight.z
            if l == 0.0 then
                return false
            endif
            set l = (x*cylinderHeight.x+y*cylinderHeight.y+z*cylinderHeight.z) / l
            set x = x - cylinderHeight.x*l
            set y = y - cylinderHeight.y*l
            set z = z - cylinderHeight.z*l
            if x*x+y*y+z*z > cylinderRadius*cylinderRadius then //point outside cylinder
return false
            endif
            
            return true
        endmethod
        method isInCone takes vector coneOrigin, vector coneHeight, real coneRadius returns boolean
            local real l
            local real x = this.x-coneOrigin.x
            local real y = this.y-coneOrigin.y
            local real z = this.z-coneOrigin.z
            if x*coneHeight.x+y*coneHeight.y+z*coneHeight.z < 0.0 then //point below cone
return false
            endif
            
            set l = coneHeight.x*coneHeight.x+coneHeight.y*coneHeight.y+coneHeight.z*coneHeight.z
            if l == 0.0 then
                return false
            endif
            set l = (x*coneHeight.x+y*coneHeight.y+z*coneHeight.z) / l
            set x = x - coneHeight.x*l
            set y = y - coneHeight.y*l
            set z = z - coneHeight.z*l
            if SquareRoot(x*x+y*y+z*z) > coneRadius*(1.0-l) then //point outside cone
return false
            endif
            
            return true
        endmethod
        method isInSphere takes vector sphereOrigin, real sphereRadius returns boolean
            if sphereRadius*sphereRadius < ((this.x-sphereOrigin.x)*(this.x-sphereOrigin.x)+(this.y-sphereOrigin.y)*(this.y-sphereOrigin.y)+(this.z-sphereOrigin.z)*(this.z-sphereOrigin.z)) then
                return false
            endif
            return true
        endmethod
    endstruct

//library Vector ends
//library YDTriggerSaveLoadSystem:
	function YDTriggerSaveLoadSystem__Init takes nothing returns nothing
		set YDHT = InitHashtable() 
	endfunction

//library YDTriggerSaveLoadSystem ends
//library YDWEBase:
//===========================================================================
//HashTable
//===========================================================================
//===========================================================================
//Return bug
//===========================================================================
function YDWEH2I takes handle h returns integer
    return GetHandleId(h)
endfunction
//清空
function YDWEFlushAllData takes nothing returns nothing
    call FlushParentHashtable(YDHT)
endfunction
function YDWEFlushMissionByInteger takes integer i returns nothing
    call FlushChildHashtable(YDHT,i)
endfunction
function YDWEFlushMissionByString takes string s returns nothing
    call FlushChildHashtable(YDHT,StringHash(s))
endfunction
function YDWEFlushStoredIntegerByInteger takes integer i,integer j returns nothing
    call RemoveSavedInteger(YDHT,i,j)
endfunction
function YDWEFlushStoredIntegerByString takes string s1,string s2 returns nothing
    call RemoveSavedInteger(YDHT,StringHash(s1),StringHash(s2))
endfunction
function YDWEHaveSavedIntegerByInteger takes integer i,integer j returns boolean
    return HaveSavedInteger(YDHT,i,j)
endfunction
function YDWEHaveSavedIntegerByString takes string s1,string s2 returns boolean
    return HaveSavedInteger(YDHT,StringHash(s1),StringHash(s2))
endfunction
//store and get integer
function YDWESaveIntegerByInteger takes integer pTable,integer pKey,integer i returns nothing
    call SaveInteger(YDHT,pTable,pKey,i)
endfunction
function YDWESaveIntegerByString takes string pTable,string pKey,integer i returns nothing
    call SaveInteger(YDHT,StringHash(pTable),StringHash(pKey),i)
endfunction
function YDWEGetIntegerByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT,pTable,pKey)
endfunction
function YDWEGetIntegerByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//store and get real
function YDWESaveRealByInteger takes integer pTable,integer pKey,real r returns nothing
    call SaveReal(YDHT,pTable,pKey,r)
endfunction
function YDWESaveRealByString takes string pTable,string pKey,real r returns nothing
    call SaveReal(YDHT,StringHash(pTable),StringHash(pKey),r)
endfunction
function YDWEGetRealByInteger takes integer pTable,integer pKey returns real
    return LoadReal(YDHT,pTable,pKey)
endfunction
function YDWEGetRealByString takes string pTable,string pKey returns real
    return LoadReal(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//store and get string
function YDWESaveStringByInteger takes integer pTable,integer pKey,string s returns nothing
    call SaveStr(YDHT,pTable,pKey,s)
endfunction
function YDWESaveStringByString takes string pTable,string pKey,string s returns nothing
    call SaveStr(YDHT,StringHash(pTable),StringHash(pKey),s)
endfunction
function YDWEGetStringByInteger takes integer pTable,integer pKey returns string
    return LoadStr(YDHT,pTable,pKey)
endfunction
function YDWEGetStringByString takes string pTable,string pKey returns string
    return LoadStr(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//store and get boolean
function YDWESaveBooleanByInteger takes integer pTable,integer pKey,boolean b returns nothing
    call SaveBoolean(YDHT,pTable,pKey,b)
endfunction
function YDWESaveBooleanByString takes string pTable,string pKey,boolean b returns nothing
    call SaveBoolean(YDHT,StringHash(pTable),StringHash(pKey),b)
endfunction
function YDWEGetBooleanByInteger takes integer pTable,integer pKey returns boolean
    return LoadBoolean(YDHT,pTable,pKey)
endfunction
function YDWEGetBooleanByString takes string pTable,string pKey returns boolean
    return LoadBoolean(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Unit
function YDWESaveUnitByInteger takes integer pTable,integer pKey,unit u returns nothing
    call SaveUnitHandle(YDHT,pTable,pKey,u)
endfunction
function YDWESaveUnitByString takes string pTable,string pKey,unit u returns nothing
    call SaveUnitHandle(YDHT,StringHash(pTable),StringHash(pKey),u)
endfunction
function YDWEGetUnitByInteger takes integer pTable,integer pKey returns unit
    return LoadUnitHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetUnitByString takes string pTable,string pKey returns unit
    return LoadUnitHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert UnitID
function YDWESaveUnitIDByInteger takes integer pTable,integer pKey,integer uid returns nothing
    call SaveInteger(YDHT,pTable,pKey,uid)
endfunction
function YDWESaveUnitIDByString takes string pTable,string pKey,integer uid returns nothing
    call SaveInteger(YDHT,StringHash(pTable),StringHash(pKey),uid)
endfunction
function YDWEGetUnitIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT,pTable,pKey)
endfunction
function YDWEGetUnitIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert AbilityID
function YDWESaveAbilityIDByInteger takes integer pTable,integer pKey,integer abid returns nothing
    call SaveInteger(YDHT,pTable,pKey,abid)
endfunction
function YDWESaveAbilityIDByString takes string pTable,string pKey,integer abid returns nothing
    call SaveInteger(YDHT,StringHash(pTable),StringHash(pKey),abid)
endfunction
function YDWEGetAbilityIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT,pTable,pKey)
endfunction
function YDWEGetAbilityIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Player
function YDWESavePlayerByInteger takes integer pTable,integer pKey,player p returns nothing
    call SavePlayerHandle(YDHT,pTable,pKey,p)
endfunction
function YDWESavePlayerByString takes string pTable,string pKey,player p returns nothing
    call SavePlayerHandle(YDHT,StringHash(pTable),StringHash(pKey),p)
endfunction
function YDWEGetPlayerByInteger takes integer pTable,integer pKey returns player
    return LoadPlayerHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetPlayerByString takes string pTable,string pKey returns player
    return LoadPlayerHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Item
function YDWESaveItemByInteger takes integer pTable,integer pKey,item it returns nothing
    call SaveItemHandle(YDHT,pTable,pKey,it)
endfunction
function YDWESaveItemByString takes string pTable,string pKey,item it returns nothing
    call SaveItemHandle(YDHT,StringHash(pTable),StringHash(pKey),it)
endfunction
function YDWEGetItemByInteger takes integer pTable,integer pKey returns item
    return LoadItemHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetItemByString takes string pTable,string pKey returns item
    return LoadItemHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert ItemID
function YDWESaveItemIDByInteger takes integer pTable,integer pKey,integer itid returns nothing
    call SaveInteger(YDHT,pTable,pKey,itid)
endfunction
function YDWESaveItemIDByString takes string pTable,string pKey,integer itid returns nothing
    call SaveInteger(YDHT,StringHash(pTable),StringHash(pKey),itid)
endfunction
function YDWEGetItemIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT,pTable,pKey)
endfunction
function YDWEGetItemIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Timer
function YDWESaveTimerByInteger takes integer pTable,integer pKey,timer t returns nothing
    call SaveTimerHandle(YDHT,pTable,pKey,t)
endfunction
function YDWESaveTimerByString takes string pTable,string pKey,timer t returns nothing
    call SaveTimerHandle(YDHT,StringHash(pTable),StringHash(pKey),t)
endfunction
function YDWEGetTimerByInteger takes integer pTable,integer pKey returns timer
    return LoadTimerHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTimerByString takes string pTable,string pKey returns timer
    return LoadTimerHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Trigger
function YDWESaveTriggerByInteger takes integer pTable,integer pKey,trigger trg returns nothing
    call SaveTriggerHandle(YDHT,pTable,pKey,trg)
endfunction
function YDWESaveTriggerByString takes string pTable,string pKey,trigger trg returns nothing
    call SaveTriggerHandle(YDHT,StringHash(pTable),StringHash(pKey),trg)
endfunction
function YDWEGetTriggerByInteger takes integer pTable,integer pKey returns trigger
    return LoadTriggerHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTriggerByString takes string pTable,string pKey returns trigger
    return LoadTriggerHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Location
function YDWESaveLocationByInteger takes integer pTable,integer pKey,location pt returns nothing
    call SaveLocationHandle(YDHT,pTable,pKey,pt)
endfunction
function YDWESaveLocationByString takes string pTable,string pKey,location pt returns nothing
    call SaveLocationHandle(YDHT,StringHash(pTable),StringHash(pKey),pt)
endfunction
function YDWEGetLocationByInteger takes integer pTable,integer pKey returns location
    return LoadLocationHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetLocationByString takes string pTable,string pKey returns location
    return LoadLocationHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Group
function YDWESaveGroupByInteger takes integer pTable,integer pKey,group g returns nothing
    call SaveGroupHandle(YDHT,pTable,pKey,g)
endfunction
function YDWESaveGroupByString takes string pTable,string pKey,group g returns nothing
    call SaveGroupHandle(YDHT,StringHash(pTable),StringHash(pKey),g)
endfunction
function YDWEGetGroupByInteger takes integer pTable,integer pKey returns group
    return LoadGroupHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetGroupByString takes string pTable,string pKey returns group
    return LoadGroupHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Multiboard
function YDWESaveMultiboardByInteger takes integer pTable,integer pKey,multiboard m returns nothing
    call SaveMultiboardHandle(YDHT,pTable,pKey,m)
endfunction
function YDWESaveMultiboardByString takes string pTable,string pKey,multiboard m returns nothing
    call SaveMultiboardHandle(YDHT,StringHash(pTable),StringHash(pKey),m)
endfunction
function YDWEGetMultiboardByInteger takes integer pTable,integer pKey returns multiboard
    return LoadMultiboardHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetMultiboardByString takes string pTable,string pKey returns multiboard
    return LoadMultiboardHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert MultiboardItem
function YDWESaveMultiboardItemByInteger takes integer pTable,integer pKey,multiboarditem mt returns nothing
    call SaveMultiboardItemHandle(YDHT,pTable,pKey,mt)
endfunction
function YDWESaveMultiboardItemByString takes string pTable,string pKey,multiboarditem mt returns nothing
    call SaveMultiboardItemHandle(YDHT,StringHash(pTable),StringHash(pKey),mt)
endfunction
function YDWEGetMultiboardItemByInteger takes integer pTable,integer pKey returns multiboarditem
    return LoadMultiboardItemHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetMultiboardItemByString takes string pTable,string pKey returns multiboarditem
    return LoadMultiboardItemHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert TextTag
function YDWESaveTextTagByInteger takes integer pTable,integer pKey,texttag tt returns nothing
    call SaveTextTagHandle(YDHT,pTable,pKey,tt)
endfunction
function YDWESaveTextTagByString takes string pTable,string pKey,texttag tt returns nothing
    call SaveTextTagHandle(YDHT,StringHash(pTable),StringHash(pKey),tt)
endfunction
function YDWEGetTextTagByInteger takes integer pTable,integer pKey returns texttag
    return LoadTextTagHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTextTagByString takes string pTable,string pKey returns texttag
    return LoadTextTagHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Lightning
function YDWESaveLightningByInteger takes integer pTable,integer pKey,lightning ln returns nothing
    call SaveLightningHandle(YDHT,pTable,pKey,ln)
endfunction
function YDWESaveLightningByString takes string pTable,string pKey,lightning ln returns nothing
    call SaveLightningHandle(YDHT,StringHash(pTable),StringHash(pKey),ln)
endfunction
function YDWEGetLightningByInteger takes integer pTable,integer pKey returns lightning
    return LoadLightningHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetLightningByString takes string pTable,string pKey returns lightning
    return LoadLightningHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Region
function YDWESaveRegionByInteger takes integer pTable,integer pKey,region rn returns nothing
    call SaveRegionHandle(YDHT,pTable,pKey,rn)
endfunction
function YDWESaveRegionByString takes string pTable,string pKey,region rt returns nothing
    call SaveRegionHandle(YDHT,StringHash(pTable),StringHash(pKey),rt)
endfunction
function YDWEGetRegionByInteger takes integer pTable,integer pKey returns region
    return LoadRegionHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetRegionByString takes string pTable,string pKey returns region
    return LoadRegionHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Rect
function YDWESaveRectByInteger takes integer pTable,integer pKey,rect rn returns nothing
    call SaveRectHandle(YDHT,pTable,pKey,rn)
endfunction
function YDWESaveRectByString takes string pTable,string pKey,rect rt returns nothing
    call SaveRectHandle(YDHT,StringHash(pTable),StringHash(pKey),rt)
endfunction
function YDWEGetRectByInteger takes integer pTable,integer pKey returns rect
    return LoadRectHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetRectByString takes string pTable,string pKey returns rect
    return LoadRectHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Leaderboard
function YDWESaveLeaderboardByInteger takes integer pTable,integer pKey,leaderboard lb returns nothing
    call SaveLeaderboardHandle(YDHT,pTable,pKey,lb)
endfunction
function YDWESaveLeaderboardByString takes string pTable,string pKey,leaderboard lb returns nothing
    call SaveLeaderboardHandle(YDHT,StringHash(pTable),StringHash(pKey),lb)
endfunction
function YDWEGetLeaderboardByInteger takes integer pTable,integer pKey returns leaderboard
    return LoadLeaderboardHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetLeaderboardByString takes string pTable,string pKey returns leaderboard
    return LoadLeaderboardHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Effect
function YDWESaveEffectByInteger takes integer pTable,integer pKey,effect e returns nothing
    call SaveEffectHandle(YDHT,pTable,pKey,e)
endfunction
function YDWESaveEffectByString takes string pTable,string pKey,effect e returns nothing
    call SaveEffectHandle(YDHT,StringHash(pTable),StringHash(pKey),e)
endfunction
function YDWEGetEffectByInteger takes integer pTable,integer pKey returns effect
    return LoadEffectHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetEffectByString takes string pTable,string pKey returns effect
    return LoadEffectHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Destructable
function YDWESaveDestructableByInteger takes integer pTable,integer pKey,destructable da returns nothing
    call SaveDestructableHandle(YDHT,pTable,pKey,da)
endfunction
function YDWESaveDestructableByString takes string pTable,string pKey,destructable da returns nothing
    call SaveDestructableHandle(YDHT,StringHash(pTable),StringHash(pKey),da)
endfunction
function YDWEGetDestructableByInteger takes integer pTable,integer pKey returns destructable
    return LoadDestructableHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetDestructableByString takes string pTable,string pKey returns destructable
    return LoadDestructableHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert triggercondition
function YDWESaveTriggerConditionByInteger takes integer pTable,integer pKey,triggercondition tc returns nothing
    call SaveTriggerConditionHandle(YDHT,pTable,pKey,tc)
endfunction
function YDWESaveTriggerConditionByString takes string pTable,string pKey,triggercondition tc returns nothing
    call SaveTriggerConditionHandle(YDHT,StringHash(pTable),StringHash(pKey),tc)
endfunction
function YDWEGetTriggerConditionByInteger takes integer pTable,integer pKey returns triggercondition
    return LoadTriggerConditionHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTriggerConditionByString takes string pTable,string pKey returns triggercondition
    return LoadTriggerConditionHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert triggeraction
function YDWESaveTriggerActionByInteger takes integer pTable,integer pKey,triggeraction ta returns nothing
    call SaveTriggerActionHandle(YDHT,pTable,pKey,ta)
endfunction
function YDWESaveTriggerActionByString takes string pTable,string pKey,triggeraction ta returns nothing
    call SaveTriggerActionHandle(YDHT,StringHash(pTable),StringHash(pKey),ta)
endfunction
function YDWEGetTriggerActionByInteger takes integer pTable,integer pKey returns triggeraction
    return LoadTriggerActionHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTriggerActionByString takes string pTable,string pKey returns triggeraction
    return LoadTriggerActionHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert event
function YDWESaveTriggerEventByInteger takes integer pTable,integer pKey,event et returns nothing
    call SaveTriggerEventHandle(YDHT,pTable,pKey,et)
endfunction
function YDWESaveTriggerEventByString takes string pTable,string pKey,event et returns nothing
    call SaveTriggerEventHandle(YDHT,StringHash(pTable),StringHash(pKey),et)
endfunction
function YDWEGetTriggerEventByInteger takes integer pTable,integer pKey returns event
    return LoadTriggerEventHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTriggerEventByString takes string pTable,string pKey returns event
    return LoadTriggerEventHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert force
function YDWESaveForceByInteger takes integer pTable,integer pKey,force fc returns nothing
    call SaveForceHandle(YDHT,pTable,pKey,fc)
endfunction
function YDWESaveForceByString takes string pTable,string pKey,force fc returns nothing
    call SaveForceHandle(YDHT,StringHash(pTable),StringHash(pKey),fc)
endfunction
function YDWEGetForceByInteger takes integer pTable,integer pKey returns force
    return LoadForceHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetForceByString takes string pTable,string pKey returns force
    return LoadForceHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert boolexpr
function YDWESaveBoolexprByInteger takes integer pTable,integer pKey,boolexpr be returns nothing
    call SaveBooleanExprHandle(YDHT,pTable,pKey,be)
endfunction
function YDWESaveBoolexprByString takes string pTable,string pKey,boolexpr be returns nothing
    call SaveBooleanExprHandle(YDHT,StringHash(pTable),StringHash(pKey),be)
endfunction
function YDWEGetBoolexprByInteger takes integer pTable,integer pKey returns boolexpr
    return LoadBooleanExprHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetBoolexprByString takes string pTable,string pKey returns boolexpr
    return LoadBooleanExprHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert sound
function YDWESaveSoundByInteger takes integer pTable,integer pKey,sound sd returns nothing
    call SaveSoundHandle(YDHT,pTable,pKey,sd)
endfunction
function YDWESaveSoundByString takes string pTable,string pKey,sound sd returns nothing
    call SaveSoundHandle(YDHT,StringHash(pTable),StringHash(pKey),sd)
endfunction
function YDWEGetSoundByInteger takes integer pTable,integer pKey returns sound
    return LoadSoundHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetSoundByString takes string pTable,string pKey returns sound
    return LoadSoundHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert timerdialog
function YDWESaveTimerDialogByInteger takes integer pTable,integer pKey,timerdialog td returns nothing
    call SaveTimerDialogHandle(YDHT,pTable,pKey,td)
endfunction
function YDWESaveTimerDialogByString takes string pTable,string pKey,timerdialog td returns nothing
    call SaveTimerDialogHandle(YDHT,StringHash(pTable),StringHash(pKey),td)
endfunction
function YDWEGetTimerDialogByInteger takes integer pTable,integer pKey returns timerdialog
    return LoadTimerDialogHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTimerDialogByString takes string pTable,string pKey returns timerdialog
    return LoadTimerDialogHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert trackable
function YDWESaveTrackableByInteger takes integer pTable,integer pKey,trackable ta returns nothing
    call SaveTrackableHandle(YDHT,pTable,pKey,ta)
endfunction
function YDWESaveTrackableByString takes string pTable,string pKey,trackable ta returns nothing
    call SaveTrackableHandle(YDHT,StringHash(pTable),StringHash(pKey),ta)
endfunction
function YDWEGetTrackableByInteger takes integer pTable,integer pKey returns trackable
    return LoadTrackableHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTrackableByString takes string pTable,string pKey returns trackable
    return LoadTrackableHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert dialog
function YDWESaveDialogByInteger takes integer pTable,integer pKey,dialog d returns nothing
    call SaveDialogHandle(YDHT,pTable,pKey,d)
endfunction
function YDWESaveDialogByString takes string pTable,string pKey,dialog d returns nothing
    call SaveDialogHandle(YDHT,StringHash(pTable),StringHash(pKey),d)
endfunction
function YDWEGetDialogByInteger takes integer pTable,integer pKey returns dialog
    return LoadDialogHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetDialogByString takes string pTable,string pKey returns dialog
    return LoadDialogHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert button
function YDWESaveButtonByInteger takes integer pTable,integer pKey,button bt returns nothing
    call SaveButtonHandle(YDHT,pTable,pKey,bt)
endfunction
function YDWESaveButtonByString takes string pTable,string pKey,button bt returns nothing
    call SaveButtonHandle(YDHT,StringHash(pTable),StringHash(pKey),bt)
endfunction
function YDWEGetButtonByInteger takes integer pTable,integer pKey returns button
    return LoadButtonHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetButtonByString takes string pTable,string pKey returns button
    return LoadButtonHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert quest
function YDWESaveQuestByInteger takes integer pTable,integer pKey,quest qt returns nothing
    call SaveQuestHandle(YDHT,pTable,pKey,qt)
endfunction
function YDWESaveQuestByString takes string pTable,string pKey,quest qt returns nothing
    call SaveQuestHandle(YDHT,StringHash(pTable),StringHash(pKey),qt)
endfunction
function YDWEGetQuestByInteger takes integer pTable,integer pKey returns quest
    return LoadQuestHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetQuestByString takes string pTable,string pKey returns quest
    return LoadQuestHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert questitem
function YDWESaveQuestItemByInteger takes integer pTable,integer pKey,questitem qi returns nothing
    call SaveQuestItemHandle(YDHT,pTable,pKey,qi)
endfunction
function YDWESaveQuestItemByString takes string pTable,string pKey,questitem qi returns nothing
    call SaveQuestItemHandle(YDHT,StringHash(pTable),StringHash(pKey),qi)
endfunction
function YDWEGetQuestItemByInteger takes integer pTable,integer pKey returns questitem
    return LoadQuestItemHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetQuestItemByString takes string pTable,string pKey returns questitem
    return LoadQuestItemHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
function YDWES2I takes string s returns integer
    return StringHash(s)
endfunction
function YDWESaveAbilityHandleBJ takes integer AbilityID, integer key, integer missionKey, hashtable table returns nothing
    call SaveInteger(table,missionKey,key,AbilityID)
endfunction
function YDWESaveAbilityHandle takes hashtable table, integer parentKey, integer childKey, integer AbilityID returns nothing
    call SaveInteger(table,parentKey,childKey,AbilityID)
endfunction
function YDWELoadAbilityHandleBJ takes integer key, integer missionKey, hashtable table returns integer
    return LoadInteger(table,missionKey,key)
endfunction
function YDWELoadAbilityHandle takes hashtable table, integer parentKey, integer childKey returns integer
    return LoadInteger(table,parentKey,childKey)
endfunction
//===========================================================================
//杩斿洖鍙傛暟
//===========================================================================
//鍦板浘杈圭晫鍒ゆ柇
function YDWECoordinateX takes real x returns real
    return RMinBJ(RMaxBJ(x, yd_MapMinX), yd_MapMaxX)
endfunction
function YDWECoordinateY takes real y returns real
    return RMinBJ(RMaxBJ(y, yd_MapMinY), yd_MapMaxY)
endfunction
//涓や釜鍗曚綅涔嬮棿鐨勮窛绂?
function YDWEDistanceBetweenUnits takes unit a,unit b returns real
    return SquareRoot((GetUnitX(a)-GetUnitX(b))*(GetUnitX(a)-GetUnitX(b))+(GetUnitY(a)-GetUnitY(b))*(GetUnitY(a)-GetUnitY(b)))
endfunction
//涓や釜鍗曚綅涔嬮棿鐨勮搴?
function YDWEAngleBetweenUnits takes unit fromUnit, unit toUnit returns real
    return bj_RADTODEG * Atan2(GetUnitY(toUnit) - GetUnitY(fromUnit), GetUnitX(toUnit) - GetUnitX(fromUnit))
endfunction
//鐢熸垚鍖哄煙
function YDWEGetRect takes real x,real y,real width, real height returns rect
    return Rect( x - width*0.5, y - height*0.5, x + width*0.5, y + height*0.5 )
endfunction
//===========================================================================
//璁剧疆鍗曚綅鍙互椋炶
//===========================================================================
function YDWEFlyEnable takes unit u returns nothing
    call UnitAddAbility(u,'Amrf')
    call UnitRemoveAbility(u,'Amrf')
endfunction
//===========================================================================
//瀛楃绐滀笌ID杞崲
//===========================================================================
function YDWEId2S takes integer value returns string
    local string charMap=bj_AllString
    local string result = ""
    local integer remainingValue = value
    local integer charValue
    local integer byteno
    set byteno = 0
    loop
        set charValue = ModuloInteger(remainingValue, 256)
        set remainingValue = remainingValue / 256
        set result = SubString(charMap, charValue, charValue + 1) + result
        set byteno = byteno + 1
        exitwhen byteno == 4
    endloop
    return result
endfunction
function YDWES2Id takes string targetstr returns integer
    local string originstr=bj_AllString
    local integer strlength=StringLength(targetstr)
    local integer a=0 //鍒嗛儴褰撳墠鏁板瓧
local integer b=0 //褰撳墠澶勭悊瀛?
local integer numx=1 //浣嶆潈
local integer result=0
    loop
    exitwhen b>strlength-1
        set numx=R2I(Pow(256,strlength-1-b))
        set a=1
        loop
            exitwhen a>255
            if SubString(targetstr,b,b+1)==SubString(originstr,a,a+1) then
                set result=result+a*numx
                set a=256
            endif
            set a=a+1
        endloop
        set b=b+1
    endloop
    return result
endfunction
function YDWES2UnitId takes string targetstr returns integer
    return YDWES2Id(targetstr)
endfunction
function YDWES2ItemId takes string targetstr returns integer
    return YDWES2Id(targetstr)
endfunction
function GetLastAbilityCastingUnit takes nothing returns unit
    return bj_lastAbilityCastingUnit
endfunction
function GetLastAbilityTargetUnit takes nothing returns unit
    return bj_lastAbilityTargetUnit
endfunction
function YDWESetMapLimitCoordinate takes real MinX,real MaxX,real MinY,real MaxY returns nothing
    set yd_MapMaxX=MaxX
    set yd_MapMinX=MinX
    set yd_MapMaxY=MaxY
    set yd_MapMinY=MinY
endfunction
//===========================================================================
//===========================================================================
//鍦板浘鍒濆鍖?
//===========================================================================
//YDWE鐗规畩鎶€鑳界粨鏉熶簨浠?
function YDWESyStemAbilityCastingOverTriggerAction takes unit hero, integer index returns nothing
	local integer i = 0
    loop
        exitwhen i >= YDWEBase__AbilityCastingOverEventNumber
        if YDWEBase__AbilityCastingOverEventType[i] == index then
            set bj_lastAbilityCastingUnit = hero 
			if YDWEBase__AbilityCastingOverEventQueue[i] != null and TriggerEvaluate(YDWEBase__AbilityCastingOverEventQueue[i]) and IsTriggerEnabled(YDWEBase__AbilityCastingOverEventQueue[i]) then
				call TriggerExecute(YDWEBase__AbilityCastingOverEventQueue[i])
			endif
		endif
        set i = i + 1 
    endloop
endfunction
//===========================================================================  
//YDWE鎶€鑳芥崟鎹変簨浠?
//===========================================================================  
function YDWESyStemAbilityCastingOverRegistTrigger takes trigger trg,integer index returns nothing 
	set YDWEBase__AbilityCastingOverEventQueue[YDWEBase__AbilityCastingOverEventNumber] = trg
	set YDWEBase__AbilityCastingOverEventType[YDWEBase__AbilityCastingOverEventNumber] = index
	set YDWEBase__AbilityCastingOverEventNumber = YDWEBase__AbilityCastingOverEventNumber + 1 
endfunction 
//===========================================================================
//绯荤粺鍑芥暟瀹屽杽
//===========================================================================
function YDWECreateUnitPool takes nothing returns nothing
    set bj_lastCreatedUnitPool=CreateUnitPool()
endfunction
function YDWEPlaceRandomUnit takes unitpool up,player p,real x,real y,real face returns nothing //unitpool,player,real,real,real
set bj_lastPoolAbstractedUnit=PlaceRandomUnit(up,p,x,y,face)
endfunction
function YDWEGetLastUnitPool takes nothing returns unitpool
    return bj_lastCreatedUnitPool
endfunction
function YDWEGetLastPoolAbstractedUnit takes nothing returns unit
    return bj_lastPoolAbstractedUnit
endfunction
function YDWECreateItemPool takes nothing returns nothing
    set bj_lastCreatedItemPool=CreateItemPool()
endfunction
function YDWEPlaceRandomItem takes itempool ip,real x,real y returns nothing //unitpool,player,real,real,real
set bj_lastPoolAbstractedItem=PlaceRandomItem(ip,x,y)
endfunction
function YDWEGetLastItemPool takes nothing returns itempool
    return bj_lastCreatedItemPool
endfunction
function YDWEGetLastPoolAbstractedItem takes nothing returns item
    return bj_lastPoolAbstractedItem
endfunction
function YDWESetAttackDamageWeaponType takes attacktype at,damagetype dt,weapontype wt returns nothing
    set bj_lastSetAttackType=at
    set bj_lastSetDamageType=dt
    set bj_lastSetWeaponType=wt
endfunction
//unitpool bj_lastCreatedPool=null
//unit bj_lastPoolAbstractedUnit=null
function YDWEGetPlayerColorString takes player p, string s returns string
    return YDWEBase__yd_PlayerColor[GetHandleId(GetPlayerColor(p))] + s + "|r"
endfunction
//===========================================================================
//===========================================================================
//绯荤粺鍑芥暟琛ュ厖
//===========================================================================
//===========================================================================
function YDWEGetUnitItemSoftId takes unit hero,item it returns integer
    local integer i = 0
    loop
         exitwhen i > 5
         if UnitItemInSlot(hero, i) == it then
            return i + 1
         endif
         set i = i + 1
    endloop
    return 0
endfunction
//===========================================================================
//===========================================================================
//鍦板浘鍒濆鍖?
//===========================================================================
//===========================================================================
//鏄剧ず鐗堟湰
function YDWEVersion_Display takes nothing returns boolean
    call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 30,"|cFF1E90FF褰撳墠缂栬緫鍣ㄧ増鏈负锛?|r|cFF00FF00YDWE " + "1.26.9.617")
    return false
endfunction
function YDWEVersion_Init takes nothing returns nothing
    local trigger t = CreateTrigger()
    local integer i = 0
    loop
        exitwhen i == 12
        call TriggerRegisterPlayerChatEvent(t, Player(i), "YDWE Version", true)
        set i = i + 1
    endloop
    call TriggerAddCondition(t, Condition(function YDWEVersion_Display))
    set t = null
endfunction
function InitializeYD takes nothing returns nothing
	//=================璁剧疆鍙橀噺=====================
	set yd_MapMinX = GetCameraBoundMinX() - GetCameraMargin(CAMERA_MARGIN_LEFT)
	set yd_MapMinY = GetCameraBoundMinY() - GetCameraMargin(CAMERA_MARGIN_BOTTOM)
	set yd_MapMaxX = GetCameraBoundMaxX() + GetCameraMargin(CAMERA_MARGIN_RIGHT)
	set yd_MapMaxY = GetCameraBoundMaxY() + GetCameraMargin(CAMERA_MARGIN_TOP)
	
    set YDWEBase__yd_PlayerColor [0] = "|cFFFF0303"
    set YDWEBase__yd_PlayerColor [1] = "|cFF0042FF"
    set YDWEBase__yd_PlayerColor [2] = "|cFF1CE6B9"
    set YDWEBase__yd_PlayerColor [3] = "|cFF540081"
    set YDWEBase__yd_PlayerColor [4] = "|cFFFFFC01"
    set YDWEBase__yd_PlayerColor [5] = "|cFFFE8A0E"
    set YDWEBase__yd_PlayerColor [6] = "|cFF20C000"
    set YDWEBase__yd_PlayerColor [7] = "|cFFE55BB0"
    set YDWEBase__yd_PlayerColor [8] = "|cFF959697"
    set YDWEBase__yd_PlayerColor [9] = "|cFF7EBFF1"
    set YDWEBase__yd_PlayerColor[10] = "|cFF106246"
    set YDWEBase__yd_PlayerColor[11] = "|cFF4E2A04"
    set YDWEBase__yd_PlayerColor[12] = "|cFF282828"
    set YDWEBase__yd_PlayerColor[13] = "|cFF282828"
    set YDWEBase__yd_PlayerColor[14] = "|cFF282828"
    set YDWEBase__yd_PlayerColor[15] = "|cFF282828"
    //=================鏄剧ず鐗堟湰=====================
    call YDWEVersion_Init()
endfunction

//library YDWEBase ends
//library YDWEPlaySoundNull:
function YDWEPlaySoundNull takes string soundName returns nothing
    local sound soundHandle = CreateSound(soundName, false, false, true, 12700, 12700, "")
    call StartSound(soundHandle)
    call KillSoundWhenDone(soundHandle)
    set soundHandle = null
endfunction

//library YDWEPlaySoundNull ends
//library YDWEPolledWaitNull:
function YDWEPolledWaitNull takes real duration returns nothing
    local timer t
    local real timeRemaining
    if (duration > 0) then
        set t = CreateTimer()
        call TimerStart(t, duration, false, null)
        loop
            set timeRemaining = TimerGetRemaining(t)
            exitwhen timeRemaining <= 0
            // If we have a bit of time left, skip past 10% of the remaining
            // duration instead of checking every interval, to minimize the
            // polling on long waits.
            if (timeRemaining > bj_POLLED_WAIT_SKIP_THRESHOLD) then
                call TriggerSleepAction(0.1 * timeRemaining)
            else
                call TriggerSleepAction(bj_POLLED_WAIT_INTERVAL)
            endif
        endloop
        call DestroyTimer(t)
    endif
    set t = null
endfunction

//library YDWEPolledWaitNull ends
//library YDWETriggerEvent:
	
//===========================================================================  
//任意单位伤害事件 
//===========================================================================
function YDWEAnyUnitDamagedTriggerAction takes nothing returns nothing
    local integer i = 0
    
    loop
        exitwhen i >= YDWETriggerEvent__DamageEventNumber
        if YDWETriggerEvent__DamageEventQueue[i] != null and IsTriggerEnabled(YDWETriggerEvent__DamageEventQueue[i]) and TriggerEvaluate(YDWETriggerEvent__DamageEventQueue[i]) then
            call TriggerExecute(YDWETriggerEvent__DamageEventQueue[i])
        endif
        set i = i + 1 
    endloop 
endfunction
function YDWEAnyUnitDamagedFilter takes nothing returns boolean 
    if GetUnitAbilityLevel(GetFilterUnit(), 'Aloc') <= 0 then 
        call TriggerRegisterUnitEvent(yd_DamageEventTrigger, GetFilterUnit(), EVENT_UNIT_DAMAGED)
    endif
    return false
endfunction
function YDWEAnyUnitDamagedEnumUnit takes nothing returns nothing 
    local trigger t = CreateTrigger()
    local region r = CreateRegion()
    local group g = CreateGroup()
    call RegionAddRect(r, GetWorldBounds())
    call TriggerRegisterEnterRegion(t, r, Condition(function YDWEAnyUnitDamagedFilter))
    call GroupEnumUnitsInRect(g, GetWorldBounds(), Condition(function YDWEAnyUnitDamagedFilter))
    call DestroyGroup(g)
    set r = null
    set t = null
    set g = null
endfunction
	
function YDWESyStemAnyUnitDamagedRegistTrigger takes trigger trg returns nothing
    if trg == null then
        return
    endif
        
    if YDWETriggerEvent__DamageEventNumber == 0 then
        set yd_DamageEventTrigger = CreateTrigger()
        call TriggerAddAction(yd_DamageEventTrigger, function YDWEAnyUnitDamagedTriggerAction) 
        call YDWEAnyUnitDamagedEnumUnit()
    endif 
    
    set YDWETriggerEvent__DamageEventQueue[YDWETriggerEvent__DamageEventNumber] = trg
    set YDWETriggerEvent__DamageEventNumber = YDWETriggerEvent__DamageEventNumber + 1
endfunction
//===========================================================================  
//移动物品事件 
//===========================================================================  
function YDWESyStemItemUnmovableTriggerAction takes nothing returns nothing
    local integer i = 0
    
    if GetIssuedOrderId() >= 852002 and GetIssuedOrderId() <= 852007 then 
		set bj_lastMovedItemInItemSlot = GetOrderTargetItem() 
    	loop
        	exitwhen i >= YDWETriggerEvent__MoveItemEventNumber
        	if YDWETriggerEvent__MoveItemEventQueue[i] != null and IsTriggerEnabled(YDWETriggerEvent__MoveItemEventQueue[i]) and TriggerEvaluate(YDWETriggerEvent__MoveItemEventQueue[i]) then
        	    call TriggerExecute(YDWETriggerEvent__MoveItemEventQueue[i])
        	endif
        	set i = i + 1 
    	endloop 
	endif	
endfunction
function YDWESyStemItemUnmovableRegistTrigger takes trigger trg returns nothing
    if trg == null then
        return
    endif
        
    if YDWETriggerEvent__MoveItemEventNumber == 0 then
        set YDWETriggerEvent__MoveItemEventTrigger = CreateTrigger()
        call TriggerAddAction(YDWETriggerEvent__MoveItemEventTrigger, function YDWESyStemItemUnmovableTriggerAction) 
        call TriggerRegisterAnyUnitEventBJ(YDWETriggerEvent__MoveItemEventTrigger, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    endif 
    
    set YDWETriggerEvent__MoveItemEventQueue[YDWETriggerEvent__MoveItemEventNumber] = trg
    set YDWETriggerEvent__MoveItemEventNumber = YDWETriggerEvent__MoveItemEventNumber + 1
endfunction
function GetLastMovedItemInItemSlot takes nothing returns item
    return bj_lastMovedItemInItemSlot
endfunction

//library YDWETriggerEvent ends
//library YDWETriggerRegisterEnterRectSimpleNull:
function YDWETriggerRegisterEnterRectSimpleNull takes trigger trig, rect r returns event
    local region rectRegion = CreateRegion()
    call RegionAddRect(rectRegion, r)
    set yd_NullTempRegion = rectRegion
    set rectRegion = null
    return TriggerRegisterEnterRegion(trig, yd_NullTempRegion, null)
endfunction

//library YDWETriggerRegisterEnterRectSimpleNull ends
//library YDWETriggerRegisterLeaveRectSimpleNull:
function YDWETriggerRegisterLeaveRectSimpleNull takes trigger trig, rect r returns event
    local region rectRegion = CreateRegion()
    call RegionAddRect(rectRegion, r)
    set yd_NullTempRegion = rectRegion
    set rectRegion = null
    return TriggerRegisterLeaveRegion(trig, yd_NullTempRegion, null)
endfunction

//library YDWETriggerRegisterLeaveRectSimpleNull ends
//library AutoIndex:
    module AutoData
        private static thistype array data
        
        // Fixed up the below to use thsitype instead of integer.
        static method operator []= takes unit u, thistype i returns nothing
            set .data[GetUnitId(u)] = i //Just attaching a struct to the unit
endmethod //using the module's thistype array.

        static method operator [] takes unit u returns thistype
            return .data[GetUnitId(u)] //Just returning the attached struct.
endmethod
    endmodule

//library AutoIndex ends
//library Constants:
function GetGrenadeVector takes real ux, real uy, real tx, real ty returns vector
    local vector v = vector.create(tx - ux, ty - uy, 0)
    set v.z = v.getLength() * 2
    return v
endfunction
function GetGrenadeTrajectory takes real ux, real uy, real tx, real ty returns real
    local real d = SquareRoot(Pow(ty-uy,2)+Pow(tx-ux,2))
    local real v = SquareRoot(d*g/Sin(2*GRENADEDEG)) / 2.25
    return v
endfunction
function InitConstants takes nothing returns nothing
endfunction

//library Constants ends
//library Damage:
    //============================================================
    ////! external ObjectMerger w3a AIlz dprv anam "Life Bonus" ansf "(Damage System)" Ilif 1 500000 aite 0
    
    //============================================================
    
    function Damage_RegisterEvent takes trigger whichTrigger returns nothing
        call Damage__OnDamageEvent.register(whichTrigger)
    endfunction
    
    function Damage_EnableEvent takes boolean enable returns nothing
        set Damage__EventEnabled=enable
    endfunction
    
    //============================================================
    
    function Damage_GetType takes nothing returns damagetype
        return Damage__TypeStackValue[Damage__TypeStackLevel]
    endfunction
    
    function Damage_Block takes real amount returns nothing
        set Damage__ToBlock[Damage__TypeStackLevel]=Damage__ToBlock[Damage__TypeStackLevel]+amount
    endfunction
    
    function Damage_BlockAll takes nothing returns nothing
        set Damage__ToBlock[Damage__TypeStackLevel]=Damage__ToBlock[Damage__TypeStackLevel]+GetEventDamage()
    endfunction
    
    //============================================================
    
    //============================================================
    
    function Damage__RemoveBoostedTimerFunc takes nothing returns nothing
        loop
            exitwhen Damage__RemoveBoostedMax==0
            set Damage__BoostedLifeUnit=Damage__RemoveBoosted[Damage__RemoveBoostedMax]
            set Damage__BoostedLifeTemp=GetWidgetLife(Damage__BoostedLifeUnit)
            call UnitRemoveAbility(Damage__BoostedLifeUnit,Damage__LIFE_BONUS_ABIL)
            if Damage__BoostedLifeTemp>0.405 then
                call SetWidgetLife(Damage__BoostedLifeUnit,Damage__BoostedLifeTemp)
            endif
            set Damage__RemoveBoostedMax=Damage__RemoveBoostedMax-1
        endloop
    endfunction
    
    //============================================================
    function Damage__OnDamageActions takes nothing returns boolean
        if Damage__EventEnabled then
            call Damage__OnDamageEvent.fire()
        endif
        if Damage__ToBlock[Damage__TypeStackLevel]!=0. then
            //====================================================
            // Blocking
            set Damage__ForUnit=GetTriggerUnit()
            
            set Damage__NextHealth=GetEventDamage()
            if Damage__ToBlock[Damage__TypeStackLevel]>=Damage__NextHealth then
                set Damage__NextHealth=GetWidgetLife(Damage__ForUnit)+Damage__NextHealth
            else
                set Damage__NextHealth=GetWidgetLife(Damage__ForUnit)+Damage__ToBlock[Damage__TypeStackLevel]
            endif
            
            call SetWidgetLife(Damage__ForUnit,Damage__NextHealth)
            if GetWidgetLife(Damage__ForUnit)<Damage__NextHealth then
                // NextHealth is over max health.
                call UnitAddAbility(Damage__ForUnit,Damage__LIFE_BONUS_ABIL)
                call SetWidgetLife(Damage__ForUnit,Damage__NextHealth)
                
                set Damage__RemoveBoostedMax=Damage__RemoveBoostedMax+1
                set Damage__RemoveBoosted[Damage__RemoveBoostedMax]=Damage__ForUnit
                call ResumeTimer(Damage__RemoveBoostedTimer)
            endif
            //====================================================
            set Damage__ToBlock[Damage__TypeStackLevel]=0.
        endif
        return false
    endfunction
    
    //============================================================
    function UnitDamageTargetEx takes unit whichUnit, widget target, real amount, boolean attack, boolean ranged, attacktype attackType, damagetype damageType, weapontype weaponType returns boolean
        local boolean result
        set Damage__TypeStackLevel=Damage__TypeStackLevel+1
        set Damage__TypeStackValue[Damage__TypeStackLevel]=damageType
        set result=UnitDamageTarget(whichUnit,target,amount,attack,ranged,attackType,damageType,weaponType)
        set Damage__TypeStackLevel=Damage__TypeStackLevel-1
        return result
    endfunction
    
//textmacro instance: Damage__DealTypeFunc("Pure","DAMAGE_TYPE_UNIVERSAL")
        function Damage_Pure takes unit source, unit target, real amount returns boolean
            return UnitDamageTargetEx(source,target,amount,false,false,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_UNIVERSAL,WEAPON_TYPE_WHOKNOWS)
        endfunction
//end of: Damage__DealTypeFunc("Pure","DAMAGE_TYPE_UNIVERSAL")
//textmacro instance: Damage__DealTypeFunc("Spell","DAMAGE_TYPE_MAGIC")
        function Damage_Spell takes unit source, unit target, real amount returns boolean
            return UnitDamageTargetEx(source,target,amount,false,false,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
        endfunction
//end of: Damage__DealTypeFunc("Spell","DAMAGE_TYPE_MAGIC")
    
    // Uses different stuff, but works much the same way.
    function Damage_Physical takes unit source, unit target, real amount, attacktype whichType, boolean attack, boolean ranged returns boolean
        return UnitDamageTargetEx(source,target,amount,attack,ranged,whichType,DAMAGE_TYPE_NORMAL,WEAPON_TYPE_WHOKNOWS)
    endfunction
    
    //============================================================
    struct Damage__Detector extends array // Uses AIDS.
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()

        private static conditionfunc ACTIONS_COND
        
        private trigger t
        
        private method AIDS_onCreate takes nothing returns nothing
            set this.t=CreateTrigger()
            call TriggerAddCondition(this.t,thistype.ACTIONS_COND)
            call TriggerRegisterUnitEvent(this.t,this.unit,EVENT_UNIT_DAMAGED)
        endmethod
        
        private method AIDS_onDestroy takes nothing returns nothing
            call DestroyTrigger(this.t)
        endmethod
        
        private static method AIDS_onInit takes nothing returns nothing
            set thistype.ACTIONS_COND=Condition(function Damage__OnDamageActions)
        endmethod
    endstruct
    
    //============================================================
    function Damage__OnInit takes nothing returns nothing
        local unit abilpreload=CreateUnit(Player(15),'uloc',0,0,0)
        call UnitAddAbility(abilpreload,Damage__LIFE_BONUS_ABIL)
        call RemoveUnit(abilpreload)
        set abilpreload=null
        
        set Damage__OnDamageEvent=Event.create()
        set Damage__TypeStackValue[Damage__TypeStackLevel]=DAMAGE_TYPE_NORMAL
        call TimerStart(Damage__RemoveBoostedTimer,0.0,false,function Damage__RemoveBoostedTimerFunc)
    endfunction

//library Damage ends
//library Direction:
function unitDir takes unit u1, unit u2 returns real
    local real x1 = GetUnitX(u1)
    local real y1 = GetUnitY(u1)
    local real x2 = GetUnitX(u2)
    local real y2 = GetUnitY(u2)
    return Atan2(y2-y1,x2-x1)
endfunction
function getDir takes real sx,real sy,real tx,real ty returns real
    return Atan2(ty-sy,tx-sx)
endfunction
function getDeg takes real y, real x returns real
    return Rad2Deg(Atan2(y,x))
endfunction
function getFacing takes unit u returns real
    return Deg2Rad(GetUnitFacing(u))
endfunction
function getTargetDir takes unit source, unit target returns real
    local real sx = GetUnitX(source)
    local real sy = GetUnitY(source)
    local real tx = GetUnitX(target)
    local real ty = GetUnitY(target)
    return getDir(sx, sy, tx, ty)
endfunction
function getDirVector takes unit owner, unit target, real speed returns vector
    local real tx = GetUnitX(target)
    local real ty = GetUnitY(target)
    local real tz = getUnitHeight(target)
    local real ux = GetUnitX(owner)
    local real uy = GetUnitY(owner)
    local real uz = getUnitHeight(owner)
    local vector t = vector.create(tx - ux, ty - uy, tz - uz)
    call t.setLength(speed)
    return t
endfunction

//library Direction ends
//library DispatchTechLevel:
function DispatchTechAdd takes integer id, integer lv, integer pid returns nothing
    if id == tKMANA then
        set EquipmentData[heros[pid]].heroData.kill_mana_percent = EquipmentData[heros[pid]].heroData.kill_mana_percent + 0.5
    endif
    if id == tAIM_SHOOT then
        set EquipmentData[heros[pid]].heroData.shoot_rist = EquipmentData[heros[pid]].heroData.shoot_rist + 0.3
    endif
    if id == tSPEED_SHOOT then
        call IncShootSpeed(pid)
        call IncShootSpeed(pid)
        call IncShootSpeed(pid)
        //set EquipmentData[heros[pid]].heroData.shoot_speed_buff = EquipmentData[heros[pid]].heroData.shoot_speed_buff + 0.3
        set EquipmentData[heros[pid]].heroData.shoot_rist = EquipmentData[heros[pid]].heroData.shoot_rist - 0.1
    endif
    if id == tSAVE then
        set EquipmentData[heros[pid]].heroData.save = EquipmentData[heros[pid]].heroData.save + 0.4
    endif
    if id == tSTRONG then
        set EquipmentData[heros[pid]].heroData.strong = EquipmentData[heros[pid]].heroData.strong + 0.2
    endif
    if id == tANTRAD then
        set EquipmentData[heros[pid]].heroData.antrad = EquipmentData[heros[pid]].heroData.antrad + 0.3
    endif
    if id == tDOGE then
        set EquipmentData[heros[pid]].heroData.doge = EquipmentData[heros[pid]].heroData.doge + 0.2
    endif
    if id == tFREZZ then
        set EquipmentData[heros[pid]].heroData.frezz = EquipmentData[heros[pid]].heroData.frezz + 0.05
    endif
    if id == tMANA_BOOM then
        set EquipmentData[heros[pid]].heroData.mana_boom_percent = EquipmentData[heros[pid]].heroData.mana_boom_percent + 0.3
    endif
endfunction
function DispatchTechLevelUp takes integer id, integer lv, integer pid returns nothing
    if id == tKMANA then
        set EquipmentData[heros[pid]].heroData.kill_mana_percent = EquipmentData[heros[pid]].heroData.kill_mana_percent + 0.05
    endif
    if id == tAIM_SHOOT then
        set EquipmentData[heros[pid]].heroData.shoot_rist = EquipmentData[heros[pid]].heroData.shoot_rist + 0.025
    endif
    if id == tSPEED_SHOOT then
        call IncShootSpeed(pid)
        //set EquipmentData[heros[pid]].heroData.shoot_speed_buff = EquipmentData[heros[pid]].heroData.shoot_speed_buff + 0.1
        set EquipmentData[heros[pid]].heroData.shoot_rist = EquipmentData[heros[pid]].heroData.shoot_rist - 0.05
    endif
    if id == tSAVE then
        set EquipmentData[heros[pid]].heroData.save = EquipmentData[heros[pid]].heroData.save + 0.05
    endif
    if id == tSTRONG then
        set EquipmentData[heros[pid]].heroData.strong = EquipmentData[heros[pid]].heroData.strong + 0.02
    endif
    if id == tANTRAD then
        set EquipmentData[heros[pid]].heroData.antrad = EquipmentData[heros[pid]].heroData.antrad + 0.05
    endif
    if id == tDOGE then
        set EquipmentData[heros[pid]].heroData.doge = EquipmentData[heros[pid]].heroData.doge + 0.01
    endif
    if id == tFREZZ then
        set EquipmentData[heros[pid]].heroData.frezz = EquipmentData[heros[pid]].heroData.frezz + 0.01
    endif
    if id == tMANA_BOOM then
        set EquipmentData[heros[pid]].heroData.mana_boom_percent = EquipmentData[heros[pid]].heroData.mana_boom_percent + 0.15
    endif
endfunction

//library DispatchTechLevel ends
//library DoublePacket:
function InitDoublePacket takes nothing returns nothing
    set kpacau=GetNewKey()
endfunction
//涓や釜鍗曚綅浜ゆ崲鐗╁搧
function ItemSwitch takes unit Ua,unit Ub returns nothing 
      local item array Ia 
      local item array Ib 
      local item array Ic 
      local integer i = 0 
      local integer n = 0 
      loop 
            exitwhen i >5 
            if UnitItemInSlot(Ua, i) != null then 
                  set Ia[i]= UnitItemInSlot(Ua, i) 
                  call UnitRemoveItemFromSlot(Ua,i) 
            endif 
            if UnitItemInSlot(Ub, i) != null then 
                  set Ib[i]= UnitItemInSlot(Ub, i) 
                  call UnitRemoveItemFromSlot(Ub,i) 
            endif 
            set i = i+1 
      endloop 
      set i = 0 
      loop 
            exitwhen i >5 
            if Ia[i] == null then 
               call UnitAddItem(Ub,CreateItem('mort',GetUnitX(Ub),GetUnitY(Ub))) 
               set Ic[n] = UnitItemInSlot(Ub, i) 
               set n=n+1 
               else 
               call UnitAddItem(Ub,Ia[i]) 
            endif 
            set i = i+1 
      endloop 
      set i = 0 
      loop 
            set i = i+1 
            exitwhen i >n 
            call RemoveItem(Ic[i]) 
            set Ic[i]=null 
      endloop 
//缁橝鐨勭墿鍝?     
      set i = 0 
      loop 
            exitwhen i >5 
            if Ib[i] == null then 
               call UnitAddItem(Ua,CreateItem('mort',GetUnitX(Ua),GetUnitY(Ua))) 
               set Ic[n]=UnitItemInSlot(Ua, i) 
               set n=n+1 
               else 
               call UnitAddItem(Ua,Ib[i]) 
            endif 
            set i = i+1 
      endloop 
      set i = 0 
      loop 
            exitwhen i >n 
            call RemoveItem(Ic[i]) 
            set Ic[i]=null 
            set i = i+1 
      endloop 
      set i = 0 
      loop 
            exitwhen i >5 
            set Ia[i]=null 
            set Ib[i]=null 
            set i = i+1 
      endloop 
endfunction
//瑕嗙洊A鐨勭墿鍝佺粰B
function ItemCopy takes unit ua, unit ub returns nothing
    local integer i
    set i=0
    loop
        exitwhen i>5
        call RemoveItem(UnitItemInSlot(ub,i))
        set i=i+1
    endloop
    set i=0
    loop
        exitwhen i>5
        call UnitAddItem(ub,CreateItem(GetItemTypeId(UnitItemInSlot(ua,i)),0,0))
        set i=i+1
    endloop
endfunction
//鍒囨崲鑳屽寘
function SwapPackageCA takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local integer dec=GetHandleId(u)
    if GetSpellAbilityId()==gpacspl then
        call ItemSwitch(u,LoadUnitHandle(ht,dec,kpacau))
    endif
    set u=null
endfunction
//涓鸿嫳闆勭殑褰撳墠鐗╁搧鏍忔敞鍐屽弻6鑳屽寘
function RegisterDouble6Package takes unit u returns nothing
    local integer dec=GetHandleId(u)
    local integer i
    local trigger trg
    local unit tu
    if LoadUnitHandle(ht,dec,kpacau) == null then
        set tu=CreateUnit(GetOwningPlayer(u),gpacauid,0,0,0)
        call SaveUnitHandle(ht,dec,kpacau,tu)
        set trg=CreateTrigger()
        call TriggerRegisterUnitEvent( trg, u, EVENT_UNIT_SPELL_EFFECT )
        call TriggerAddCondition(trg,function SwapPackageCA)
    endif
    set trg=null
    set tu=null
endfunction

//library DoublePacket ends
//library GroupUtils:
//******************************************************************************
//* BY: Rising_Dusk
//* 
//* This library is a simple implementation of a stack for groups that need to
//* be in the user's control for greater than an instant of time. Additionally,
//* this library provides a single, global group variable for use with user-end
//* enumerations. It is important to note that users should not be calling
//* DestroyGroup() on the global group, since then it may not exist for when it
//* it is next needed.
//*
//* The group stack removes the need for destroying groups and replaces it with
//* a recycling method.
//*     function NewGroup takes nothing returns group
//*     function ReleaseGroup takes group g returns boolean
//*     function GroupRefresh takes group g returns nothing
//* 
//* NewGroup grabs a currently unused group from the stack or creates one if the
//* stack is empty. You can use this group however you'd like, but always
//* remember to call ReleaseGroup on it when you are done with it. If you don't
//* release it, it will 'leak' and your stack may eventually overflow if you
//* keep doing that.
//* 
//* GroupRefresh cleans a group of any shadow references which may be clogging
//* its hash table. If you remove a unit from the game who is a member of a unit
//* group, it will 'effectively' remove the unit from the group, but leave a
//* shadow in its place. Calling GroupRefresh on a group will clean up any
//* shadow references that may exist within it.
//******************************************************************************
    function GroupUtils__AddEx takes nothing returns nothing
        if GroupUtils__Flag then
            call GroupClear(GroupUtils__Refr)
            set GroupUtils__Flag = false
        endif
        call GroupAddUnit(GroupUtils__Refr, GetEnumUnit())
    endfunction
    
    function GroupRefresh takes group g returns nothing
        set GroupUtils__Flag = true
        set GroupUtils__Refr = g
        call ForGroup(GroupUtils__Refr, function GroupUtils__AddEx)
        if GroupUtils__Flag then
            call GroupClear(g)
        endif
    endfunction
    function NewGroup takes nothing returns group
        if GroupUtils__Count == 0 then
            set GroupUtils__Groups[0] = CreateGroup()
        else
            set GroupUtils__Count = GroupUtils__Count - 1
        endif
        set GroupUtils__Status[GetHandleId(GroupUtils__Groups[GroupUtils__Count])-GroupUtils__MIN_HANDLE_ID] = 1
        return GroupUtils__Groups[GroupUtils__Count]
    endfunction
    function ReleaseGroup takes group g returns boolean
        local integer stat = GroupUtils__Status[GetHandleId(g)-GroupUtils__MIN_HANDLE_ID]
        if g == null then
            return false
        elseif stat == 0 then
            return false
        elseif stat == 2 then
            return false
        elseif GroupUtils__Count == 8191 then
            call DestroyGroup(g)
            return false
        else
            call GroupClear(g)
            set GroupUtils__Groups[GroupUtils__Count] = g
            set GroupUtils__Count = GroupUtils__Count + 1
            set GroupUtils__Status[GetHandleId(g)-GroupUtils__MIN_HANDLE_ID] = 2
        endif
        return true
    endfunction
    

//library GroupUtils ends
//library Gun:
interface IGun
    IShooter shooter
    IMissleFactory factory
    ItemFeatureData ifd
    method fire takes nothing returns nothing
    method stopFire takes nothing returns nothing
    method getGunType takes nothing returns integer
    method setOwner takes unit owner returns nothing
endinterface
struct DefaultGun extends IGun
    method fire takes nothing returns nothing
        if shooter.owner != null then
            call shooter.shoot(vector.create(0,0,0))
        endif
    endmethod
    
    method setOwner takes unit owner returns nothing
        set shooter.owner = owner
    endmethod
    
    method stopFire takes nothing returns nothing
    endmethod
    
    method getGunType takes nothing returns integer
        return SHOOT_GUN
    endmethod
    
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local DefaultGun g=DefaultGun.allocate()
        set g.factory=DefaultMissleFactory.create()
        set g.shooter=ShootGunShooter.create(owner,g.factory)
        set g.ifd = ifd
        return g
    endmethod
    
    method onDestroy takes nothing returns nothing
        call shooter.destroy()
        call factory.destroy()
    endmethod
endstruct
//textmacro instance: ExtendGun("FireShotgun","FireMissleFactory","ShootGunShooter")
struct FireShotgun extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local FireShotgun g=FireShotgun.allocate(owner, ifd)
        set g.factory=FireMissleFactory.create()
        set g.shooter=ShootGunShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("FireShotgun","FireMissleFactory","ShootGunShooter")
//textmacro instance: ExtendGun("HumanRifle","DefaultMissleFactory","MachineGunShooter")
struct HumanRifle extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local HumanRifle g=HumanRifle.allocate(owner, ifd)
        set g.factory=DefaultMissleFactory.create()
        set g.shooter=MachineGunShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("HumanRifle","DefaultMissleFactory","MachineGunShooter")
//textmacro instance: ExtendGun("SpearRifle","SpearMissleFactory","MachineGunShooter")
struct SpearRifle extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local SpearRifle g=SpearRifle.allocate(owner, ifd)
        set g.factory=SpearMissleFactory.create()
        set g.shooter=MachineGunShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("SpearRifle","SpearMissleFactory","MachineGunShooter")
//textmacro instance: ExtendGun("IceMachineGun","IceMissleFactory","MachineGunShooter")
struct IceMachineGun extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local IceMachineGun g=IceMachineGun.allocate(owner, ifd)
        set g.factory=IceMissleFactory.create()
        set g.shooter=MachineGunShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("IceMachineGun","IceMissleFactory","MachineGunShooter")
//textmacro instance: ExtendGun("FireMachineGun","FireMissleFactory","MachineGunShooter")
struct FireMachineGun extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local FireMachineGun g=FireMachineGun.allocate(owner, ifd)
        set g.factory=FireMissleFactory.create()
        set g.shooter=MachineGunShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("FireMachineGun","FireMissleFactory","MachineGunShooter")
//textmacro instance: ExtendGun("AutoRifle","DefaultMissleFactory","AutoShooter")
struct AutoRifle extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local AutoRifle g=AutoRifle.allocate(owner, ifd)
        set g.factory=DefaultMissleFactory.create()
        set g.shooter=AutoShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("AutoRifle","DefaultMissleFactory","AutoShooter")

//library Gun ends
//library Heal:
    
    native UnitAlive takes unit id returns boolean
    
    struct HealType extends array
        private static integer Counter = 0
        static method new takes nothing returns thistype
            set thistype.Counter = thistype.Counter + 1
            return thistype.Counter
        endmethod
    endstruct
    
    
    function Heal_RegisterEvent takes trigger trig returns EventReg
        return Heal__HealEvent.register(trig)
    endfunction
    
    function Heal_UnregisterEvent takes trigger trig returns nothing
        call Heal__HealEvent.unregister(trig)
    endfunction
    
    function Heal_EnableEvent takes boolean flag returns nothing
        set Heal__IsEventEnabled = flag
    endfunction
    
    function Heal_GetSource takes nothing returns unit
        return Heal__HealerStack[Heal__StackLevel]
    endfunction
    
    function Heal_GetTarget takes nothing returns unit
        return Heal__TargetStack[Heal__StackLevel]
    endfunction
    
    function Heal_GetAmount takes nothing returns real
        return Heal__HealAmountStack[Heal__StackLevel]
    endfunction
    
    function Heal_Block takes real amount returns nothing
        set Heal__HealBlockStack[Heal__StackLevel] = Heal__HealBlockStack[Heal__StackLevel] + amount
    endfunction
    
    function Heal_BlockAll takes nothing returns nothing
        set Heal__HealBlockStack[Heal__StackLevel] = Heal__HealBlockStack[Heal__StackLevel] + Heal__HealAmountStack[Heal__StackLevel]
    endfunction
    
    function Heal_GetType takes nothing returns HealType
        return Heal__TypeStack[Heal__StackLevel]
    endfunction
    
    function HealUnit takes unit healer, unit target, real amount, HealType htype returns boolean
        local real life
        local real maxlife
        if UnitAlive(healer) == true and UnitAlive(target) == true and amount > 0. then
            set life = GetWidgetLife(target)
            set maxlife = GetUnitState(target,UNIT_STATE_MAX_LIFE)
            call DestroyEffect( AddSpecialEffect(HEAL_EFFECT, GetUnitX(target), GetUnitY(target)) )
            if life == maxlife then
                return false//If target has full hp, no healing is done.
            else
                if life + amount > maxlife then
                    set amount = maxlife - life //if current hp + amount > max hp, set amount to max hp - current hp.
endif
                call SetWidgetLife(target,life + amount)
            endif
            if Heal__IsEventEnabled == true then
                set Heal__StackLevel = Heal__StackLevel + 1
                set Heal__HealerStack[Heal__StackLevel] = healer
                set Heal__TargetStack[Heal__StackLevel] = target
                set Heal__HealAmountStack[Heal__StackLevel] = amount
                set Heal__TypeStack[Heal__StackLevel] = htype
                set Heal__HealBlockStack[Heal__StackLevel] = 0.
                call Heal__HealEvent.fire()
                if Heal__HealBlockStack[Heal__StackLevel] > amount then
                    set Heal__HealBlockStack[Heal__StackLevel] = amount
                endif
                call SetWidgetLife(target,GetWidgetLife(target) - Heal__HealBlockStack[Heal__StackLevel])
                set Heal__StackLevel = Heal__StackLevel - 1
            endif
            return true
        endif
        return false
    endfunction
    
    function Heal__Init takes nothing returns nothing
        set Heal__HealEvent = Event.create()
        
        set HEAL_TYPE_NORMAL = HealType.new()
    endfunction

//library Heal ends
//library ItemData:
struct ItemFeature
    string name
    real origin
    real step
    integer lv 
    integer maxlv
    integer gold
    integer wood
    string desc
    static method create takes string name, real origin, real step, integer lv, integer maxlv, integer gold, integer wood returns ItemFeature
        local ItemFeature m=ItemFeature.allocate()
        set m.name = name
        set m.origin =origin
        set m.step = step
        set m.lv = lv
        set m.maxlv = maxlv
        set m.gold = gold
        set m.wood = wood
        return m
    endmethod
    method setDesc takes string s returns nothing
        set desc = s
    endmethod
    method getValue takes nothing returns real
        return origin + step * lv
    endmethod
endstruct
struct IndividualItemData extends array
    ItemFeatureData featureData
    
    private method AII_onCreate takes nothing returns nothing
        local integer ii = GetItemTypeId(this.item)
        set featureData = ItemFeatureData.construct(ii)
    endmethod
    
    implement AII
endstruct
struct ItemFeatureData
    ItemFeature f1
    ItemFeature f2
    ItemFeature f3
    ItemFeature f4
    ItemFeature f5
    IGun gun
    
    static method create takes ItemFeature f1,ItemFeature f2,ItemFeature f3,ItemFeature f4,ItemFeature f5, IGun gun returns ItemFeatureData
        local ItemFeatureData m=ItemFeatureData.allocate()
        set m.f1 = f1
        set m.f2 = f2
        set m.f3 = f3
        set m.f4 = f4
        set m.f5 = f5
        set m.gun = gun
        return m
    endmethod
    static method construct takes integer did returns ItemFeatureData
        local ItemFeature f1
        local ItemFeature f2
        local ItemFeature f3
        local ItemFeature f4
        local ItemFeature f5
        local integer id = did - 'I000'
        local IGun gun = 0
        local ItemFeatureData ifd = 0
//textmacro instance: CreateItemFeature("1")
    set f1 = ItemFeature.create(LoadStr(ifht1, id, ifht_name),LoadReal(ifht1, id, ifht_origin),LoadReal(ifht1, id, ifht_step),LoadInteger(ifht1, id, ifht_lv),LoadInteger(ifht1, id, ifht_max_lv),LoadInteger(ifht1, id, ifht_gold),LoadInteger(ifht1, id, ifht_wood))
    call f1.setDesc(LoadStr(ifht1, id, ifht_desc))
//end of: CreateItemFeature("1")
//textmacro instance: CreateItemFeature("2")
    set f2 = ItemFeature.create(LoadStr(ifht2, id, ifht_name),LoadReal(ifht2, id, ifht_origin),LoadReal(ifht2, id, ifht_step),LoadInteger(ifht2, id, ifht_lv),LoadInteger(ifht2, id, ifht_max_lv),LoadInteger(ifht2, id, ifht_gold),LoadInteger(ifht2, id, ifht_wood))
    call f2.setDesc(LoadStr(ifht2, id, ifht_desc))
//end of: CreateItemFeature("2")
//textmacro instance: CreateItemFeature("3")
    set f3 = ItemFeature.create(LoadStr(ifht3, id, ifht_name),LoadReal(ifht3, id, ifht_origin),LoadReal(ifht3, id, ifht_step),LoadInteger(ifht3, id, ifht_lv),LoadInteger(ifht3, id, ifht_max_lv),LoadInteger(ifht3, id, ifht_gold),LoadInteger(ifht3, id, ifht_wood))
    call f3.setDesc(LoadStr(ifht3, id, ifht_desc))
//end of: CreateItemFeature("3")
//textmacro instance: CreateItemFeature("4")
    set f4 = ItemFeature.create(LoadStr(ifht4, id, ifht_name),LoadReal(ifht4, id, ifht_origin),LoadReal(ifht4, id, ifht_step),LoadInteger(ifht4, id, ifht_lv),LoadInteger(ifht4, id, ifht_max_lv),LoadInteger(ifht4, id, ifht_gold),LoadInteger(ifht4, id, ifht_wood))
    call f4.setDesc(LoadStr(ifht4, id, ifht_desc))
//end of: CreateItemFeature("4")
//textmacro instance: CreateItemFeature("5")
    set f5 = ItemFeature.create(LoadStr(ifht5, id, ifht_name),LoadReal(ifht5, id, ifht_origin),LoadReal(ifht5, id, ifht_step),LoadInteger(ifht5, id, ifht_lv),LoadInteger(ifht5, id, ifht_max_lv),LoadInteger(ifht5, id, ifht_gold),LoadInteger(ifht5, id, ifht_wood))
    call f5.setDesc(LoadStr(ifht5, id, ifht_desc))
//end of: CreateItemFeature("5")
        set ifd = ItemFeatureData.create(f1,f2,f3,f4,f5,gun)
        if LoadInteger(idht, did-'I000', idht_item_type) == GUN then
            if did == 'I001' then
                set gun = HumanRifle.create(null, ifd)
//textmacro instance: BindGun("'I00R'", "SpearRifle")
            elseif did == 'I00R' then
                set gun = SpearRifle.create(null, ifd)
//end of: BindGun("'I00R'", "SpearRifle")
//textmacro instance: BindGun("'I00S'", "FireShotgun")
            elseif did == 'I00S' then
                set gun = FireShotgun.create(null, ifd)
//end of: BindGun("'I00S'", "FireShotgun")
            endif
        endif
        set ifd.gun = gun
        return ifd
    endmethod
endstruct
struct ItemTypeData
    string name
    integer spell
    integer s1
    integer s2
    integer s3
    integer itemType
    
    static method create takes string name, integer spell, integer s1, integer s2, integer s3, integer itemType returns ItemTypeData
        local ItemTypeData m=ItemTypeData.allocate()
        set m.name=name
        set m.spell=spell
        set m.s1=s1
        set m.s2=s2
        set m.s3=s3
        set m.itemType=itemType
        return m
    endmethod 
endstruct
function InitItemData takes nothing returns nothing
    call FlushParentHashtable( idht )
    set idht = InitHashtable()
//textmacro instance: DefineIfht("1")
    call FlushParentHashtable( ifht1 )
    set ifht1 = InitHashtable()
//end of: DefineIfht("1")
//textmacro instance: DefineIfht("2")
    call FlushParentHashtable( ifht2 )
    set ifht2 = InitHashtable()
//end of: DefineIfht("2")
//textmacro instance: DefineIfht("3")
    call FlushParentHashtable( ifht3 )
    set ifht3 = InitHashtable()
//end of: DefineIfht("3")
//textmacro instance: DefineIfht("4")
    call FlushParentHashtable( ifht4 )
    set ifht4 = InitHashtable()
//end of: DefineIfht("4")
//textmacro instance: DefineIfht("5")
    call FlushParentHashtable( ifht5 )
    set ifht5 = InitHashtable()
//end of: DefineIfht("5")
//textmacro instance: InitWeaponTypeData("iJUMP", "寮瑰皠闉?, "'A00A'", "'A00B'","0","0","SHOE")
    call SaveStr(idht,iJUMP - 'I000',idht_name,"寮瑰皠闉?)
    call SaveInteger(idht,iJUMP - 'I000',idht_spell,'A00A')
    call SaveInteger(idht,iJUMP - 'I000',idht_s1,'A00B')
    call SaveInteger(idht,iJUMP - 'I000',idht_s2,0)
    call SaveInteger(idht,iJUMP - 'I000',idht_s3,0)
    call SaveInteger(idht,iJUMP - 'I000',idht_item_type,SHOE)
//end of: InitWeaponTypeData("iJUMP", "寮瑰皠闉?, "'A00A'", "'A00B'","0","0","SHOE")
//textmacro instance: InitWeaponTypeData("iRETURN", "鍥炴棆闀?, "aRETURN", "0","0","0","I_D")
    call SaveStr(idht,iRETURN - 'I000',idht_name,"鍥炴棆闀?)
    call SaveInteger(idht,iRETURN - 'I000',idht_spell,aRETURN)
    call SaveInteger(idht,iRETURN - 'I000',idht_s1,0)
    call SaveInteger(idht,iRETURN - 'I000',idht_s2,0)
    call SaveInteger(idht,iRETURN - 'I000',idht_s3,0)
    call SaveInteger(idht,iRETURN - 'I000',idht_item_type,I_D)
//end of: InitWeaponTypeData("iRETURN", "鍥炴棆闀?, "aRETURN", "0","0","0","I_D")
//textmacro instance: InitWeaponTypeData("iREACT", "灏勫嚮鍙嶄綔鐢ㄥ姏澧炲己瑁呯疆", "aREACT", "0","0","0","OTHER")
    call SaveStr(idht,iREACT - 'I000',idht_name,"灏勫嚮鍙嶄綔鐢ㄥ姏澧炲己瑁呯疆")
    call SaveInteger(idht,iREACT - 'I000',idht_spell,aREACT)
    call SaveInteger(idht,iREACT - 'I000',idht_s1,0)
    call SaveInteger(idht,iREACT - 'I000',idht_s2,0)
    call SaveInteger(idht,iREACT - 'I000',idht_s3,0)
    call SaveInteger(idht,iREACT - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iREACT", "灏勫嚮鍙嶄綔鐢ㄥ姏澧炲己瑁呯疆", "aREACT", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iELECTRIC", "鐢甸灜", "aELECTRIC", "0","0","0","OTHER")
    call SaveStr(idht,iELECTRIC - 'I000',idht_name,"鐢甸灜")
    call SaveInteger(idht,iELECTRIC - 'I000',idht_spell,aELECTRIC)
    call SaveInteger(idht,iELECTRIC - 'I000',idht_s1,0)
    call SaveInteger(idht,iELECTRIC - 'I000',idht_s2,0)
    call SaveInteger(idht,iELECTRIC - 'I000',idht_s3,0)
    call SaveInteger(idht,iELECTRIC - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iELECTRIC", "鐢甸灜", "aELECTRIC", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iBLINK", "闂儊鍖曢", "aBLINK", "0","0","0","OTHER")
    call SaveStr(idht,iBLINK - 'I000',idht_name,"闂儊鍖曢")
    call SaveInteger(idht,iBLINK - 'I000',idht_spell,aBLINK)
    call SaveInteger(idht,iBLINK - 'I000',idht_s1,0)
    call SaveInteger(idht,iBLINK - 'I000',idht_s2,0)
    call SaveInteger(idht,iBLINK - 'I000',idht_s3,0)
    call SaveInteger(idht,iBLINK - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iBLINK", "闂儊鍖曢", "aBLINK", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iTRANSPORT", "瓒呰窛浼犻€佸櫒", "aTRANSPORT", "0","0","0","OTHER")
    call SaveStr(idht,iTRANSPORT - 'I000',idht_name,"瓒呰窛浼犻€佸櫒")
    call SaveInteger(idht,iTRANSPORT - 'I000',idht_spell,aTRANSPORT)
    call SaveInteger(idht,iTRANSPORT - 'I000',idht_s1,0)
    call SaveInteger(idht,iTRANSPORT - 'I000',idht_s2,0)
    call SaveInteger(idht,iTRANSPORT - 'I000',idht_s3,0)
    call SaveInteger(idht,iTRANSPORT - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iTRANSPORT", "瓒呰窛浼犻€佸櫒", "aTRANSPORT", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iAUTOAIM", "杈呭姪灏勫嚮瑁呯疆", "aAUTOAIM", "0","0","0","OTHER")
    call SaveStr(idht,iAUTOAIM - 'I000',idht_name,"杈呭姪灏勫嚮瑁呯疆")
    call SaveInteger(idht,iAUTOAIM - 'I000',idht_spell,aAUTOAIM)
    call SaveInteger(idht,iAUTOAIM - 'I000',idht_s1,0)
    call SaveInteger(idht,iAUTOAIM - 'I000',idht_s2,0)
    call SaveInteger(idht,iAUTOAIM - 'I000',idht_s3,0)
    call SaveInteger(idht,iAUTOAIM - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iAUTOAIM", "杈呭姪灏勫嚮瑁呯疆", "aAUTOAIM", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iLEAVE", "绂诲績闀?, "aLEAVE", "0","0","0","I_D")
    call SaveStr(idht,iLEAVE - 'I000',idht_name,"绂诲績闀?)
    call SaveInteger(idht,iLEAVE - 'I000',idht_spell,aLEAVE)
    call SaveInteger(idht,iLEAVE - 'I000',idht_s1,0)
    call SaveInteger(idht,iLEAVE - 'I000',idht_s2,0)
    call SaveInteger(idht,iLEAVE - 'I000',idht_s3,0)
    call SaveInteger(idht,iLEAVE - 'I000',idht_item_type,I_D)
//end of: InitWeaponTypeData("iLEAVE", "绂诲績闀?, "aLEAVE", "0","0","0","I_D")
//textmacro instance: InitWeaponTypeData("iBKGRENADE", "闇囪崱鎵嬮浄", "aBKGRENADE", "0","0","0","I_T")
    call SaveStr(idht,iBKGRENADE - 'I000',idht_name,"闇囪崱鎵嬮浄")
    call SaveInteger(idht,iBKGRENADE - 'I000',idht_spell,aBKGRENADE)
    call SaveInteger(idht,iBKGRENADE - 'I000',idht_s1,0)
    call SaveInteger(idht,iBKGRENADE - 'I000',idht_s2,0)
    call SaveInteger(idht,iBKGRENADE - 'I000',idht_s3,0)
    call SaveInteger(idht,iBKGRENADE - 'I000',idht_item_type,I_T)
//end of: InitWeaponTypeData("iBKGRENADE", "闇囪崱鎵嬮浄", "aBKGRENADE", "0","0","0","I_T")
//textmacro instance: InitWeaponTypeData("iPSGRENADE", "鍐插嚮鎵嬮浄", "aPSGRENADE", "0","0","0","I_T")
    call SaveStr(idht,iPSGRENADE - 'I000',idht_name,"鍐插嚮鎵嬮浄")
    call SaveInteger(idht,iPSGRENADE - 'I000',idht_spell,aPSGRENADE)
    call SaveInteger(idht,iPSGRENADE - 'I000',idht_s1,0)
    call SaveInteger(idht,iPSGRENADE - 'I000',idht_s2,0)
    call SaveInteger(idht,iPSGRENADE - 'I000',idht_s3,0)
    call SaveInteger(idht,iPSGRENADE - 'I000',idht_item_type,I_T)
//end of: InitWeaponTypeData("iPSGRENADE", "鍐插嚮鎵嬮浄", "aPSGRENADE", "0","0","0","I_T")
//textmacro instance: InitWeaponTypeData("iMINE", "鍙嶆鍏靛湴闆?, "aMINE", "0","0","0","I_N")
    call SaveStr(idht,iMINE - 'I000',idht_name,"鍙嶆鍏靛湴闆?)
    call SaveInteger(idht,iMINE - 'I000',idht_spell,aMINE)
    call SaveInteger(idht,iMINE - 'I000',idht_s1,0)
    call SaveInteger(idht,iMINE - 'I000',idht_s2,0)
    call SaveInteger(idht,iMINE - 'I000',idht_s3,0)
    call SaveInteger(idht,iMINE - 'I000',idht_item_type,I_N)
//end of: InitWeaponTypeData("iMINE", "鍙嶆鍏靛湴闆?, "aMINE", "0","0","0","I_N")
//textmacro instance: InitWeaponTypeData("'I00P'", "绛夌瀛愯偐鐐?, "'A01N'", "0","0","0","AB1")
    call SaveStr(idht,'I00P' - 'I000',idht_name,"绛夌瀛愯偐鐐?)
    call SaveInteger(idht,'I00P' - 'I000',idht_spell,'A01N')
    call SaveInteger(idht,'I00P' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I00P' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I00P' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I00P' - 'I000',idht_item_type,AB1)
//end of: InitWeaponTypeData("'I00P'", "绛夌瀛愯偐鐐?, "'A01N'", "0","0","0","AB1")
//textmacro instance: InitWeaponTypeData("'I00Q'", "蹇垉椋炵", "'A01O'", "0","0","0","AB1")
    call SaveStr(idht,'I00Q' - 'I000',idht_name,"蹇垉椋炵")
    call SaveInteger(idht,'I00Q' - 'I000',idht_spell,'A01O')
    call SaveInteger(idht,'I00Q' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I00Q' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I00Q' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I00Q' - 'I000',idht_item_type,AB1)
//end of: InitWeaponTypeData("'I00Q'", "蹇垉椋炵", "'A01O'", "0","0","0","AB1")
//textmacro instance: InitWeaponTypeData("'I00Z'", "鍔涢噺鎷冲", "'A01Y'", "0","0","0","AB1")
    call SaveStr(idht,'I00Z' - 'I000',idht_name,"鍔涢噺鎷冲")
    call SaveInteger(idht,'I00Z' - 'I000',idht_spell,'A01Y')
    call SaveInteger(idht,'I00Z' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I00Z' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I00Z' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I00Z' - 'I000',idht_item_type,AB1)
//end of: InitWeaponTypeData("'I00Z'", "鍔涢噺鎷冲", "'A01Y'", "0","0","0","AB1")
//textmacro instance: InitWeaponTypeData("'I00Y'", "鐏姏鍘嬪埗", "'A01T'", "0","0","0","AB2")
    call SaveStr(idht,'I00Y' - 'I000',idht_name,"鐏姏鍘嬪埗")
    call SaveInteger(idht,'I00Y' - 'I000',idht_spell,'A01T')
    call SaveInteger(idht,'I00Y' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I00Y' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I00Y' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I00Y' - 'I000',idht_item_type,AB2)
//end of: InitWeaponTypeData("'I00Y'", "鐏姏鍘嬪埗", "'A01T'", "0","0","0","AB2")
//textmacro instance: InitWeaponTypeData("iSPEED", "鍠峰皠鍔犻€?, "'A00C'", "0","0","0","AB2")
    call SaveStr(idht,iSPEED - 'I000',idht_name,"鍠峰皠鍔犻€?)
    call SaveInteger(idht,iSPEED - 'I000',idht_spell,'A00C')
    call SaveInteger(idht,iSPEED - 'I000',idht_s1,0)
    call SaveInteger(idht,iSPEED - 'I000',idht_s2,0)
    call SaveInteger(idht,iSPEED - 'I000',idht_s3,0)
    call SaveInteger(idht,iSPEED - 'I000',idht_item_type,AB2)
//end of: InitWeaponTypeData("iSPEED", "鍠峰皠鍔犻€?, "'A00C'", "0","0","0","AB2")
//textmacro instance: InitWeaponTypeData("'I012'", "缃戞灙", "'A021'", "0","0","0","AB2")
    call SaveStr(idht,'I012' - 'I000',idht_name,"缃戞灙")
    call SaveInteger(idht,'I012' - 'I000',idht_spell,'A021')
    call SaveInteger(idht,'I012' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I012' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I012' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I012' - 'I000',idht_item_type,AB2)
//end of: InitWeaponTypeData("'I012'", "缃戞灙", "'A021'", "0","0","0","AB2")
//textmacro instance: InitWeaponTypeData("'I001'", "鏅€氭鏋?, "'A01O'", "0","0","0","GUN")
    call SaveStr(idht,'I001' - 'I000',idht_name,"鏅€氭鏋?)
    call SaveInteger(idht,'I001' - 'I000',idht_spell,'A01O')
    call SaveInteger(idht,'I001' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I001' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I001' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I001' - 'I000',idht_item_type,GUN)
//end of: InitWeaponTypeData("'I001'", "鏅€氭鏋?, "'A01O'", "0","0","0","GUN")
//textmacro instance: InitWeaponTypeData("'I00R'", "鐭涙灙", "'A01O'", "0","0","0","GUN")
    call SaveStr(idht,'I00R' - 'I000',idht_name,"鐭涙灙")
    call SaveInteger(idht,'I00R' - 'I000',idht_spell,'A01O')
    call SaveInteger(idht,'I00R' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I00R' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I00R' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I00R' - 'I000',idht_item_type,GUN)
//end of: InitWeaponTypeData("'I00R'", "鐭涙灙", "'A01O'", "0","0","0","GUN")
//textmacro instance: InitWeaponTypeData("'I00S'", "鐏劙鏁ｅ脊鏋?, "'A01O'", "0","0","0","GUN")
    call SaveStr(idht,'I00S' - 'I000',idht_name,"鐏劙鏁ｅ脊鏋?)
    call SaveInteger(idht,'I00S' - 'I000',idht_spell,'A01O')
    call SaveInteger(idht,'I00S' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I00S' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I00S' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I00S' - 'I000',idht_item_type,GUN)
//end of: InitWeaponTypeData("'I00S'", "鐏劙鏁ｅ脊鏋?, "'A01O'", "0","0","0","GUN")
//textmacro instance: InitItemFeatureData("iJUMP", "1", "璺宠穬楂樺害", "35","5","0","5","100","0")
    call SaveStr(ifht1,iJUMP - 'I000',ifht_name,"璺宠穬楂樺害")
    call SaveReal(ifht1,iJUMP - 'I000',ifht_origin,35)
    call SaveReal(ifht1,iJUMP - 'I000',ifht_step,5)
    call SaveInteger(ifht1,iJUMP - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iJUMP - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iJUMP - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iJUMP - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iJUMP", "1", "璺宠穬楂樺害", "35","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iJUMP", "2", "璺宠穬璺濈", "10","3","0","5","100","0")
    call SaveStr(ifht2,iJUMP - 'I000',ifht_name,"璺宠穬璺濈")
    call SaveReal(ifht2,iJUMP - 'I000',ifht_origin,10)
    call SaveReal(ifht2,iJUMP - 'I000',ifht_step,3)
    call SaveInteger(ifht2,iJUMP - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iJUMP - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iJUMP - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iJUMP - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iJUMP", "2", "璺宠穬璺濈", "10","3","0","5","100","0")
//textmacro instance: InitItemFeatureData("iRETURN", "1", "鎶曟幏閫熷害", "80","10","0","5","100","0")
    call SaveStr(ifht1,iRETURN - 'I000',ifht_name,"鎶曟幏閫熷害")
    call SaveReal(ifht1,iRETURN - 'I000',ifht_origin,80)
    call SaveReal(ifht1,iRETURN - 'I000',ifht_step,10)
    call SaveInteger(ifht1,iRETURN - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iRETURN - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iRETURN - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iRETURN - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iRETURN", "1", "鎶曟幏閫熷害", "80","10","0","5","100","0")
//textmacro instance: InitItemFeatureData("iRETURN", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
    call SaveStr(ifht2,iRETURN - 'I000',ifht_name,"棰濆浼ゅ")
    call SaveReal(ifht2,iRETURN - 'I000',ifht_origin,0)
    call SaveReal(ifht2,iRETURN - 'I000',ifht_step,20)
    call SaveInteger(ifht2,iRETURN - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iRETURN - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iRETURN - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iRETURN - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iRETURN", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
//textmacro instance: InitItemFeatureData("iLEAVE", "1", "椋炶閫熷害", "3.5","0.5","0","5","100","0")
    call SaveStr(ifht1,iLEAVE - 'I000',ifht_name,"椋炶閫熷害")
    call SaveReal(ifht1,iLEAVE - 'I000',ifht_origin,3.5)
    call SaveReal(ifht1,iLEAVE - 'I000',ifht_step,0.5)
    call SaveInteger(ifht1,iLEAVE - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iLEAVE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iLEAVE - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iLEAVE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iLEAVE", "1", "椋炶閫熷害", "3.5","0.5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iLEAVE", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
    call SaveStr(ifht2,iLEAVE - 'I000',ifht_name,"棰濆浼ゅ")
    call SaveReal(ifht2,iLEAVE - 'I000',ifht_origin,0)
    call SaveReal(ifht2,iLEAVE - 'I000',ifht_step,20)
    call SaveInteger(ifht2,iLEAVE - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iLEAVE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iLEAVE - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iLEAVE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iLEAVE", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
//textmacro instance: InitItemFeatureData("iREACT", "1", "灏勫嚮鍙嶄綔鐢ㄥ姏", "0.5","0.25","0","2","50","0")
    call SaveStr(ifht1,iREACT - 'I000',ifht_name,"灏勫嚮鍙嶄綔鐢ㄥ姏")
    call SaveReal(ifht1,iREACT - 'I000',ifht_origin,0.5)
    call SaveReal(ifht1,iREACT - 'I000',ifht_step,0.25)
    call SaveInteger(ifht1,iREACT - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iREACT - 'I000',ifht_max_lv,2)
    call SaveInteger(ifht1,iREACT - 'I000',ifht_gold,50)
    call SaveInteger(ifht1,iREACT - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iREACT", "1", "灏勫嚮鍙嶄綔鐢ㄥ姏", "0.5","0.25","0","2","50","0")
//textmacro instance: InitItemFeatureData("iELECTRIC", "1", "鎶曟幏閫熷害", "30","10","0","5","100","0")
    call SaveStr(ifht1,iELECTRIC - 'I000',ifht_name,"鎶曟幏閫熷害")
    call SaveReal(ifht1,iELECTRIC - 'I000',ifht_origin,30)
    call SaveReal(ifht1,iELECTRIC - 'I000',ifht_step,10)
    call SaveInteger(ifht1,iELECTRIC - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iELECTRIC - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iELECTRIC - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iELECTRIC - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iELECTRIC", "1", "鎶曟幏閫熷害", "30","10","0","5","100","0")
//textmacro instance: InitItemFeatureData("iELECTRIC", "2", "鎶曟幏璺濈", "30","5","0","5","100","0")
    call SaveStr(ifht2,iELECTRIC - 'I000',ifht_name,"鎶曟幏璺濈")
    call SaveReal(ifht2,iELECTRIC - 'I000',ifht_origin,30)
    call SaveReal(ifht2,iELECTRIC - 'I000',ifht_step,5)
    call SaveInteger(ifht2,iELECTRIC - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iELECTRIC - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iELECTRIC - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iELECTRIC - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iELECTRIC", "2", "鎶曟幏璺濈", "30","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBLINK", "1", "闂儊璺濈", "600","200","0","3","50","0")
    call SaveStr(ifht1,iBLINK - 'I000',ifht_name,"闂儊璺濈")
    call SaveReal(ifht1,iBLINK - 'I000',ifht_origin,600)
    call SaveReal(ifht1,iBLINK - 'I000',ifht_step,200)
    call SaveInteger(ifht1,iBLINK - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iBLINK - 'I000',ifht_max_lv,3)
    call SaveInteger(ifht1,iBLINK - 'I000',ifht_gold,50)
    call SaveInteger(ifht1,iBLINK - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iBLINK", "1", "闂儊璺濈", "600","200","0","3","50","0")
//textmacro instance: InitItemFeatureData("iTRANSPORT", "1", "浼犻€佽窛绂?, "5000","2000","0","5","150","0")
    call SaveStr(ifht1,iTRANSPORT - 'I000',ifht_name,"浼犻€佽窛绂?)
    call SaveReal(ifht1,iTRANSPORT - 'I000',ifht_origin,5000)
    call SaveReal(ifht1,iTRANSPORT - 'I000',ifht_step,2000)
    call SaveInteger(ifht1,iTRANSPORT - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iTRANSPORT - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iTRANSPORT - 'I000',ifht_gold,150)
    call SaveInteger(ifht1,iTRANSPORT - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iTRANSPORT", "1", "浼犻€佽窛绂?, "5000","2000","0","5","150","0")
//textmacro instance: InitItemFeatureData("iAUTOAIM", "1", "鎸佺画鏃堕棿", "3","1","0","5","100","0")
    call SaveStr(ifht1,iAUTOAIM - 'I000',ifht_name,"鎸佺画鏃堕棿")
    call SaveReal(ifht1,iAUTOAIM - 'I000',ifht_origin,3)
    call SaveReal(ifht1,iAUTOAIM - 'I000',ifht_step,1)
    call SaveInteger(ifht1,iAUTOAIM - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iAUTOAIM - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iAUTOAIM - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iAUTOAIM - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iAUTOAIM", "1", "鎸佺画鏃堕棿", "3","1","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBKGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
    call SaveStr(ifht1,iBKGRENADE - 'I000',ifht_name,"鎶曟幏鍔涢噺")
    call SaveReal(ifht1,iBKGRENADE - 'I000',ifht_origin,50)
    call SaveReal(ifht1,iBKGRENADE - 'I000',ifht_step,5)
    call SaveInteger(ifht1,iBKGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iBKGRENADE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iBKGRENADE - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iBKGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iBKGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBKGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
    call SaveStr(ifht2,iBKGRENADE - 'I000',ifht_name,"鐖嗙偢鑼冨洿")
    call SaveReal(ifht2,iBKGRENADE - 'I000',ifht_origin,500)
    call SaveReal(ifht2,iBKGRENADE - 'I000',ifht_step,50)
    call SaveInteger(ifht2,iBKGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iBKGRENADE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iBKGRENADE - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iBKGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iBKGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBKGRENADE", "3", "鐪╂檿", "1","1","0","1","300","0")
    call SaveStr(ifht3,iBKGRENADE - 'I000',ifht_name,"鐪╂檿")
    call SaveReal(ifht3,iBKGRENADE - 'I000',ifht_origin,1)
    call SaveReal(ifht3,iBKGRENADE - 'I000',ifht_step,1)
    call SaveInteger(ifht3,iBKGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht3,iBKGRENADE - 'I000',ifht_max_lv,1)
    call SaveInteger(ifht3,iBKGRENADE - 'I000',ifht_gold,300)
    call SaveInteger(ifht3,iBKGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iBKGRENADE", "3", "鐪╂檿", "1","1","0","1","300","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
    call SaveStr(ifht1,iPSGRENADE - 'I000',ifht_name,"鎶曟幏鍔涢噺")
    call SaveReal(ifht1,iPSGRENADE - 'I000',ifht_origin,50)
    call SaveReal(ifht1,iPSGRENADE - 'I000',ifht_step,5)
    call SaveInteger(ifht1,iPSGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iPSGRENADE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iPSGRENADE - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iPSGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iPSGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
    call SaveStr(ifht2,iPSGRENADE - 'I000',ifht_name,"鐖嗙偢鑼冨洿")
    call SaveReal(ifht2,iPSGRENADE - 'I000',ifht_origin,500)
    call SaveReal(ifht2,iPSGRENADE - 'I000',ifht_step,50)
    call SaveInteger(ifht2,iPSGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iPSGRENADE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iPSGRENADE - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iPSGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iPSGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "3", "鍑婚€€", "10","2","0","5","100","0")
    call SaveStr(ifht3,iPSGRENADE - 'I000',ifht_name,"鍑婚€€")
    call SaveReal(ifht3,iPSGRENADE - 'I000',ifht_origin,10)
    call SaveReal(ifht3,iPSGRENADE - 'I000',ifht_step,2)
    call SaveInteger(ifht3,iPSGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht3,iPSGRENADE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht3,iPSGRENADE - 'I000',ifht_gold,100)
    call SaveInteger(ifht3,iPSGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iPSGRENADE", "3", "鍑婚€€", "10","2","0","5","100","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "4", "鍑忛€?, "0","1","0","2","200","0")
    call SaveStr(ifht4,iPSGRENADE - 'I000',ifht_name,"鍑忛€?)
    call SaveReal(ifht4,iPSGRENADE - 'I000',ifht_origin,0)
    call SaveReal(ifht4,iPSGRENADE - 'I000',ifht_step,1)
    call SaveInteger(ifht4,iPSGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht4,iPSGRENADE - 'I000',ifht_max_lv,2)
    call SaveInteger(ifht4,iPSGRENADE - 'I000',ifht_gold,200)
    call SaveInteger(ifht4,iPSGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iPSGRENADE", "4", "鍑忛€?, "0","1","0","2","200","0")
//textmacro instance: QuickItemFeatureData("'I00Q'", "1", "浼ゅ澧炲箙", "5","1","姣忕骇澧炲姞10%鍒囧壊浼ゅ")
    call SaveStr(ifht1,'I00Q' - 'I000',ifht_name,"浼ゅ澧炲箙")
    call SaveReal(ifht1,'I00Q' - 'I000',ifht_origin,0)
    call SaveReal(ifht1,'I00Q' - 'I000',ifht_step,1)
    call SaveInteger(ifht1,'I00Q' - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,'I00Q' - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,'I00Q' - 'I000',ifht_gold,0)
    call SaveInteger(ifht1,'I00Q' - 'I000',ifht_wood,1)
    call SaveStr(ifht1,'I00Q' - 'I000',ifht_desc,"姣忕骇澧炲姞10%鍒囧壊浼ゅ")
//end of: QuickItemFeatureData("'I00Q'", "1", "浼ゅ澧炲箙", "5","1","姣忕骇澧炲姞10%鍒囧壊浼ゅ")
//textmacro instance: QuickItemFeatureData("'I00Q'", "2", "澶嶆暟椋炵", "2","4","鍙戝皠澶氭灇椋炵鑰屼笉鏄竴鏋氾紝姣忕骇澧炲姞涓ゆ灇銆?)
    call SaveStr(ifht2,'I00Q' - 'I000',ifht_name,"澶嶆暟椋炵")
    call SaveReal(ifht2,'I00Q' - 'I000',ifht_origin,0)
    call SaveReal(ifht2,'I00Q' - 'I000',ifht_step,1)
    call SaveInteger(ifht2,'I00Q' - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,'I00Q' - 'I000',ifht_max_lv,2)
    call SaveInteger(ifht2,'I00Q' - 'I000',ifht_gold,0)
    call SaveInteger(ifht2,'I00Q' - 'I000',ifht_wood,4)
    call SaveStr(ifht2,'I00Q' - 'I000',ifht_desc,"鍙戝皠澶氭灇椋炵鑰屼笉鏄竴鏋氾紝姣忕骇澧炲姞涓ゆ灇銆?)
//end of: QuickItemFeatureData("'I00Q'", "2", "澶嶆暟椋炵", "2","4","鍙戝皠澶氭灇椋炵鑰屼笉鏄竴鏋氾紝姣忕骇澧炲姞涓ゆ灇銆?)
//textmacro instance: QuickItemFeatureData("'I00Q'", "3", "鑷垎椋炵", "3","3","鎺у埗椋炶涓殑椋炵鑷垎锛岄€犳垚宸ㄥぇ浼ゅ銆傜垎鐐镐激瀹抽殢绛夌骇鎻愬崌")
    call SaveStr(ifht3,'I00Q' - 'I000',ifht_name,"鑷垎椋炵")
    call SaveReal(ifht3,'I00Q' - 'I000',ifht_origin,0)
    call SaveReal(ifht3,'I00Q' - 'I000',ifht_step,1)
    call SaveInteger(ifht3,'I00Q' - 'I000',ifht_lv,0)
    call SaveInteger(ifht3,'I00Q' - 'I000',ifht_max_lv,3)
    call SaveInteger(ifht3,'I00Q' - 'I000',ifht_gold,0)
    call SaveInteger(ifht3,'I00Q' - 'I000',ifht_wood,3)
    call SaveStr(ifht3,'I00Q' - 'I000',ifht_desc,"鎺у埗椋炶涓殑椋炵鑷垎锛岄€犳垚宸ㄥぇ浼ゅ銆傜垎鐐镐激瀹抽殢绛夌骇鎻愬崌")
//end of: QuickItemFeatureData("'I00Q'", "3", "鑷垎椋炵", "3","3","鎺у埗椋炶涓殑椋炵鑷垎锛岄€犳垚宸ㄥぇ浼ゅ銆傜垎鐐镐激瀹抽殢绛夌骇鎻愬崌")
//textmacro instance: QuickItemFeatureData("'I00Q'", "4", "椋炶缁埅", "3","1","寤堕暱椋炵椋炶鏃堕棿锛屾瘡绾у闀?绉?)
    call SaveStr(ifht4,'I00Q' - 'I000',ifht_name,"椋炶缁埅")
    call SaveReal(ifht4,'I00Q' - 'I000',ifht_origin,0)
    call SaveReal(ifht4,'I00Q' - 'I000',ifht_step,1)
    call SaveInteger(ifht4,'I00Q' - 'I000',ifht_lv,0)
    call SaveInteger(ifht4,'I00Q' - 'I000',ifht_max_lv,3)
    call SaveInteger(ifht4,'I00Q' - 'I000',ifht_gold,0)
    call SaveInteger(ifht4,'I00Q' - 'I000',ifht_wood,1)
    call SaveStr(ifht4,'I00Q' - 'I000',ifht_desc,"寤堕暱椋炵椋炶鏃堕棿锛屾瘡绾у闀?绉?)
//end of: QuickItemFeatureData("'I00Q'", "4", "椋炶缁埅", "3","1","寤堕暱椋炵椋炶鏃堕棿锛屾瘡绾у闀?绉?)
//textmacro instance: QuickItemFeatureData("'I00P'", "1", "浼ゅ澧炲箙", "5","1","姣忕骇澧炲姞10%绂诲瓙鍥激瀹?)
    call SaveStr(ifht1,'I00P' - 'I000',ifht_name,"浼ゅ澧炲箙")
    call SaveReal(ifht1,'I00P' - 'I000',ifht_origin,0)
    call SaveReal(ifht1,'I00P' - 'I000',ifht_step,1)
    call SaveInteger(ifht1,'I00P' - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,'I00P' - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,'I00P' - 'I000',ifht_gold,0)
    call SaveInteger(ifht1,'I00P' - 'I000',ifht_wood,1)
    call SaveStr(ifht1,'I00P' - 'I000',ifht_desc,"姣忕骇澧炲姞10%绂诲瓙鍥激瀹?)
//end of: QuickItemFeatureData("'I00P'", "1", "浼ゅ澧炲箙", "5","1","姣忕骇澧炲姞10%绂诲瓙鍥激瀹?)
//textmacro instance: QuickItemFeatureData("'I00P'", "2", "澶嶆暟绂诲瓙鐐?, "2","3","姣忕骇澧炲姞棰濆涓ら绂诲瓙鍥?)
    call SaveStr(ifht2,'I00P' - 'I000',ifht_name,"澶嶆暟绂诲瓙鐐?)
    call SaveReal(ifht2,'I00P' - 'I000',ifht_origin,0)
    call SaveReal(ifht2,'I00P' - 'I000',ifht_step,1)
    call SaveInteger(ifht2,'I00P' - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,'I00P' - 'I000',ifht_max_lv,2)
    call SaveInteger(ifht2,'I00P' - 'I000',ifht_gold,0)
    call SaveInteger(ifht2,'I00P' - 'I000',ifht_wood,3)
    call SaveStr(ifht2,'I00P' - 'I000',ifht_desc,"姣忕骇澧炲姞棰濆涓ら绂诲瓙鍥?)
//end of: QuickItemFeatureData("'I00P'", "2", "澶嶆暟绂诲瓙鐐?, "2","3","姣忕骇澧炲姞棰濆涓ら绂诲瓙鍥?)
//textmacro instance: QuickItemFeatureData("'I00Z'", "1", "浼ゅ澧炲箙", "5","1","姣忕骇澧炲姞10%瑁傚湴浼ゅ")
    call SaveStr(ifht1,'I00Z' - 'I000',ifht_name,"浼ゅ澧炲箙")
    call SaveReal(ifht1,'I00Z' - 'I000',ifht_origin,0)
    call SaveReal(ifht1,'I00Z' - 'I000',ifht_step,1)
    call SaveInteger(ifht1,'I00Z' - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,'I00Z' - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,'I00Z' - 'I000',ifht_gold,0)
    call SaveInteger(ifht1,'I00Z' - 'I000',ifht_wood,1)
    call SaveStr(ifht1,'I00Z' - 'I000',ifht_desc,"姣忕骇澧炲姞10%瑁傚湴浼ゅ")
//end of: QuickItemFeatureData("'I00Z'", "1", "浼ゅ澧炲箙", "5","1","姣忕骇澧炲姞10%瑁傚湴浼ゅ")
//textmacro instance: QuickItemFeatureData("'I00Z'", "2", "寮哄姏鍑婚", "3","1","闇囬鎬墿锛屼娇瀹冧滑杩滅鑷繁锛屽嚮椋炶窛绂婚殢绛夌骇鎻愬崌")
    call SaveStr(ifht2,'I00Z' - 'I000',ifht_name,"寮哄姏鍑婚")
    call SaveReal(ifht2,'I00Z' - 'I000',ifht_origin,0)
    call SaveReal(ifht2,'I00Z' - 'I000',ifht_step,1)
    call SaveInteger(ifht2,'I00Z' - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,'I00Z' - 'I000',ifht_max_lv,3)
    call SaveInteger(ifht2,'I00Z' - 'I000',ifht_gold,0)
    call SaveInteger(ifht2,'I00Z' - 'I000',ifht_wood,1)
    call SaveStr(ifht2,'I00Z' - 'I000',ifht_desc,"闇囬鎬墿锛屼娇瀹冧滑杩滅鑷繁锛屽嚮椋炶窛绂婚殢绛夌骇鎻愬崌")
//end of: QuickItemFeatureData("'I00Z'", "2", "寮哄姏鍑婚", "3","1","闇囬鎬墿锛屼娇瀹冧滑杩滅鑷繁锛屽嚮椋炶窛绂婚殢绛夌骇鎻愬崌")
//textmacro instance: QuickItemFeatureData("'I00Z'", "3", "鏀诲嚮鑼冨洿", "5","1","澧炲姞瑁傚湴浣滅敤鑼冨洿锛屾瘡绾ф墿澶?0鐮?)
    call SaveStr(ifht3,'I00Z' - 'I000',ifht_name,"鏀诲嚮鑼冨洿")
    call SaveReal(ifht3,'I00Z' - 'I000',ifht_origin,0)
    call SaveReal(ifht3,'I00Z' - 'I000',ifht_step,1)
    call SaveInteger(ifht3,'I00Z' - 'I000',ifht_lv,0)
    call SaveInteger(ifht3,'I00Z' - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht3,'I00Z' - 'I000',ifht_gold,0)
    call SaveInteger(ifht3,'I00Z' - 'I000',ifht_wood,1)
    call SaveStr(ifht3,'I00Z' - 'I000',ifht_desc,"澧炲姞瑁傚湴浣滅敤鑼冨洿锛屾瘡绾ф墿澶?0鐮?)
//end of: QuickItemFeatureData("'I00Z'", "3", "鏀诲嚮鑼冨洿", "5","1","澧炲姞瑁傚湴浣滅敤鑼冨洿锛屾瘡绾ф墿澶?0鐮?)
//textmacro instance: QuickItemFeatureData("'I00Z'", "4", "鐪╂檿鏃堕棿", "5","1","姣忕骇寤堕暱1绉掔湬鏅曟椂闂?)
    call SaveStr(ifht4,'I00Z' - 'I000',ifht_name,"鐪╂檿鏃堕棿")
    call SaveReal(ifht4,'I00Z' - 'I000',ifht_origin,0)
    call SaveReal(ifht4,'I00Z' - 'I000',ifht_step,1)
    call SaveInteger(ifht4,'I00Z' - 'I000',ifht_lv,0)
    call SaveInteger(ifht4,'I00Z' - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht4,'I00Z' - 'I000',ifht_gold,0)
    call SaveInteger(ifht4,'I00Z' - 'I000',ifht_wood,1)
    call SaveStr(ifht4,'I00Z' - 'I000',ifht_desc,"姣忕骇寤堕暱1绉掔湬鏅曟椂闂?)
//end of: QuickItemFeatureData("'I00Z'", "4", "鐪╂檿鏃堕棿", "5","1","姣忕骇寤堕暱1绉掔湬鏅曟椂闂?)
//textmacro instance: QuickItemFeatureData("'I00Z'", "5", "闇囪崱娉?, "2","3","闇囪崱鍦伴潰锛岃緪灏勯渿鑽℃尝锛屽ぇ鑼冨洿鐪╂檿鏁屼汉")
    call SaveStr(ifht5,'I00Z' - 'I000',ifht_name,"闇囪崱娉?)
    call SaveReal(ifht5,'I00Z' - 'I000',ifht_origin,0)
    call SaveReal(ifht5,'I00Z' - 'I000',ifht_step,1)
    call SaveInteger(ifht5,'I00Z' - 'I000',ifht_lv,0)
    call SaveInteger(ifht5,'I00Z' - 'I000',ifht_max_lv,2)
    call SaveInteger(ifht5,'I00Z' - 'I000',ifht_gold,0)
    call SaveInteger(ifht5,'I00Z' - 'I000',ifht_wood,3)
    call SaveStr(ifht5,'I00Z' - 'I000',ifht_desc,"闇囪崱鍦伴潰锛岃緪灏勯渿鑽℃尝锛屽ぇ鑼冨洿鐪╂檿鏁屼汉")
//end of: QuickItemFeatureData("'I00Z'", "5", "闇囪崱娉?, "2","3","闇囪崱鍦伴潰锛岃緪灏勯渿鑽℃尝锛屽ぇ鑼冨洿鐪╂檿鏁屼汉")
//textmacro instance: QuickItemFeatureData("'I00Y'", "1", "鎬ュ皠澧炲箙", "5","1","姣忕骇澧炲姞5%灏勫嚮閫熷害")
    call SaveStr(ifht1,'I00Y' - 'I000',ifht_name,"鎬ュ皠澧炲箙")
    call SaveReal(ifht1,'I00Y' - 'I000',ifht_origin,0)
    call SaveReal(ifht1,'I00Y' - 'I000',ifht_step,1)
    call SaveInteger(ifht1,'I00Y' - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,'I00Y' - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,'I00Y' - 'I000',ifht_gold,0)
    call SaveInteger(ifht1,'I00Y' - 'I000',ifht_wood,1)
    call SaveStr(ifht1,'I00Y' - 'I000',ifht_desc,"姣忕骇澧炲姞5%灏勫嚮閫熷害")
//end of: QuickItemFeatureData("'I00Y'", "1", "鎬ュ皠澧炲箙", "5","1","姣忕骇澧炲姞5%灏勫嚮閫熷害")
//textmacro instance: QuickItemFeatureData("'I00Y'", "2", "蹇€熻寮?, "1","2","鍙戝姩鐏姏鍘嬪埗鍚屾椂鐬棿濉弧寮瑰す")
    call SaveStr(ifht2,'I00Y' - 'I000',ifht_name,"蹇€熻寮?)
    call SaveReal(ifht2,'I00Y' - 'I000',ifht_origin,0)
    call SaveReal(ifht2,'I00Y' - 'I000',ifht_step,1)
    call SaveInteger(ifht2,'I00Y' - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,'I00Y' - 'I000',ifht_max_lv,1)
    call SaveInteger(ifht2,'I00Y' - 'I000',ifht_gold,0)
    call SaveInteger(ifht2,'I00Y' - 'I000',ifht_wood,2)
    call SaveStr(ifht2,'I00Y' - 'I000',ifht_desc,"鍙戝姩鐏姏鍘嬪埗鍚屾椂鐬棿濉弧寮瑰す")
//end of: QuickItemFeatureData("'I00Y'", "2", "蹇€熻寮?, "1","2","鍙戝姩鐏姏鍘嬪埗鍚屾椂鐬棿濉弧寮瑰す")
//textmacro instance: QuickItemFeatureData("'I00Y'", "3", "鎸佺画鏃堕棿", "5","1","姣忕骇寤堕暱1绉掓寔缁椂闂?)
    call SaveStr(ifht3,'I00Y' - 'I000',ifht_name,"鎸佺画鏃堕棿")
    call SaveReal(ifht3,'I00Y' - 'I000',ifht_origin,0)
    call SaveReal(ifht3,'I00Y' - 'I000',ifht_step,1)
    call SaveInteger(ifht3,'I00Y' - 'I000',ifht_lv,0)
    call SaveInteger(ifht3,'I00Y' - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht3,'I00Y' - 'I000',ifht_gold,0)
    call SaveInteger(ifht3,'I00Y' - 'I000',ifht_wood,1)
    call SaveStr(ifht3,'I00Y' - 'I000',ifht_desc,"姣忕骇寤堕暱1绉掓寔缁椂闂?)
//end of: QuickItemFeatureData("'I00Y'", "3", "鎸佺画鏃堕棿", "5","1","姣忕骇寤堕暱1绉掓寔缁椂闂?)
//textmacro instance: QuickItemFeatureData("'I003'", "1", "鍠峰皠鍔犻€?, "5","1","鎻愬崌鍠峰皠鍔犻€熷害")
    call SaveStr(ifht1,'I003' - 'I000',ifht_name,"鍠峰皠鍔犻€?)
    call SaveReal(ifht1,'I003' - 'I000',ifht_origin,0)
    call SaveReal(ifht1,'I003' - 'I000',ifht_step,1)
    call SaveInteger(ifht1,'I003' - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,'I003' - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,'I003' - 'I000',ifht_gold,0)
    call SaveInteger(ifht1,'I003' - 'I000',ifht_wood,1)
    call SaveStr(ifht1,'I003' - 'I000',ifht_desc,"鎻愬崌鍠峰皠鍔犻€熷害")
//end of: QuickItemFeatureData("'I003'", "1", "鍠峰皠鍔犻€?, "5","1","鎻愬崌鍠峰皠鍔犻€熷害")
//textmacro instance: QuickItemFeatureData("'I003'", "2", "鍔犻€熷喎鍗?, "3","1","姣忕骇鍑忓皯1绉掓妧鑳絚d")
    call SaveStr(ifht2,'I003' - 'I000',ifht_name,"鍔犻€熷喎鍗?)
    call SaveReal(ifht2,'I003' - 'I000',ifht_origin,0)
    call SaveReal(ifht2,'I003' - 'I000',ifht_step,1)
    call SaveInteger(ifht2,'I003' - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,'I003' - 'I000',ifht_max_lv,3)
    call SaveInteger(ifht2,'I003' - 'I000',ifht_gold,0)
    call SaveInteger(ifht2,'I003' - 'I000',ifht_wood,1)
    call SaveStr(ifht2,'I003' - 'I000',ifht_desc,"姣忕骇鍑忓皯1绉掓妧鑳絚d")
//end of: QuickItemFeatureData("'I003'", "2", "鍔犻€熷喎鍗?, "3","1","姣忕骇鍑忓皯1绉掓妧鑳絚d")
//textmacro instance: QuickItemFeatureData("'I003'", "3", "鍠峰皠鍐叉挒", "3","2","鐪╂檿鍐叉挒鍒扮殑鏁屼汉3绉掗挓锛屽浠栦滑閫犳垚閫熷害姣斾緥浼ゅ锛屽悓鏃惰嚜宸辫兘闈㈠厤鐤挒鍑?)
    call SaveStr(ifht3,'I003' - 'I000',ifht_name,"鍠峰皠鍐叉挒")
    call SaveReal(ifht3,'I003' - 'I000',ifht_origin,0)
    call SaveReal(ifht3,'I003' - 'I000',ifht_step,1)
    call SaveInteger(ifht3,'I003' - 'I000',ifht_lv,0)
    call SaveInteger(ifht3,'I003' - 'I000',ifht_max_lv,3)
    call SaveInteger(ifht3,'I003' - 'I000',ifht_gold,0)
    call SaveInteger(ifht3,'I003' - 'I000',ifht_wood,2)
    call SaveStr(ifht3,'I003' - 'I000',ifht_desc,"鐪╂檿鍐叉挒鍒扮殑鏁屼汉3绉掗挓锛屽浠栦滑閫犳垚閫熷害姣斾緥浼ゅ锛屽悓鏃惰嚜宸辫兘闈㈠厤鐤挒鍑?)
//end of: QuickItemFeatureData("'I003'", "3", "鍠峰皠鍐叉挒", "3","2","鐪╂檿鍐叉挒鍒扮殑鏁屼汉3绉掗挓锛屽浠栦滑閫犳垚閫熷害姣斾緥浼ゅ锛屽悓鏃惰嚜宸辫兘闈㈠厤鐤挒鍑?)
//textmacro instance: QuickItemFeatureData("'I012'", "1", "鎺у埗鏃堕棿", "5","1","寤堕暱閽㈢綉鎺у埗鏃堕棿锛屾瘡绾ф彁鍗囦袱绉?)
    call SaveStr(ifht1,'I012' - 'I000',ifht_name,"鎺у埗鏃堕棿")
    call SaveReal(ifht1,'I012' - 'I000',ifht_origin,0)
    call SaveReal(ifht1,'I012' - 'I000',ifht_step,1)
    call SaveInteger(ifht1,'I012' - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,'I012' - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,'I012' - 'I000',ifht_gold,0)
    call SaveInteger(ifht1,'I012' - 'I000',ifht_wood,1)
    call SaveStr(ifht1,'I012' - 'I000',ifht_desc,"寤堕暱閽㈢綉鎺у埗鏃堕棿锛屾瘡绾ф彁鍗囦袱绉?)
//end of: QuickItemFeatureData("'I012'", "1", "鎺у埗鏃堕棿", "5","1","寤堕暱閽㈢綉鎺у埗鏃堕棿锛屾瘡绾ф彁鍗囦袱绉?)
//textmacro instance: QuickItemFeatureData("'I012'", "2", "缁炴潃浼ゅ", "5","1","澧炲姞閽㈢綉鐨勭粸鏉€浼ゅ")
    call SaveStr(ifht2,'I012' - 'I000',ifht_name,"缁炴潃浼ゅ")
    call SaveReal(ifht2,'I012' - 'I000',ifht_origin,0)
    call SaveReal(ifht2,'I012' - 'I000',ifht_step,1)
    call SaveInteger(ifht2,'I012' - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,'I012' - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,'I012' - 'I000',ifht_gold,0)
    call SaveInteger(ifht2,'I012' - 'I000',ifht_wood,1)
    call SaveStr(ifht2,'I012' - 'I000',ifht_desc,"澧炲姞閽㈢綉鐨勭粸鏉€浼ゅ")
//end of: QuickItemFeatureData("'I012'", "2", "缁炴潃浼ゅ", "5","1","澧炲姞閽㈢綉鐨勭粸鏉€浼ゅ")
//textmacro instance: QuickItemFeatureData("'I012'", "3", "澶嶆暟閽㈢綉", "3","2","鍙戝皠鏇村鐨勯挗缃?)
    call SaveStr(ifht3,'I012' - 'I000',ifht_name,"澶嶆暟閽㈢綉")
    call SaveReal(ifht3,'I012' - 'I000',ifht_origin,0)
    call SaveReal(ifht3,'I012' - 'I000',ifht_step,1)
    call SaveInteger(ifht3,'I012' - 'I000',ifht_lv,0)
    call SaveInteger(ifht3,'I012' - 'I000',ifht_max_lv,3)
    call SaveInteger(ifht3,'I012' - 'I000',ifht_gold,0)
    call SaveInteger(ifht3,'I012' - 'I000',ifht_wood,2)
    call SaveStr(ifht3,'I012' - 'I000',ifht_desc,"鍙戝皠鏇村鐨勯挗缃?)
//end of: QuickItemFeatureData("'I012'", "3", "澶嶆暟閽㈢綉", "3","2","鍙戝皠鏇村鐨勯挗缃?)
endfunction
function getItemTypeData takes integer idd returns ItemTypeData
    local integer id = idd - 'I000'
    if HaveSavedString(idht,id,idht_name) then
        return ItemTypeData.create(LoadStr(idht,id,idht_name),LoadInteger(idht,id,idht_spell),LoadInteger(idht,id,idht_s1),LoadInteger(idht,id,idht_s2),LoadInteger(idht,id,idht_s3),LoadInteger(idht,id,idht_item_type))
    endif
    return -1
endfunction
function hasItemTypeData takes integer idd returns boolean
    local integer id = idd - 'I000'
    if HaveSavedString(idht,id,idht_name) then
        return true
    endif
    return false
endfunction
function GetItemByTypeId takes unit u,integer id returns item
local integer i=0
local item ui
loop
    exitwhen i>5
    set ui=UnitItemInSlot(u,i)
    if GetItemTypeId(ui) == id then
        return ui
    endif
    set i=i+1
endloop
set ui = null
return null
endfunction
//textmacro instance: getfeaturevalue("1")
function getf1value takes unit u, integer id returns real
    local item itm = GetItemByTypeId(u, id)
    local ItemFeature f1 = IndividualItemData[itm].featureData.f1
    set itm = null
    return f1.getValue()
endfunction
//end of: getfeaturevalue("1")
//textmacro instance: getfeaturevalue("2")
function getf2value takes unit u, integer id returns real
    local item itm = GetItemByTypeId(u, id)
    local ItemFeature f2 = IndividualItemData[itm].featureData.f2
    set itm = null
    return f2.getValue()
endfunction
//end of: getfeaturevalue("2")
//textmacro instance: getfeaturevalue("3")
function getf3value takes unit u, integer id returns real
    local item itm = GetItemByTypeId(u, id)
    local ItemFeature f3 = IndividualItemData[itm].featureData.f3
    set itm = null
    return f3.getValue()
endfunction
//end of: getfeaturevalue("3")
//textmacro instance: getfeaturevalue("4")
function getf4value takes unit u, integer id returns real
    local item itm = GetItemByTypeId(u, id)
    local ItemFeature f4 = IndividualItemData[itm].featureData.f4
    set itm = null
    return f4.getValue()
endfunction
//end of: getfeaturevalue("4")
//textmacro instance: getfeaturevalue("5")
function getf5value takes unit u, integer id returns real
    local item itm = GetItemByTypeId(u, id)
    local ItemFeature f5 = IndividualItemData[itm].featureData.f5
    set itm = null
    return f5.getValue()
endfunction
//end of: getfeaturevalue("5")

//library ItemData ends
//library Job:
function InitMarinJob takes unit target, integer lv returns nothing
    local integer pid = GetPlayerId(GetOwningPlayer(target))
    if IsHero(target) then
        if lv == 1 then
            call IncShootSpeed(pid)
            call IncShootSpeed(pid)
            set EquipmentData[target].heroData.machine_gun_buff = EquipmentData[target].heroData.machine_gun_buff + 0.15
        endif
    endif
endfunction

//library Job ends
//library JumpFacingStore:
function storeJumpFacing takes nothing returns nothing
    local real sx = GetUnitX(GetTriggerUnit())
    local real sy = GetUnitY(GetTriggerUnit())
    local real tx = GetOrderPointX()
    local real ty = GetOrderPointY()
    local real tz = getTerrianHeight(tx, ty)
    local unit tu = GetOrderTargetUnit()
    local real dir
    if IsHero(GetTriggerUnit()) and GetIssuedOrderId() == OI_RIGHT_CLICK_MOVE then
        if tu != null then
            set tx = GetUnitX(tu)
            set ty = GetUnitY(tu)
            set tz = getUnitHeight(tu)
        endif
        set dir = getDir(sx, sy, tx, ty)
        set EquipmentData[GetTriggerUnit()].heroData.jump_direction = dir
        if EquipmentData[GetTriggerUnit()].heroData.aimu != null and GetUnitAbilityLevel(GetTriggerUnit(), 'A02H') == 0 then
            set EquipmentData[GetTriggerUnit()].heroData.stx = tx
            set EquipmentData[GetTriggerUnit()].heroData.sty = ty
            set EquipmentData[GetTriggerUnit()].heroData.stz = tz
            call SetUnitFacing(GetTriggerUnit(), dir * bj_RADTODEG)
        endif
    endif
    set tu = null
endfunction
function InitJumpFacingStore takes nothing returns nothing
local trigger jumpPointFacing_t=CreateTrigger()
call TriggerAddCondition(jumpPointFacing_t,function storeJumpFacing)
call TriggerRegisterAnyUnitEventBJ( jumpPointFacing_t, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER )
call TriggerRegisterAnyUnitEventBJ( jumpPointFacing_t, EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER )
set jumpPointFacing_t=null
endfunction

//library JumpFacingStore ends
//library Material:
struct Material extends array
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()
    
    string clazz //bullet unit energy
real hardness
    real bounce
    real volume
    real weight
    real airk
    string fakelv
    string ground_action
    integer burnlv
    integer bleedlv
    boolean horro
    real horro_dmg
    real anti_horro
    real kill_hp
    integer shot_tick
    integer shot_fast_buff
    real last_shoot
    real last_fire
    integer last_issue
    integer nocollision
    integer nohitwall
    real colris
    real coldmg
    real colf
    real g
    integer deadcnt
    real pushris
    
    static method AIDS_filter takes unit u returns boolean
        return true
    endmethod
    
    private method AIDS_onCreate takes nothing returns nothing
        local integer ut = GetUnitTypeId(.unit)
        set this.burnlv = 0
        set this.bleedlv = 0
        set this.horro = false
        set this.horro_dmg = HORRO_DMG
        set this.anti_horro = 0
        set this.clazz = MC_UNIT
        set this.hardness = 10
        set this.bounce = 0.2
        set this.volume = 100
        set this.weight = 100
        set this.airk = 0.75
        set this.fakelv = LV_FREEZ
        set this.shot_tick = 0
        set this.shot_fast_buff = 0
        set this.last_shoot = 0
        set this.last_fire = 0
        set this.last_issue = 0
        set this.g = -2
        set this.nocollision = 0
        set this.nohitwall = 0
        set this.colris = 0
        set this.coldmg = 0
        set this.colf = 0
        set this.pushris = 0
        if ut == ONE_WALL or ut == ONE_WALL_BREAKABLE or ut == 'h008' then
            set this.clazz = MC_WALL
        elseif ut == 'ncop' or ut == 'ncp2' or ut == 'ncp3' then
            set this.clazz = MC_RING 
        elseif ut == 'u002' then
            set this.horro_dmg = 0.2
            set this.anti_horro = 0.3
        elseif ut == HERO then
            set this.clazz = MC_UNIT
            set this.hardness = 10
            set this.bounce = 0.2
            set this.volume = 100
            set this.weight = 100
            set this.airk = 0.75
            set this.fakelv = LV_ACTIVE
            set this.ground_action = GROUND_BOUNCE
            set this.horro_dmg = 0.00
            set this.anti_horro = 0
            set this.kill_hp = 0
//textmacro instance: RegisterMaterial("'e000'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e000' then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e000'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e001'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e001' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e001'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e002'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e002' then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e002'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e003'","MC_ARROW","100","1","75","2","0.005","LV_DESTORY","GROUND_SMOOTH")
elseif ut == 'e003' then
    set this.clazz = MC_ARROW
    set this.hardness = 100
    set this.bounce = 1
    set this.volume = 75
    set this.weight = 2
    set this.airk = 0.005
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_SMOOTH
    
//end of: RegisterMaterial("'e003'","MC_ARROW","100","1","75","2","0.005","LV_DESTORY","GROUND_SMOOTH")
//textmacro instance: RegisterMaterial("'e00M'","MC_ARROW","100","1","75","2","0.005","LV_DESTORY","GROUND_SMOOTH")
elseif ut == 'e00M' then
    set this.clazz = MC_ARROW
    set this.hardness = 100
    set this.bounce = 1
    set this.volume = 75
    set this.weight = 2
    set this.airk = 0.005
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_SMOOTH
    
//end of: RegisterMaterial("'e00M'","MC_ARROW","100","1","75","2","0.005","LV_DESTORY","GROUND_SMOOTH")
//textmacro instance: RegisterMaterial("'e004'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e004' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e004'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00N'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00N' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00N'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e009'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e009' then
    set this.clazz = MC_STONE
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 5
    set this.airk = 0.005
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e009'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00A'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00A' then
    set this.clazz = MC_STONE
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 5
    set this.airk = 0.005
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00A'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00B'","MC_MINE","100","0.5","200","30","0","LV_DESTORY","GROUND_STICK")
elseif ut == 'e00B' then
    set this.clazz = MC_MINE
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 200
    set this.weight = 30
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_STICK
    
//end of: RegisterMaterial("'e00B'","MC_MINE","100","0.5","200","30","0","LV_DESTORY","GROUND_STICK")
//textmacro instance: RegisterMaterial("bICE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == bICE_MISSLE then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("bICE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("bFIRE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == bFIRE_MISSLE then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("bFIRE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("MAGIC","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == MAGIC then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("MAGIC","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("DUMMY_TYPE","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == DUMMY_TYPE then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("DUMMY_TYPE","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("bELECTRIC","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == bELECTRIC then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("bELECTRIC","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("TECH_UNIT","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == TECH_UNIT then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("TECH_UNIT","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00E'","MC_BULLET","100","0.5","150","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00E' then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 150
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00E'","MC_BULLET","100","0.5","150","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00F'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00F' then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00F'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00H'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00H' then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00H'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00G'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00G' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00G'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00I'","MC_BULLET","100","0.5","150","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00I' then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 150
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00I'","MC_BULLET","100","0.5","150","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00K'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
elseif ut == 'e00K' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_ACTIVE
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00K'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00L'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
elseif ut == 'e00L' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_ACTIVE
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00L'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'n001'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
elseif ut == 'n001' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_ACTIVE
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'n001'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'h00G'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
elseif ut == 'h00G' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_ACTIVE
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'h00G'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'h009'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
elseif ut == 'h009' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_ACTIVE
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'h009'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'nwgt'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
elseif ut == 'nwgt' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_ACTIVE
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'nwgt'","MC_EFFECT","100","0.5","50","0.01","0","LV_ACTIVE","GROUND_DESTROY")
        endif
        if ut == 'u005' then
            set this.volume = 200
            set this.hardness = 20
        endif
        if ut == 'u006' then
            set this.pushris = 0.5
        endif
        if this.clazz == MC_UNIT then
            set this.deadcnt = 120
        else
            set this.deadcnt = 0
        endif
    endmethod
        
    private method AIDS_onDestroy takes nothing returns nothing
    endmethod
       
    
endstruct

//library Material ends
//library MonsterBonus:
function MonsterBonus takes nothing returns nothing
local integer typeId=GetUnitTypeId(GetTriggerUnit())
local player p=GetOwningPlayer(GetKillingUnitBJ())
local IMonsterTypeData data=DefaultTypeData.findTypeData(typeId)
call AdjustPlayerStateBJ( data.getDeadGold(), p, PLAYER_STATE_RESOURCE_GOLD )
call AdjustPlayerStateBJ( data.getDeadWood(), p, PLAYER_STATE_RESOURCE_LUMBER )
if typeId == 'u007' or typeId == 'u009' then
    call AdjustPlayerStateBJ( 1, p, PLAYER_STATE_RESOURCE_GOLD )
elseif typeId == 'u006' then
    call AdjustPlayerStateBJ( 2, p, PLAYER_STATE_RESOURCE_GOLD )
elseif typeId == 'z002' then
    call AdjustPlayerStateBJ( 1, p, PLAYER_STATE_RESOURCE_GOLD )
elseif typeId == 'z001' then
    call AdjustPlayerStateBJ( 5, p, PLAYER_STATE_RESOURCE_GOLD )
endif
endfunction
function InitMonsterBonus takes nothing returns nothing
call TriggerAddCondition(gtrgMonsterDead,function MonsterBonus)
endfunction

//library MonsterBonus ends
//library Move:
function UpdateBoard takes nothing returns nothing
    set lx = GetRectMinX(area)
    set rx = GetRectMaxX(area)
    set ly = GetRectMinY(area)
    set ry = GetRectMaxY(area)
    set lz = 0
    set rz = 3000
endfunction
function InitMove takes nothing returns nothing
    set area = GetPlayableMapRect()
    call UpdateBoard()
endfunction
function ChangeRect takes rect newrect returns nothing
    set area = newrect
    call UpdateBoard()
endfunction
function MoveUnit takes unit u, real tx, real ty, real tz returns nothing
    local real z = tz - getTerrianHeight(tx, ty)
    local real fz = GetUnitFlyHeight(u)
    if fz > 0 then
        set z = RMaxBJ(0,z)
    endif
    if tx >= rx or tx <= lx or ty >= ry or ty <= ly or tz > rz or z < 0 then
    else
        if IsPointInRegion(playable_region, tx, ty) then
            call SetUnitX(u, tx)
            call SetUnitY(u, ty)
            call SetUnitFlyHeight(u, z, 0)
        endif
    endif
endfunction

//library Move ends
//library PUI:
    //===========================================================================
    //  Allowed PUI_PROPERTY TYPES are: unit, integer, real, boolean, string
    //  Do NOT put handles that need to be destroyed here (timer, trigger, ...)
    //  Instead put them in a struct and use PUI textmacro
    //===========================================================================
    //===========================================================================
    //  Never destroy PUI structs directly.
    //  Use .release() instead, will call .destroy()
    //===========================================================================

//library PUI ends
//library Revive:
function LayDown takes nothing returns nothing
    local real dam=GetEventDamage()
    local unit u=GetTriggerUnit()
    local real l= GetUnitState(u, UNIT_STATE_LIFE)
    if dam + 1 >= l then
        call BJDebugMsg(R2S(dam))
        set l=dam + 1
        call UnitAddAbilityBJ('A02I', u)
        call SetUnitLifeBJ(u, l)
        call GroupAddUnitSimple(u, revgro)
        call EnableTrigger(revtrg)
    endif
    set u=null
endfunction
function LifeLow takes nothing returns nothing
    local unit u = GetTriggerUnit()
    if GetUnitAbilityLevel(u, 'A02H') == 0 then
        call UnitAddAbility(u, 'Avul')
        call NotHealth(GetPlayerId(GetOwningPlayer(u)))
        call UnitAddAbility(u, 'A02H')
        call SetUnitManaBJ(u, 60.0)
        call PauseUnit(u, true)
        call SetUnitAnimationByIndex(u, 3)
        call PauseUnit(u, false)
        set u = null
    endif
endfunction
function RegisterReviveSystem takes unit u returns nothing
    local trigger trg=CreateTrigger()
    local trigger trg2 = CreateTrigger()
    call TriggerRegisterUnitEvent(trg, u, EVENT_UNIT_DAMAGED)
    call TriggerRegisterUnitLifeEvent(trg2, u, LESS_THAN, 2)
    call TriggerAddCondition(trg2, function LifeLow)
    call TriggerRegisterUnitEvent(gg_trg_cantmove, u, EVENT_UNIT_ISSUED_TARGET_ORDER)
    call TriggerRegisterUnitEvent(gg_trg_cantmove, u, EVENT_UNIT_ISSUED_POINT_ORDER)
    call TriggerAddCondition(trg, Condition(function LayDown))
    set trg=null
    set trg2 = null
endfunction
function RemoveNineLifeGroupAction takes nothing returns nothing
    local unit u=GetEnumUnit()
    local real l= GetUnitStateSwap(UNIT_STATE_LIFE, u)
    call UnitRemoveAbilityBJ('A02I', u)
    call SetUnitLifeBJ(u, l)
    call GroupRemoveUnitSimple(u, revgro)
    set u=null
endfunction
function RemoveNineLife takes nothing returns nothing
    call DisableTrigger(GetTriggeringTrigger())
    call ForGroupBJ(revgro, function RemoveNineLifeGroupAction)
endfunction
function InitReviveSystem takes nothing returns nothing
    set revgro=CreateGroup()
    set revtrg=CreateTrigger()
    call TriggerAddAction(revtrg, function RemoveNineLife)
    call TriggerRegisterTimerEventPeriodic(revtrg, 0.00)
endfunction

//library Revive ends
//library SpellStruct:
    //===========================================================================
    // Configurables
    //
    
    //===========================================================================
    // Header Declarations
    //
    
    function interface SpellStruct__Method takes integer this returns nothing
    function interface SpellStruct__UnitMethodFilter takes integer this, unit u returns boolean
    function interface SpellStruct__UnitMethod takes integer this, unit u returns nothing
    function interface SpellStruct__Allocator takes nothing returns integer
    
    //===========================================================================
    // Recursion stack
    //
    module SpellStruct__Stack
        static thistype top=0 // thistype(0) throws a syntax error, does not compile
static method increment takes nothing returns nothing
            set thistype.top=thistype(thistype.top+1)
        endmethod
        static method decrement takes nothing returns nothing
            set thistype.top=thistype(thistype.top-1)
        endmethod
    endmodule
    
    //===========================================================================
    // Defaults
    //
    interface SpellStruct__DefaultsInterface
        // For methods that are not implemented.
        // In order of firing.
        method onCreate takes nothing returns nothing defaults nothing
        method onChannel takes nothing returns nothing defaults nothing
        method onStartCast takes nothing returns nothing defaults nothing
        method onEffect takes nothing returns nothing defaults nothing // May not always fire in casting a given spell.
method onFinish takes nothing returns nothing defaults nothing // May not fire in casting a spell, Blizzard's event response fails.
method onStopCast takes nothing returns nothing defaults nothing // Blizzard's event response sometimes fails.

        method cleanup takes nothing returns nothing defaults nothing
    endinterface
    
    //===========================================================================
    // Event Handlers
    //
    
    
//textmacro instance: SpellStruct__EventResponse("onChannel","OnChannel","true","false")
        function SpellStruct__OnChannel takes nothing returns boolean
            set SpellStruct__CastingAbility=GetSpellAbilityId()
            static if true then
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,SpellStruct__ALLOCATOR))
                if SpellStruct__ThisCastData==0 then
                    return false
                endif
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(SpellStruct__Allocator(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,SpellStruct__ALLOCATOR)).evaluate())
                call SaveInteger(SpellStruct__STORE,SpellStruct__CastingAbility,GetHandleId(GetTriggerUnit()),SpellStruct__ThisCastData)
            else
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,GetHandleId(GetTriggerUnit())))
            endif
            //call BJDebugMsg("OnChannel - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct__ThisCastData!=0 then
                call SpellStruct__ThisCastData.onChannel.execute()
                static if false then
                    call SpellStruct__ThisCastData.cleanup.evaluate()
                endif
            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onChannel","OnChannel","true","false")
//textmacro instance: SpellStruct__EventResponse("onStartCast","OnStartCast","false","false")
        function SpellStruct__OnStartCast takes nothing returns boolean
            set SpellStruct__CastingAbility=GetSpellAbilityId()
            static if false then
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,SpellStruct__ALLOCATOR))
                if SpellStruct__ThisCastData==0 then
                    return false
                endif
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(SpellStruct__Allocator(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,SpellStruct__ALLOCATOR)).evaluate())
                call SaveInteger(SpellStruct__STORE,SpellStruct__CastingAbility,GetHandleId(GetTriggerUnit()),SpellStruct__ThisCastData)
            else
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,GetHandleId(GetTriggerUnit())))
            endif
            //call BJDebugMsg("OnStartCast - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct__ThisCastData!=0 then
                call SpellStruct__ThisCastData.onStartCast.execute()
                static if false then
                    call SpellStruct__ThisCastData.cleanup.evaluate()
                endif
            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onStartCast","OnStartCast","false","false")
//textmacro instance: SpellStruct__EventResponse("onEffect","OnEffect","false","false")
        function SpellStruct__OnEffect takes nothing returns boolean
            set SpellStruct__CastingAbility=GetSpellAbilityId()
            static if false then
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,SpellStruct__ALLOCATOR))
                if SpellStruct__ThisCastData==0 then
                    return false
                endif
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(SpellStruct__Allocator(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,SpellStruct__ALLOCATOR)).evaluate())
                call SaveInteger(SpellStruct__STORE,SpellStruct__CastingAbility,GetHandleId(GetTriggerUnit()),SpellStruct__ThisCastData)
            else
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,GetHandleId(GetTriggerUnit())))
            endif
            //call BJDebugMsg("OnEffect - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct__ThisCastData!=0 then
                call SpellStruct__ThisCastData.onEffect.execute()
                static if false then
                    call SpellStruct__ThisCastData.cleanup.evaluate()
                endif
            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onEffect","OnEffect","false","false")
//textmacro instance: SpellStruct__EventResponse("onFinish","OnFinish","false","false")
        function SpellStruct__OnFinish takes nothing returns boolean
            set SpellStruct__CastingAbility=GetSpellAbilityId()
            static if false then
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,SpellStruct__ALLOCATOR))
                if SpellStruct__ThisCastData==0 then
                    return false
                endif
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(SpellStruct__Allocator(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,SpellStruct__ALLOCATOR)).evaluate())
                call SaveInteger(SpellStruct__STORE,SpellStruct__CastingAbility,GetHandleId(GetTriggerUnit()),SpellStruct__ThisCastData)
            else
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,GetHandleId(GetTriggerUnit())))
            endif
            //call BJDebugMsg("OnFinish - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct__ThisCastData!=0 then
                call SpellStruct__ThisCastData.onFinish.execute()
                static if false then
                    call SpellStruct__ThisCastData.cleanup.evaluate()
                endif
            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onFinish","OnFinish","false","false")
//textmacro instance: SpellStruct__EventResponse("onStopCast","OnStopCast","false","true")
        function SpellStruct__OnStopCast takes nothing returns boolean
            set SpellStruct__CastingAbility=GetSpellAbilityId()
            static if false then
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,SpellStruct__ALLOCATOR))
                if SpellStruct__ThisCastData==0 then
                    return false
                endif
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(SpellStruct__Allocator(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,SpellStruct__ALLOCATOR)).evaluate())
                call SaveInteger(SpellStruct__STORE,SpellStruct__CastingAbility,GetHandleId(GetTriggerUnit()),SpellStruct__ThisCastData)
            else
                set SpellStruct__ThisCastData=SpellStruct__DefaultsInterface(LoadInteger(SpellStruct__STORE,SpellStruct__CastingAbility,GetHandleId(GetTriggerUnit())))
            endif
            //call BJDebugMsg("OnStopCast - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct__ThisCastData!=0 then
                call SpellStruct__ThisCastData.onStopCast.execute()
                static if true then
                    call SpellStruct__ThisCastData.cleanup.evaluate()
                endif
            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onStopCast","OnStopCast","false","true")
    
    //===========================================================================
    // Attachment.
    //
    struct SpellStruct__ChainAttach
        trigger trigger
        timer timer
        integer instance
        SpellStruct__Method callback
        thistype next
        thistype prev
    endstruct
    
    //===========================================================================
    // Timers (requires Attachment).
    //
    function SpellStruct__SetTimerStruct takes timer t, integer data returns nothing
        static if LIBRARY_TimerUtils then
            call SetTimerData(t,data)
        else
            call SaveInteger(SpellStruct__STORE,GetHandleId(t),SpellStruct__TIMER_DATA,data)
        endif
    endfunction
    function SpellStruct__GetTimerStruct takes timer t returns integer
        static if LIBRARY_TimerUtils then
            return GetTimerData(t)
        else
            return LoadInteger(SpellStruct__STORE,GetHandleId(t),SpellStruct__TIMER_DATA)
        endif
    endfunction
    
    //===========================================================================
    // Triggers (requires Attachment).
    //
    function SpellStruct__SetTriggerStruct takes trigger t, integer data returns nothing
        call SaveInteger(SpellStruct__STORE,GetHandleId(t),SpellStruct__TRIGGER_DATA,data)
    endfunction
    function SpellStruct__GetTriggerStruct takes trigger t returns integer
        return LoadInteger(SpellStruct__STORE,GetHandleId(t),SpellStruct__TRIGGER_DATA)
    endfunction
    
    //===========================================================================
    // AoE enumeration.
    //
    struct SpellStruct__EnumStack extends array
        implement SpellStruct__Stack
        integer instance
        real x
        real y
        real range
        integer callback
        group for
    endstruct
    function SpellStruct__InternalEnum takes nothing returns boolean // Could be recursive.
local unit u=GetFilterUnit() // can't be a global due to recursion.
if IsUnitInRangeXY(u,SpellStruct__EnumStack.top.x,SpellStruct__EnumStack.top.y,SpellStruct__EnumStack.top.range) then // Factors in collision sizes.
if SpellStruct__UnitMethodFilter(SpellStruct__EnumStack.top.callback).evaluate(SpellStruct__EnumStack.top.instance,u) then
                call GroupAddUnit(SpellStruct__EnumStack.top.for,u)
            endif
        endif
        set u=null
        return false
    endfunction
    function SpellStruct__InternalFor takes nothing returns boolean // Could be recursive.
local unit u=GetFilterUnit() // can't be a global due to recursion.
if IsUnitInRangeXY(u,SpellStruct__EnumStack.top.x,SpellStruct__EnumStack.top.y,SpellStruct__EnumStack.top.range) then // Factors in collision sizes.
call SpellStruct__UnitMethod(SpellStruct__EnumStack.top.callback).execute(SpellStruct__EnumStack.top.instance,u)
        endif
        set u=null
        return false
    endfunction
    
    //===========================================================================
    // Exposed Interface - SpellStruct
    //
    struct SpellStruct extends SpellStruct__DefaultsInterface
        //===========================================================================
        // Various Spell-based Methods.
        //
        method getDistanceToTargetWidget takes nothing returns real
            local real x=GetWidgetX(this.targetWidget)-this.casterX
            local real y=GetWidgetY(this.targetWidget)-this.casterY
            return SquareRoot(x*x+y*y)
        endmethod
        method getDistanceToTargetPoint takes nothing returns real
            local real x=this.targetX-this.casterX
            local real y=this.targetY-this.casterY
            return SquareRoot(x*x+y*y)
        endmethod
        method getAngleToTargetWidget takes nothing returns real // radians.
return Atan2(GetWidgetY(this.targetWidget)-this.casterY,GetWidgetX(this.targetWidget)-this.casterX)
        endmethod
        method getAngleToTargetPoint takes nothing returns real // radians.
return Atan2(this.targetY-this.casterY,this.targetX-this.casterX)
        endmethod
        
        //===========================================================================
        // ForGroup.
        //
        private static method forGroupCallback takes nothing returns nothing
            call SpellStruct__UnitMethod(SpellStruct__EnumStack.top.callback).execute(SpellStruct__EnumStack.top.instance,GetEnumUnit()) // bigger crimes have been committed, but not much bigger.
endmethod
        method forGroup takes group g, SpellStruct__UnitMethod callback returns nothing
            call SpellStruct__EnumStack.increment() // just borrowing that stack... would break if event reponses accessed the stack directly, but they don't.
set SpellStruct__EnumStack.top.instance=this
            set SpellStruct__EnumStack.top.callback=callback
            call ForGroup(g,function thistype.forGroupCallback)
            call SpellStruct__EnumStack.decrement()
        endmethod
        
        //===========================================================================
        // AoE enumeration.
        //
        real aoe
        
        method enumUnitsInAoE takes group whichGroup, SpellStruct__UnitMethodFilter filter returns nothing 
            call SpellStruct__EnumStack.increment()
            set SpellStruct__EnumStack.top.instance=this
            set SpellStruct__EnumStack.top.x=this.targetX
            set SpellStruct__EnumStack.top.y=this.targetY
            set SpellStruct__EnumStack.top.range=this.aoe
            set SpellStruct__EnumStack.top.callback=filter
            set SpellStruct__EnumStack.top.for=whichGroup
            call GroupEnumUnitsInRange(SpellStruct__GROUP,SpellStruct__EnumStack.top.x,SpellStruct__EnumStack.top.y,SpellStruct__EnumStack.top.range+SpellStruct__MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct__InternalEnum))
            call SpellStruct__EnumStack.decrement()
        endmethod
        
        method enumUnitsInAoETarget takes group whichGroup, SpellStruct__UnitMethodFilter filter returns nothing 
            call SpellStruct__EnumStack.increment()
            set SpellStruct__EnumStack.top.instance=this
            set SpellStruct__EnumStack.top.x=GetWidgetX(this.targetWidget)
            set SpellStruct__EnumStack.top.y=GetWidgetY(this.targetWidget)
            set SpellStruct__EnumStack.top.range=this.aoe
            set SpellStruct__EnumStack.top.callback=filter
            set SpellStruct__EnumStack.top.for=whichGroup
            call GroupEnumUnitsInRange(SpellStruct__GROUP,SpellStruct__EnumStack.top.x,SpellStruct__EnumStack.top.y,SpellStruct__EnumStack.top.range+SpellStruct__MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct__InternalEnum))
            call SpellStruct__EnumStack.decrement()
        endmethod
        
        method enumUnitsInAoECaster takes group whichGroup, SpellStruct__UnitMethodFilter filter returns nothing 
            call SpellStruct__EnumStack.increment()
            set SpellStruct__EnumStack.top.instance=this
            set SpellStruct__EnumStack.top.x=GetUnitX(this.caster)
            set SpellStruct__EnumStack.top.y=GetUnitY(this.caster)
            set SpellStruct__EnumStack.top.range=this.aoe
            set SpellStruct__EnumStack.top.callback=filter
            set SpellStruct__EnumStack.top.for=whichGroup
            call GroupEnumUnitsInRange(SpellStruct__GROUP,SpellStruct__EnumStack.top.x,SpellStruct__EnumStack.top.y,SpellStruct__EnumStack.top.range+SpellStruct__MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct__InternalEnum))
            call SpellStruct__EnumStack.decrement()
        endmethod
        
        method forUnitsInAoE takes SpellStruct__UnitMethod callback returns nothing 
            call SpellStruct__EnumStack.increment()
            set SpellStruct__EnumStack.top.instance=this
            set SpellStruct__EnumStack.top.x=this.targetX
            set SpellStruct__EnumStack.top.y=this.targetY
            set SpellStruct__EnumStack.top.range=this.aoe
            set SpellStruct__EnumStack.top.callback=callback
            call GroupEnumUnitsInRange(SpellStruct__GROUP,SpellStruct__EnumStack.top.x,SpellStruct__EnumStack.top.y,SpellStruct__EnumStack.top.range+SpellStruct__MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct__InternalFor))
            call SpellStruct__EnumStack.decrement()
        endmethod
        
        method forUnitsInAoETarget takes SpellStruct__UnitMethod callback returns nothing 
            call SpellStruct__EnumStack.increment()
            set SpellStruct__EnumStack.top.instance=this
            set SpellStruct__EnumStack.top.x=GetWidgetX(this.targetWidget)
            set SpellStruct__EnumStack.top.y=GetWidgetY(this.targetWidget)
            set SpellStruct__EnumStack.top.range=this.aoe
            set SpellStruct__EnumStack.top.callback=callback
            call GroupEnumUnitsInRange(SpellStruct__GROUP,SpellStruct__EnumStack.top.x,SpellStruct__EnumStack.top.y,SpellStruct__EnumStack.top.range+SpellStruct__MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct__InternalFor))
            call SpellStruct__EnumStack.decrement()
        endmethod
        
        method forUnitsInAoECaster takes SpellStruct__UnitMethod callback returns nothing 
            call SpellStruct__EnumStack.increment()
            set SpellStruct__EnumStack.top.instance=this
            set SpellStruct__EnumStack.top.x=GetUnitX(this.caster)
            set SpellStruct__EnumStack.top.y=GetUnitY(this.caster)
            set SpellStruct__EnumStack.top.range=this.aoe
            set SpellStruct__EnumStack.top.callback=callback
            call GroupEnumUnitsInRange(SpellStruct__GROUP,SpellStruct__EnumStack.top.x,SpellStruct__EnumStack.top.y,SpellStruct__EnumStack.top.range+SpellStruct__MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct__InternalFor))
            call SpellStruct__EnumStack.decrement()
        endmethod
        
        method isUnitInAoE takes unit u returns boolean
            return IsUnitInRangeXY(u,this.targetX,this.targetY,this.aoe)
        endmethod
        method isUnitInAoETarget takes unit u returns boolean
            return IsUnitInRangeXY(u,GetWidgetX(this.targetWidget),GetWidgetY(this.targetWidget),this.aoe)
        endmethod
        method isUnitInAoECaster takes unit u returns boolean
            return IsUnitInRangeXY(u,GetUnitX(this.caster),GetUnitY(this.caster),this.aoe)
        endmethod
        
        //===========================================================================
        // Auto Cleanup.
        //
        private boolean doAutoDestroy // set in module's create method.
boolean hasStoppedCasting=false
        method operator autoDestroy= takes boolean flag returns nothing
            if flag then
                if this.hasStoppedCasting and this.isNotLocked then
                    set this.hasStoppedCasting=false // double free safety
call this.destroy()
                else
                    set this.doAutoDestroy=true
                endif
            else
                set this.doAutoDestroy=false
            endif
        endmethod
        method operator autoDestroy takes nothing returns boolean
            return this.doAutoDestroy
        endmethod
        
        //===========================================================================
        // Locking.
        //
        private integer lockLevel=0
        method operator isLocked takes nothing returns boolean
            return this.lockLevel>0
        endmethod
        method operator isNotLocked takes nothing returns boolean
            return this.lockLevel==0
        endmethod
        method addLock takes nothing returns nothing
            set this.lockLevel=this.lockLevel+1
        endmethod
        method removeLock takes nothing returns nothing
            set this.lockLevel=this.lockLevel-1
            if this.hasStoppedCasting and this.isNotLocked and this.doAutoDestroy then
                set this.hasStoppedCasting=false // double free safety
call this.destroy()
            endif
        endmethod
        
        //===========================================================================
        // Attachment.
        //
        private static SpellStruct__ChainAttach attachNode
        private static SpellStruct__ChainAttach attachHead
        
        
        
        
        //===========================================================================
        // Timers (requires Locking).
        //
        private SpellStruct__ChainAttach timerAttachments
        private static method timerCallback takes nothing returns nothing
            set thistype.attachNode=SpellStruct__GetTimerStruct(GetExpiredTimer()) // first time since h2i/gamecache I've needed this.
call thistype.attachNode.callback.execute(thistype.attachNode.instance) // good reason to use T32 instead.
// cannot use thistype.attachNode anymore, value may have changed.
endmethod
        method startTimer takes SpellStruct__Method callback, real period returns nothing
            // Make node and attach data.
//textmacro instance: SpellStruct__CreateAttachmentNode("this.timerAttachments")
            // Create node.
            set thistype.attachNode=SpellStruct__ChainAttach.create()
            // Link node (at end of list).
            set thistype.attachHead=this.timerAttachments
            set thistype.attachHead.prev.next=thistype.attachNode
            set thistype.attachNode.prev=thistype.attachHead.prev
            set thistype.attachHead.prev=thistype.attachNode
            set thistype.attachNode.next=thistype.attachHead
//end of: SpellStruct__CreateAttachmentNode("this.timerAttachments")
            set thistype.attachNode.instance=this
            set thistype.attachNode.callback=callback
            // Create timer and attach data.
//textmacro instance: SpellStruct__GetTimer("thistype.attachNode.timer")
        static if LIBRARY_TimerUtils then
            set thistype.attachNode.timer=NewTimer()
        elseif LIBRARY_Recycle then
            set thistype.attachNode.timer=Timer.get()
        else
            set thistype.attachNode.timer=CreateTimer()
        endif
//end of: SpellStruct__GetTimer("thistype.attachNode.timer")
            call SpellStruct__SetTimerStruct(thistype.attachNode.timer,thistype.attachNode)
            // Attach node to struct/method.
            call SaveInteger(SpellStruct__STORE,this,callback,thistype.attachNode)
            // Start timer.
            call TimerStart(thistype.attachNode.timer,period,true,function thistype.timerCallback)
            call this.addLock()
        endmethod
        method stopTimer takes SpellStruct__Method callback returns nothing
            set thistype.attachNode=SpellStruct__ChainAttach(LoadInteger(SpellStruct__STORE,this,callback))
            // Unchain attachment
            set thistype.attachNode.next.prev=thistype.attachNode.prev
            set thistype.attachNode.prev.next=thistype.attachNode.next
            // Release Timer.
//textmacro instance: SpellStruct__ReleaseTimer("thistype.attachNode.timer")
        static if LIBRARY_TimerUtils then
            call ReleaseTimer(thistype.attachNode.timer)
        elseif LIBRARY_Recycle then
            call RemoveSavedInteger(SpellStruct__STORE,GetHandleId(thistype.attachNode.timer),SpellStruct__TIMER_DATA)
            call Timer.release(thistype.attachNode.timer)
        else
            call RemoveSavedInteger(SpellStruct__STORE,GetHandleId(thistype.attachNode.timer),SpellStruct__TIMER_DATA)
            call PauseTimer(thistype.attachNode.timer)
            call DestroyTimer(thistype.attachNode.timer)
            //set thistype.attachNode.timer=null // using globals, unnecessary.
        endif
//end of: SpellStruct__ReleaseTimer("thistype.attachNode.timer")
            call RemoveSavedInteger(SpellStruct__STORE,this,callback)
            call this.removeLock()
        endmethod
        
        //===========================================================================
        // Triggers (requires Locking).
        //
        private SpellStruct__ChainAttach triggerAttachments
        private static method triggerCallback takes nothing returns boolean
            set thistype.attachNode=SpellStruct__GetTriggerStruct(GetTriggeringTrigger()) // first time since h2i/gamecache I've needed this.
call thistype.attachNode.callback.execute(thistype.attachNode.instance) // good reason to use T32 instead.
// cannot use thistype.attachNode anymore, value may have changed.
return false
        endmethod
        method createTrigger takes SpellStruct__Method callback returns trigger
            // Make node and attach data.
//textmacro instance: SpellStruct__CreateAttachmentNode("this.triggerAttachments")
            // Create node.
            set thistype.attachNode=SpellStruct__ChainAttach.create()
            // Link node (at end of list).
            set thistype.attachHead=this.triggerAttachments
            set thistype.attachHead.prev.next=thistype.attachNode
            set thistype.attachNode.prev=thistype.attachHead.prev
            set thistype.attachHead.prev=thistype.attachNode
            set thistype.attachNode.next=thistype.attachHead
//end of: SpellStruct__CreateAttachmentNode("this.triggerAttachments")
            set thistype.attachNode.instance=this
            set thistype.attachNode.callback=callback
            // Create timer and attach data.
            set thistype.attachNode.trigger=CreateTrigger()
            call SpellStruct__SetTriggerStruct(thistype.attachNode.trigger,thistype.attachNode)
            // Attach node to struct/method.
            call SaveInteger(SpellStruct__STORE,this,callback,thistype.attachNode)
            // Init trigger.
            call TriggerAddCondition(thistype.attachNode.trigger,Filter(function thistype.triggerCallback))
            call this.addLock()
            return thistype.attachNode.trigger
        endmethod
        method destroyTrigger takes SpellStruct__Method callback returns nothing
            set thistype.attachNode=SpellStruct__ChainAttach(LoadInteger(SpellStruct__STORE,this,callback))
            // Unchain attachment
            set thistype.attachNode.next.prev=thistype.attachNode.prev
            set thistype.attachNode.prev.next=thistype.attachNode.next
            // Destroy trigger
//textmacro instance: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
        call RemoveSavedInteger(SpellStruct__STORE,GetHandleId(thistype.attachNode.trigger),SpellStruct__TRIGGER_DATA)
//end of: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
            call DestroyTrigger(thistype.attachNode.trigger)
            call RemoveSavedInteger(SpellStruct__STORE,this,callback)
            call this.removeLock()
        endmethod
        
        //===========================================================================
        // Event responses.
        //
        readonly integer abilId
        readonly unit caster
        readonly integer level
        readonly integer order
        readonly unit targetUnit
        readonly widget targetWidget
        readonly destructable targetDest
        readonly item targetItem
        readonly location targetLoc
        readonly real targetX // for target point of AoE spells.
readonly real targetY // for target point of AoE spells.
readonly player owner
        
        method operator casterX takes nothing returns real
            return GetUnitX(this.caster)
        endmethod
        method operator casterY takes nothing returns real
            return GetUnitY(this.caster)
        endmethod
        
        private static location loc
        static method create takes nothing returns thistype
            local thistype this=thistype.allocate()
            
            //===========================================================================
            // Event responses.
            //
            set this.abilId=GetSpellAbilityId()
            set this.caster=GetTriggerUnit()
            set this.owner=GetOwningPlayer(this.caster)
            set this.level=GetUnitAbilityLevel(this.caster,this.abilId)
            set this.order=GetUnitCurrentOrder(this.caster)
            // Target stuff
            set this.targetUnit=GetSpellTargetUnit()
            if this.targetUnit==null then
                set this.targetDest=GetSpellTargetDestructable()
                if this.targetDest==null then
                    set this.targetItem=GetSpellTargetItem()
                    if this.targetItem==null then
                        set this.targetWidget=null
                        set thistype.loc=GetSpellTargetLoc()
                        if thistype.loc==null then
                            set this.targetX=GetUnitX(this.caster)
                            set this.targetY=GetUnitY(this.caster)
                        else
                            set this.targetX=GetLocationX(thistype.loc)
                            set this.targetY=GetLocationY(thistype.loc)
                            call RemoveLocation(thistype.loc)
                            set thistype.loc=null // worthwhile
endif
                    else
                        set this.targetWidget=this.targetItem
                        set this.targetX=GetItemX(this.targetItem)
                        set this.targetY=GetItemY(this.targetItem)
                    endif
                else
                    set this.targetWidget=this.targetDest
                    set this.targetItem=null
                    set this.targetX=GetWidgetX(this.targetDest) // shorter
set this.targetY=GetWidgetY(this.targetDest)
                endif
            else
                set this.targetWidget=this.targetUnit
                set this.targetDest=null
                set this.targetItem=null
                set this.targetX=GetUnitX(this.targetUnit)
                set this.targetY=GetUnitY(this.targetUnit)
            endif
            
            //===========================================================================
            // Attachment (timer & trigger).
            //
//textmacro instance: SpellStruct__CreateAttachmentHead()
            set thistype.attachHead=SpellStruct__ChainAttach.create()
            set thistype.attachHead.next=thistype.attachHead
            set thistype.attachHead.prev=thistype.attachHead
//end of: SpellStruct__CreateAttachmentHead()
            set this.timerAttachments=thistype.attachHead
//textmacro instance: SpellStruct__CreateAttachmentHead()
            set thistype.attachHead=SpellStruct__ChainAttach.create()
            set thistype.attachHead.next=thistype.attachHead
            set thistype.attachHead.prev=thistype.attachHead
//end of: SpellStruct__CreateAttachmentHead()
            set this.triggerAttachments=thistype.attachHead
            
            return this
        endmethod
        
        method destroy takes nothing returns nothing
            if this.hasStoppedCasting then
                set this.hasStoppedCasting=false // random double free protection on autoDestroy stuff.
else
                call RemoveSavedInteger(SpellStruct__STORE,this.abilId,GetHandleId(this.caster))
            endif
            
            //===========================================================================
            // Timers
            //
//textmacro instance: SpellStruct__AttachmentChainLoop("this.timerAttachments")
            set thistype.attachHead=this.timerAttachments
            set thistype.attachNode=thistype.attachHead.next
            loop
                exitwhen thistype.attachNode==thistype.attachHead
//end of: SpellStruct__AttachmentChainLoop("this.timerAttachments")
//textmacro instance: SpellStruct__ReleaseTimer("thistype.attachNode.timer")
        static if LIBRARY_TimerUtils then
            call ReleaseTimer(thistype.attachNode.timer)
        elseif LIBRARY_Recycle then
            call RemoveSavedInteger(SpellStruct__STORE,GetHandleId(thistype.attachNode.timer),SpellStruct__TIMER_DATA)
            call Timer.release(thistype.attachNode.timer)
        else
            call RemoveSavedInteger(SpellStruct__STORE,GetHandleId(thistype.attachNode.timer),SpellStruct__TIMER_DATA)
            call PauseTimer(thistype.attachNode.timer)
            call DestroyTimer(thistype.attachNode.timer)
            //set thistype.attachNode.timer=null // using globals, unnecessary.
        endif
//end of: SpellStruct__ReleaseTimer("thistype.attachNode.timer")
                call RemoveSavedInteger(SpellStruct__STORE,this,thistype.attachNode.callback)
//textmacro instance: SpellStruct__AttachmentChainEndloop()
                set thistype.attachNode=thistype.attachNode.next
            endloop
//end of: SpellStruct__AttachmentChainEndloop()
            call this.timerAttachments.destroy()
            
            //===========================================================================
            // Triggers
            //
//textmacro instance: SpellStruct__AttachmentChainLoop("this.triggerAttachments")
            set thistype.attachHead=this.triggerAttachments
            set thistype.attachNode=thistype.attachHead.next
            loop
                exitwhen thistype.attachNode==thistype.attachHead
//end of: SpellStruct__AttachmentChainLoop("this.triggerAttachments")
//textmacro instance: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
        call RemoveSavedInteger(SpellStruct__STORE,GetHandleId(thistype.attachNode.trigger),SpellStruct__TRIGGER_DATA)
//end of: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
                call DestroyTrigger(thistype.attachNode.trigger)
                call RemoveSavedInteger(SpellStruct__STORE,this,thistype.attachNode.callback)
//textmacro instance: SpellStruct__AttachmentChainEndloop()
                set thistype.attachNode=thistype.attachNode.next
            endloop
//end of: SpellStruct__AttachmentChainEndloop()
            call this.triggerAttachments.destroy()
            
            call this.deallocate()
        endmethod
    endstruct
    
    //===========================================================================
    // Exposed Module - SpellStruct
    //
    module SpellStruct
        //===========================================================================
        // AoE enumeration.
        //
        static real defaultAoE=0.
        
        //===========================================================================
        // Setting up the struct.
        //
        private static integer currentAbil=0
        static method operator abil= takes integer abilId returns nothing
            if thistype.currentAbil!=0 then
                call RemoveSavedInteger(SpellStruct__STORE,thistype.currentAbil,SpellStruct__ALLOCATOR)
            endif
            set thistype.currentAbil=abilId
            if abilId!=0 then
                call SaveInteger(SpellStruct__STORE,abilId,SpellStruct__ALLOCATOR,thistype.create)
            endif
        endmethod
        static method operator abil takes nothing returns integer
            return thistype.currentAbil
        endmethod
        
        //===========================================================================
        // Auto Cleanup.
        //
        private static boolean doAutoDestroyDefault=true
        static method operator autoDestroyDefault= takes boolean flag returns nothing
            set thistype.doAutoDestroyDefault=flag
        endmethod
        static method operator autoDestroyDefault takes nothing returns boolean
            return thistype.doAutoDestroyDefault
        endmethod
        method cleanup takes nothing returns nothing // only runs if not destroyed
call RemoveSavedInteger(SpellStruct__STORE,this.abilId,GetHandleId(this.caster))
            set this.hasStoppedCasting=true // can't be readonly because of this.
if this.autoDestroy and this.isNotLocked then
                call SpellStruct(this).destroy() // Jasshelper bug? Had to typecast "this".
endif
        endmethod
        
        //===========================================================================
        // Struct Allocation.
        //
        private static method create takes nothing returns thistype
            local thistype this=thistype.allocate()
            // General stuff
            set this.autoDestroy=thistype.autoDestroyDefault
            set this.aoe=thistype.defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call this.onCreate.evaluate() // in case of thread terminate
//endif
return this
        endmethod
    endmodule
    
    //===========================================================================
    // Init
    //
    struct SpellStruct__Init extends array
        private static method onInit takes nothing returns nothing
            //===========================================================================
            // Event Responses
            //
            local trigger t
            
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CHANNEL","OnChannel")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_CHANNEL)
                call TriggerAddCondition(t,Filter(function SpellStruct__OnChannel))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CHANNEL","OnChannel")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CAST","OnStartCast")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_CAST)
                call TriggerAddCondition(t,Filter(function SpellStruct__OnStartCast))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CAST","OnStartCast")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_EFFECT","OnEffect")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_EFFECT)
                call TriggerAddCondition(t,Filter(function SpellStruct__OnEffect))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_EFFECT","OnEffect")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_FINISH","OnFinish")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_FINISH)
                call TriggerAddCondition(t,Filter(function SpellStruct__OnFinish))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_FINISH","OnFinish")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_ENDCAST","OnStopCast")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_ENDCAST)
                call TriggerAddCondition(t,Filter(function SpellStruct__OnStopCast))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_ENDCAST","OnStopCast")
            
            set t=null
        endmethod
    endstruct

//library SpellStruct ends
//library Status:
    
    native UnitAlive takes unit id returns boolean
    
    module Status___PreloadModule
        private static method onInit takes nothing returns nothing
            local unit u=CreateUnit(Status___DUMMY_CASTER_OWNER,DUMMY_TYPE,0,0,0)
            local integer abil
            call UnitAddAbility(u,Status___ABIL_INVISIBLE)
            call UnitAddAbility(u,Status___ABIL_GHOST)
            call UnitAddAbility(u,Status___ABIL_IMMUNITY)
            call UnitAddAbility(u,Status___ABIL_UNLOCUST)
            call UnitAddAbility(u,Status___ABIL_NEVER_MISS)
            call UnitAddAbility(u,Status___ABIL_ALWAYS_MISS)
            call UnitAddAbility(u,Status___ABIL_UNTOUCHABLE)
            call UnitAddAbility(u,Status___ABIL_PHASE)
            call UnitAddAbility(u,ABIL_DOUBLE_ATTACK)
            call UnitAddAbility(u,Status___ABIL_RESISTANT_SKIN)
            call UnitAddAbility(u,Status___ABIL_REFLECT_PIERCING)
//textmacro instance: Status__PreloadBonus("ARMOR")
                set abil=Status___ABIL_ARMOR+Status___LEVELS_ARMOR
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_ARMOR
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("ARMOR")
//textmacro instance: Status__PreloadBonus("DAMAGE")
                set abil=Status___ABIL_DAMAGE+Status___LEVELS_DAMAGE
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_DAMAGE
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("DAMAGE")
//textmacro instance: Status__PreloadBonus("STR")
                set abil=Status___ABIL_STR+Status___LEVELS_STR
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_STR
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("STR")
//textmacro instance: Status__PreloadBonus("AGI")
                set abil=Status___ABIL_AGI+Status___LEVELS_AGI
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_AGI
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("AGI")
//textmacro instance: Status__PreloadBonus("INT")
                set abil=Status___ABIL_INT+Status___LEVELS_INT
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_INT
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("INT")
//textmacro instance: Status__PreloadBonus("ATTACK_SPEED")
                set abil=Status___ABIL_ATTACK_SPEED+Status___LEVELS_ATTACK_SPEED
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_ATTACK_SPEED
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("ATTACK_SPEED")
//textmacro instance: Status__PreloadBonus("HEALTH")
                set abil=Status___ABIL_HEALTH+Status___LEVELS_HEALTH
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_HEALTH
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("HEALTH")
//textmacro instance: Status__PreloadBonus("MANA")
                set abil=Status___ABIL_MANA+Status___LEVELS_MANA
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_MANA
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("MANA")
            call KillUnit(u)
            call RemoveUnit(u)
            set u=null
        endmethod
    endmodule
    
    module Status___StaticPeriodic
        private static method onInit takes nothing returns nothing
            call TimerStart(CreateTimer(),Status___PERIOD,true,function thistype.periodicLink)
        endmethod
    endmodule
    
    module Status___StatusInit
        private static method onInit takes nothing returns nothing
            local integer i
            set thistype.dummyCaster=CreateUnit(Status___DUMMY_CASTER_OWNER,DUMMY_TYPE,0,0,0)
            set thistype.dummyCaster2=CreateUnit(Status___DUMMY_CASTER_OWNER,DUMMY_TYPE,0,0,0)
            set thistype.dummyCaster3=CreateUnit(Status___DUMMY_CASTER_OWNER,DUMMY_TYPE,0,0,0)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_STUN)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_DISABLE)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_SILENCE)
            set Status___CASTER_DISARM_BOTH=thistype.dummyCaster
            set Status___CASTER_DISARM_MELEE=thistype.dummyCaster2
            set Status___CASTER_DISARM_RANGE=thistype.dummyCaster3
            call UnitAddAbility(Status___CASTER_DISARM_BOTH,Status___ABIL_DISARM_BOTH)
            call UnitAddAbility(Status___CASTER_DISARM_MELEE,Status___ABIL_DISARM_MELEE)
            call UnitAddAbility(Status___CASTER_DISARM_RANGE,Status___ABIL_DISARM_RANGE)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_IMMOBOLISE)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_DOOM)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_HEX)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_BANISH)
            set i=bj_MAX_PLAYERS
            loop
                set i=i-1
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_IMMUNITY,false)
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_NEVER_MISS,false)
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_ALWAYS_MISS,false)
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_UNTOUCHABLE,false)
                //call SetPlayerAbilityAvailable(Player(i),ABIL_DOUBLE_ATTACK,false)
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_RESISTANT_SKIN,false)
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_REFLECT_PIERCING,false)
                exitwhen i==0
            endloop
        endmethod
    endmodule
    
    module Status___TwoPowArray
        readonly static integer array twoPow
        private static method onInit takes nothing returns nothing
            local integer i=0
            local integer val=1
            loop
                set thistype.twoPow[i]=val // thistype.twoPow[0]=1
exitwhen i==30
                set i=i+1
                set val=val*2
            endloop
        endmethod
    endmodule
    
    struct Status extends array
        private method AIDS_onCreate takes nothing returns nothing
            static if Status___PERMENANTLY_REVEAL then
                call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
            endif
            
            set this.disableLevel=0
            set this.stunLevel=0
            set this.silenceLevel=0
            set this.doomLevel=0
            set this.disarmMeleeLevel=0
            set this.disarmRangeLevel=0
            set this.immoboliseLevel=0
            set this.invisibleLevel=0
            set this.ghostLevel=0
            set this.invulnerableLevel=0
            set this.immunityLevel=0
            set this.pauseLevel=0
            set this.hideLevel=0
            set this.unpathLevel=0
            set this.hexLevel=0
            set this.locustLevel=0
            set this.neverMissLevel=0
            set this.alwaysMissLevel=0
            set this.untouchableLevel=0
            set this.banishLevel=0
            set this.phaseLevel=0
            set this.resistantSkinLevel=0
            set this.reflectPiercingLevel=0
            
            set this.armorBonus=0
            set this.damageBonus=0
            set this.strBonus=0
            set this.agiBonus=0
            set this.intBonus=0
            set this.attackSpeedBonus=0
            set this.healthBonus=0
            set this.manaBonus=0
            set this.healthRegenBonus=0
            set this.manaRegenBonus=0
            set this.healthRegenPercentBonus=0
            set this.manaRegenPercentBonus=0
            
            set this.moveSpeedBonus=0.0
            set this.moveSpeedPercentBonus=0.0
            call this.stopPeriodic()
        endmethod
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()
        private static unit dummyCaster=null
        private static unit dummyCaster2=null
        private static unit dummyCaster3=null
        
        implement Status___StatusInit
        implement Status___TwoPowArray
        
        ////////////////////
        // Status Effects //
        ////////////////////
        
        // Stun
        private integer stunLevel
        method addStun takes nothing returns nothing
            set this.stunLevel=this.stunLevel+1
            if this.stunLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_STUN,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeStun takes nothing returns nothing
            set this.stunLevel=this.stunLevel-1
            if this.stunLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_STUN)
            endif
        endmethod
        method isStunned takes nothing returns boolean
            return this.stunLevel>0
        endmethod
        
        // Disable
        private integer disableLevel
        method addDisable takes nothing returns nothing
            set this.disableLevel=this.disableLevel+1
            if this.disableLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_DISABLE,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeDisable takes nothing returns nothing
            set this.disableLevel=this.disableLevel-1
            if this.disableLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_DISABLE)
            endif
        endmethod
        method isDisabled takes nothing returns boolean
            return this.disableLevel>0
        endmethod
        
        // Silence
        private integer silenceLevel
        method addSilence takes nothing returns nothing
            set this.silenceLevel=this.silenceLevel+1
            if this.silenceLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_SILENCE,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeSilence takes nothing returns nothing
            set this.silenceLevel=this.silenceLevel-1
            if this.silenceLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_SILENCE)
            endif
        endmethod
        method isSilenced takes nothing returns boolean
            return this.silenceLevel>0
        endmethod
        
        private integer doomLevel
        method addDoom takes nothing returns nothing
            set this.doomLevel=this.doomLevel+1
            if this.doomLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_DOOM,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeDoom takes nothing returns nothing
            set this.doomLevel=this.doomLevel-1
            if this.doomLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_DOOM)
            endif
        endmethod
        method isDoomed takes nothing returns boolean
            return this.doomLevel>0
        endmethod
        
        // Disarm (Melee)
        private integer disarmMeleeLevel
        private integer disarmRangeLevel
        method addDisarmMelee takes nothing returns nothing
            set this.disarmMeleeLevel=this.disarmMeleeLevel+1
            if this.disarmMeleeLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                if this.disarmRangeLevel>0 then
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_RANGE)
                    call IssueTargetOrderById(Status___CASTER_DISARM_BOTH,Status___OID_DISARM,this.unit)
                else
                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE,Status___OID_DISARM,this.unit)
                endif
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method addDisarmRange takes nothing returns nothing
            set this.disarmRangeLevel=this.disarmRangeLevel+1
            if this.disarmRangeLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                if this.disarmMeleeLevel>0 then
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_MELEE)
                    call IssueTargetOrderById(Status___CASTER_DISARM_BOTH,Status___OID_DISARM,this.unit)
                else
                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE,Status___OID_DISARM,this.unit)
                endif
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method addDisarm takes nothing returns nothing
            set this.disarmMeleeLevel=this.disarmMeleeLevel+1
            set this.disarmRangeLevel=this.disarmRangeLevel+1
            if this.disarmMeleeLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                if this.disarmRangeLevel>0 then
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_RANGE)
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_MELEE)
                    call IssueTargetOrderById(Status___CASTER_DISARM_BOTH,Status___OID_DISARM,this.unit)
                else
                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE,Status___OID_DISARM,this.unit)
                endif
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            else
                if this.disarmRangeLevel>0 then
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                    endif
                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE,Status___OID_DISARM,this.unit)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                    endif
                endif
            endif
        endmethod
        method removeDisarmMelee takes nothing returns nothing
            set this.disarmMeleeLevel=this.disarmMeleeLevel-1
            if this.disarmMeleeLevel==0 then
                if this.disarmRangeLevel>0 then
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_BOTH)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                    endif
                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE,Status___OID_DISARM,this.unit)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                    endif
                else
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_MELEE)
                endif
            endif
        endmethod
        method removeDisarmRange takes nothing returns nothing
            set this.disarmRangeLevel=this.disarmRangeLevel-1
            if this.disarmRangeLevel==0 then
                if this.disarmMeleeLevel>0 then
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_BOTH)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                    endif
                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE,Status___OID_DISARM,this.unit)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                    endif
                else
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_RANGE)
                endif
            endif
        endmethod
        method removeDisarm takes nothing returns nothing
            set this.disarmMeleeLevel=this.disarmMeleeLevel-1
            set this.disarmRangeLevel=this.disarmRangeLevel-1
            if this.disarmMeleeLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_BOTH)
                call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_MELEE)
                if this.disarmRangeLevel>0 then
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                    endif
                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE,Status___OID_DISARM,this.unit)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                    endif
                endif
            elseif this.disarmRangeLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_BOTH)
                call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_RANGE)
                if this.disarmMeleeLevel>0 then
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                    endif
                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE,Status___OID_DISARM,this.unit)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                    endif
                endif
            endif
        endmethod
        method isDisarmedMelee takes nothing returns boolean
            return this.disarmMeleeLevel>0
        endmethod
        method isDisarmedRange takes nothing returns boolean
            return this.disarmRangeLevel>0
        endmethod
        method isDisarmed takes nothing returns boolean
            return this.disarmMeleeLevel>0 and this.disarmRangeLevel>0
        endmethod
        
        // Immobolise
        private integer immoboliseLevel
        method addImmobolise takes nothing returns nothing
            set this.immoboliseLevel=this.immoboliseLevel+1
            if this.immoboliseLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_IMMOBOLISE,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeImmobolise takes nothing returns nothing
            set this.immoboliseLevel=this.immoboliseLevel-1
            if this.immoboliseLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_IMMOBOLISE_GROUND)
                call UnitRemoveAbility(this.unit,Status___BUFF_IMMOBOLISE_AIR)
            endif
        endmethod
        method isImmobolised takes nothing returns boolean
            return this.immoboliseLevel>0
        endmethod
        
        // Invisibility
        private integer invisibleLevel
        method addInvisible takes nothing returns nothing
            set this.invisibleLevel=this.invisibleLevel+1
            if this.invisibleLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_INVISIBLE)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_INVISIBLE)
            endif
        endmethod
        method removeInvisible takes nothing returns nothing
            set this.invisibleLevel=this.invisibleLevel-1
            if this.invisibleLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_INVISIBLE)
                call UnitRemoveAbility(this.unit,Status___ABIL_INVISIBLE)
            endif
        endmethod
        method isInvisible takes nothing returns boolean
            return this.invisibleLevel>0
        endmethod
        
        // Ghost
        private integer ghostLevel
        method addGhost takes nothing returns nothing
            set this.ghostLevel=this.ghostLevel+1
            if this.ghostLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_GHOST)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_GHOST)
            endif
        endmethod
        method removeGhost takes nothing returns nothing
            set this.ghostLevel=this.ghostLevel-1
            if this.ghostLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_GHOST)
                call UnitRemoveAbility(this.unit,Status___ABIL_GHOST)
            endif
        endmethod
        method isGhost takes nothing returns boolean
            return this.ghostLevel>0
        endmethod
        
        // Invulnerability
        private integer invulnerableLevel
        method addInvulnerable takes nothing returns nothing
            set this.invulnerableLevel=this.invulnerableLevel+1
            if this.invulnerableLevel>0 then
                call SetUnitInvulnerable(this.unit,true)
            endif
        endmethod
        method removeInvulnerable takes nothing returns nothing
            set this.invulnerableLevel=this.invulnerableLevel-1
            if this.invulnerableLevel==0 then
                call SetUnitInvulnerable(this.unit,false)
            endif
        endmethod
        method isInvulnerable takes nothing returns boolean
            return this.invulnerableLevel>0
        endmethod
        
        // Spell Immunity
        private integer immunityLevel
        method addImmunity takes nothing returns nothing
            set this.immunityLevel=this.immunityLevel+1
            if this.immunityLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_IMMUNITY)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_IMMUNITY)
            endif
        endmethod
        method removeImmunity takes nothing returns nothing
            set this.immunityLevel=this.immunityLevel-1
            if this.immunityLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_IMMUNITY)
                call UnitRemoveAbility(this.unit,Status___ABIL_IMMUNITY)
            endif
        endmethod
        method isImmune takes nothing returns boolean
            return this.immunityLevel>0
        endmethod
        
        // Pause
        private integer pauseLevel
        method addPause takes nothing returns nothing
            set this.pauseLevel=this.pauseLevel+1
            if this.pauseLevel>0 then
                call PauseUnit(this.unit,true)
            endif
        endmethod
        method removePause takes nothing returns nothing
            set this.pauseLevel=this.pauseLevel-1
            if this.pauseLevel==0 then
                call PauseUnit(this.unit,false)
            endif
        endmethod
        method isPaused takes nothing returns boolean
            return this.pauseLevel>0
        endmethod
        
        // Hide
        private integer hideLevel
        method addHide takes nothing returns nothing
            set this.hideLevel=this.hideLevel+1
            if this.hideLevel>0 then
                call ShowUnit(this.unit,false)
            endif
        endmethod
        method removeHide takes nothing returns nothing
            set this.hideLevel=this.hideLevel-1
            if this.hideLevel==0 then
                call ShowUnit(this.unit,true)
            endif
        endmethod
        method isHidden takes nothing returns boolean
            return this.hideLevel>0
        endmethod
        
        // Unpath
        private integer unpathLevel
        method addUnpath takes nothing returns nothing
            set this.unpathLevel=this.unpathLevel+1
            if this.unpathLevel>0 then
                call SetUnitPathing(this.unit,false)
            endif
        endmethod
        method removeUnpath takes nothing returns nothing
            set this.unpathLevel=this.unpathLevel-1
            if this.unpathLevel==0 then
                call SetUnitPathing(this.unit,true)
            endif
        endmethod
        method isUnpathed takes nothing returns boolean
            return this.unpathLevel>0
        endmethod
        
        // Hex
        private integer hexLevel
        method addHex takes nothing returns nothing
            set this.hexLevel=this.hexLevel+1
            if this.hexLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_HEX,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeHex takes nothing returns nothing
            set this.hexLevel=this.hexLevel-1
            if this.hexLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_HEX)
            endif
        endmethod
        method isHexed takes nothing returns boolean
            return this.hexLevel>0
        endmethod
        
        // Locust
        private integer locustLevel
        method addLocust takes nothing returns nothing
            set this.locustLevel=this.locustLevel+1
            if this.locustLevel>0 then
                call UnitAddAbility(this.unit,'Aloc')
                call UnitMakeAbilityPermanent(this.unit,true,'Aloc')
            endif
        endmethod
        method removeLocust takes nothing returns nothing
            set this.locustLevel=this.locustLevel-1
            if this.locustLevel==0 then
                call ShowUnit(this.unit,false)
                call UnitMakeAbilityPermanent(this.unit,false,'Aloc')
                call UnitRemoveAbility(this.unit,'Aloc')
                call ShowUnit(this.unit,true)
                call UnitAddAbility(this.unit,Status___ABIL_UNLOCUST)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_UNLOCUST)
                call IssueImmediateOrderById(this.unit,Status___OID_UNLOCUST)
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_UNLOCUST)
                call UnitRemoveAbility(this.unit,Status___ABIL_UNLOCUST)
            endif
        endmethod
        method isLocust takes nothing returns boolean
            return this.locustLevel>0
        endmethod
        
        // Never Miss
        private integer neverMissLevel
        method addNeverMiss takes nothing returns nothing
            set this.neverMissLevel=this.neverMissLevel+1
            if this.neverMissLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_NEVER_MISS)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_NEVER_MISS)
            endif
        endmethod
        method removeNeverMiss takes nothing returns nothing
            set this.neverMissLevel=this.neverMissLevel-1
            if this.neverMissLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_NEVER_MISS)
                call UnitRemoveAbility(this.unit,Status___ABIL_NEVER_MISS)
            endif
        endmethod
        method isNeverMiss takes nothing returns boolean
            return this.neverMissLevel>0
        endmethod
        
        // Always Miss
        private integer alwaysMissLevel
        method addAlwaysMiss takes nothing returns nothing
            set this.alwaysMissLevel=this.alwaysMissLevel+1
            if this.alwaysMissLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_ALWAYS_MISS)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_ALWAYS_MISS)
            endif
        endmethod
        method alwaysNeverMiss takes nothing returns nothing
            set this.alwaysMissLevel=this.alwaysMissLevel-1
            if this.alwaysMissLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_ALWAYS_MISS)
                call UnitRemoveAbility(this.unit,Status___ABIL_ALWAYS_MISS)
            endif
        endmethod
        method isAlwaysMiss takes nothing returns boolean
            return this.alwaysMissLevel>0
        endmethod
        
        // Untouchable
        private integer untouchableLevel
        method addUntouchable takes nothing returns nothing
            set this.untouchableLevel=this.untouchableLevel+1
            if this.untouchableLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_UNTOUCHABLE)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_UNTOUCHABLE)
            endif
        endmethod
        method removeUntouchable takes nothing returns nothing
            set this.untouchableLevel=this.untouchableLevel-1
            if this.untouchableLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_UNTOUCHABLE)
                call UnitRemoveAbility(this.unit,Status___ABIL_UNTOUCHABLE)
            endif
        endmethod
        method isUntouchable takes nothing returns boolean
            return this.untouchableLevel>0
        endmethod
        
        // Banish
        private integer banishLevel
        method addBanish takes nothing returns nothing
            set this.banishLevel=this.banishLevel+1
            if this.banishLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_BANISH,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeBanish takes nothing returns nothing
            set this.banishLevel=this.banishLevel-1
            if this.banishLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_BANISH)
            endif
        endmethod
        method isBanished takes nothing returns boolean
            return this.banishLevel>0
        endmethod
        
        // Phase
        private integer phaseLevel
        method addPhase takes nothing returns nothing
            set this.phaseLevel=this.phaseLevel+1
            if this.phaseLevel>0 then
                call SetPlayerAbilityAvailable(GetOwningPlayer(this.unit),Status___ABIL_PHASE,true)
                if UnitAddAbility(this.unit,Status___ABIL_PHASE) then
                    call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_PHASE)
                endif
                call IssueImmediateOrderById(this.unit,Status___OID_PHASE)
                call SetPlayerAbilityAvailable(GetOwningPlayer(this.unit),Status___ABIL_PHASE,false)
            endif
        endmethod
        method removePhase takes nothing returns nothing
            set this.phaseLevel=this.phaseLevel-1
            if this.phaseLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_PHASE)
            endif
        endmethod
        method isPhased takes nothing returns boolean
            return this.phaseLevel>0
        endmethod
        
        // Resistant Skin
        private integer resistantSkinLevel
        method addResistantSkin takes nothing returns nothing
            set this.resistantSkinLevel=this.resistantSkinLevel+1
            if this.resistantSkinLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_RESISTANT_SKIN)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_RESISTANT_SKIN)
            endif
        endmethod
        method removeResistantSkin takes nothing returns nothing
            set this.resistantSkinLevel=this.resistantSkinLevel-1
            if this.resistantSkinLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_RESISTANT_SKIN)
                call UnitRemoveAbility(this.unit,Status___ABIL_RESISTANT_SKIN)
            endif
        endmethod
        method isResistantSkin takes nothing returns boolean
            return this.resistantSkinLevel>0
        endmethod
        
        // Reflect Piercing
        private integer reflectPiercingLevel
        method addReflectPiercing takes nothing returns nothing
            set this.reflectPiercingLevel=this.reflectPiercingLevel+1
            if this.reflectPiercingLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_REFLECT_PIERCING)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_REFLECT_PIERCING)
            endif
        endmethod
        method removeReflectPiercing takes nothing returns nothing
            set this.reflectPiercingLevel=this.reflectPiercingLevel-1
            if this.reflectPiercingLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_REFLECT_PIERCING)
                call UnitRemoveAbility(this.unit,Status___ABIL_REFLECT_PIERCING)
            endif
        endmethod
        method isReflectPiercing takes nothing returns boolean
            return this.reflectPiercingLevel>0
        endmethod
        
        
        ////////////////////
        // Status Bonuses //
        ////////////////////
        private static method setBonus takes unit u, integer abil, integer levels, integer amount returns nothing
            local boolean addNeg=false
            if amount<0 then
                set addNeg=true
                set amount=amount+thistype.twoPow[levels]
            else
                call UnitMakeAbilityPermanent(u,false,abil)
                call UnitRemoveAbility(u,abil)
            endif
            
            set abil=abil+levels
            set levels=thistype.twoPow[levels]
            loop
                set levels=levels/2
                
                if amount>=levels then
                    call UnitAddAbility(u,abil)
                    call UnitMakeAbilityPermanent(u,true,abil)
                    set amount=amount-levels
                else
                    call UnitMakeAbilityPermanent(u,false,abil)
                    call UnitRemoveAbility(u,abil)
                endif
                
                set abil=abil-1
                exitwhen levels==1
            endloop
            
            if addNeg then
                call UnitAddAbility(u,abil)
                call UnitMakeAbilityPermanent(u,true,abil)
            endif
        endmethod
        
        private integer armorBonus
        method modArmorBonus takes integer amount returns nothing
            set this.armorBonus=this.armorBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_ARMOR,Status___LEVELS_ARMOR,this.armorBonus)
        endmethod
        method getArmorBonus takes nothing returns integer
            return this.armorBonus
        endmethod
        
        private integer damageBonus
        method modDamageBonus takes integer amount returns nothing
            set this.damageBonus=this.damageBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_DAMAGE,Status___LEVELS_DAMAGE,this.damageBonus)
        endmethod
        method getDamageBonus takes nothing returns integer
            return this.damageBonus
        endmethod
        
        private integer strBonus
        method modStrBonus takes integer amount returns nothing
            set this.strBonus=this.strBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_STR,Status___LEVELS_STR,this.strBonus)
        endmethod
        method getStrBonus takes nothing returns integer
            return this.strBonus
        endmethod
        
        private integer agiBonus
        method modAgiBonus takes integer amount returns nothing
            set this.agiBonus=this.agiBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_AGI,Status___LEVELS_AGI,this.agiBonus)
        endmethod
        method getAgiBonus takes nothing returns integer
            return this.agiBonus
        endmethod
        
        private integer intBonus
        method modIntBonus takes integer amount returns nothing
            set this.intBonus=this.intBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_INT,Status___LEVELS_INT,this.intBonus)
        endmethod
        method getIntBonus takes nothing returns integer
            return this.intBonus
        endmethod
        
        private integer attackSpeedBonus
        method modAttackSpeedBonus takes integer amount returns nothing
            set this.attackSpeedBonus=this.attackSpeedBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_ATTACK_SPEED,Status___LEVELS_ATTACK_SPEED,this.attackSpeedBonus)
        endmethod
        method getAttackSpeedBonus takes nothing returns integer
            return this.attackSpeedBonus
        endmethod
        
        private integer healthBonus
        method modHealthBonus takes integer amount returns nothing
            set this.healthBonus=this.healthBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_HEALTH,Status___LEVELS_HEALTH,this.healthBonus)
        endmethod
        method getHealthBonus takes nothing returns integer
            return this.healthBonus
        endmethod
        
        private integer manaBonus
        method modManaBonus takes integer amount returns nothing
            set this.manaBonus=this.manaBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_MANA,Status___LEVELS_MANA,this.manaBonus)
        endmethod
        method getManaBonus takes nothing returns integer
            return this.manaBonus
        endmethod
        
        // Periodic bonuses
        private static unit updateUnit
        
        private static group healthRegenGroup=CreateGroup()
        private static method healthRegenPeriodic takes nothing returns nothing
            set thistype.updateUnit=GetEnumUnit()
            if UnitAlive(thistype.updateUnit) then
                call SetWidgetLife(thistype.updateUnit,GetWidgetLife(thistype.updateUnit)+thistype[thistype.updateUnit].healthRegenBonus)
            endif
        endmethod
        private real healthRegenBonus
        method modHealthRegenBonus takes real amount returns nothing
            set this.healthRegenBonus=this.healthRegenBonus+amount*Status___PERIOD
            if this.healthRegenBonus==0 then
                call GroupRemoveUnit(thistype.healthRegenGroup,this.unit)
            else
                call GroupAddUnit(thistype.healthRegenGroup,this.unit)
            endif
        endmethod
        method getHealthRegenBonus takes nothing returns real
            return this.healthRegenBonus/Status___PERIOD
        endmethod
        
        private static group manaRegenGroup=CreateGroup()
        private static method manaRegenPeriodic takes nothing returns nothing
            set thistype.updateUnit=GetEnumUnit()
            if UnitAlive(thistype.updateUnit) then
                call SetUnitState(thistype.updateUnit,UNIT_STATE_MANA,GetUnitState(thistype.updateUnit,UNIT_STATE_MANA)+thistype[thistype.updateUnit].manaRegenBonus)
            endif
        endmethod
        private real manaRegenBonus
        method modManaRegenBonus takes real amount returns nothing
            set this.manaRegenBonus=this.manaRegenBonus+amount*Status___PERIOD
            if this.manaRegenBonus==0 then
                call GroupRemoveUnit(thistype.manaRegenGroup,this.unit)
            else
                call GroupAddUnit(thistype.manaRegenGroup,this.unit)
            endif
        endmethod
        method getManaRegenBonus takes nothing returns real
            return this.manaRegenBonus/Status___PERIOD
        endmethod
        
        private static group healthRegenPercentGroup=CreateGroup()
        private static method healthRegenPercentPeriodic takes nothing returns nothing
            set thistype.updateUnit=GetEnumUnit()
            if UnitAlive(thistype.updateUnit) then
                call SetWidgetLife(thistype.updateUnit,GetWidgetLife(thistype.updateUnit)+GetUnitState(thistype.updateUnit,UNIT_STATE_MAX_LIFE)*thistype[thistype.updateUnit].healthRegenPercentBonus)
            endif
        endmethod
        private real healthRegenPercentBonus
        method modHealthRegenPercentBonus takes real amount returns nothing
            set this.healthRegenPercentBonus=this.healthRegenPercentBonus+amount*Status___PERIOD*0.01
            if this.healthRegenPercentBonus==0 then
                call GroupRemoveUnit(thistype.healthRegenPercentGroup,this.unit)
            else
                call GroupAddUnit(thistype.healthRegenPercentGroup,this.unit)
            endif
        endmethod
        method getHealthRegenPercentBonus takes nothing returns real
            return this.healthRegenPercentBonus/Status___PERIOD/0.01
        endmethod
        
        private static group manaRegenPercentGroup=CreateGroup()
        private static method manaRegenPercentPeriodic takes nothing returns nothing
            set thistype.updateUnit=GetEnumUnit()
            if UnitAlive(thistype.updateUnit) then
                call SetUnitState(thistype.updateUnit,UNIT_STATE_MANA,GetUnitState(thistype.updateUnit,UNIT_STATE_MANA)+GetUnitState(thistype.updateUnit,UNIT_STATE_MAX_MANA)*thistype[thistype.updateUnit].manaRegenPercentBonus)
            endif
        endmethod
        private real manaRegenPercentBonus
        method modManaRegenPercentBonus takes real amount returns nothing
            set this.manaRegenPercentBonus=this.manaRegenPercentBonus+amount*Status___PERIOD*0.01
            if this.manaRegenPercentBonus==0 then
                call GroupRemoveUnit(thistype.manaRegenPercentGroup,this.unit)
            else
                call GroupAddUnit(thistype.manaRegenPercentGroup,this.unit)
            endif
        endmethod
        method getManaRegenPercentBonus takes nothing returns real
            return this.manaRegenPercentBonus/Status___PERIOD/0.01
        endmethod
        
        // Links periodic effects.
        private static method periodicLink takes nothing returns nothing
            call ForGroup(thistype.healthRegenGroup,function thistype.healthRegenPeriodic)
            call ForGroup(thistype.manaRegenGroup,function thistype.manaRegenPeriodic)
            call ForGroup(thistype.healthRegenPercentGroup,function thistype.healthRegenPercentPeriodic)
            call ForGroup(thistype.manaRegenPercentGroup,function thistype.manaRegenPercentPeriodic)
        endmethod
        implement Status___StaticPeriodic
        
        ////////////////////
        // Movement Speed //
        ////////////////////
        
        private real moveSpeedBonus
        private real moveSpeedPercentBonus
        private real x
        private real y
        private static real updateUnitX
        private static real updateUnitY
        private static real xInc
        private static real yInc
        private static real updateDist
        private method periodic takes nothing returns nothing
            set thistype.updateUnit=this.unit
            set thistype.updateUnitX=GetUnitX(thistype.updateUnit)
            set thistype.updateUnitY=GetUnitY(thistype.updateUnit)
            set thistype.xInc=thistype.updateUnitX-this.x
            set thistype.yInc=thistype.updateUnitY-this.y
            set thistype.updateDist=SquareRoot(thistype.xInc*thistype.xInc+thistype.yInc*thistype.yInc)
            if thistype.updateDist>0 then
                if UnitAlive(thistype.updateUnit) and this.disableLevel<=0 and this.stunLevel<=0 and this.pauseLevel<=0 and this.immoboliseLevel<=0 and GetUnitMoveSpeed(thistype.updateUnit)>0 then
                    if this.moveSpeedPercentBonus!=0.0 then
                        set thistype.updateUnitX=thistype.updateUnitX+thistype.xInc*this.moveSpeedPercentBonus
                        set thistype.updateUnitY=thistype.updateUnitY+thistype.yInc*this.moveSpeedPercentBonus
                    endif
                    if this.moveSpeedBonus!=0.0 then
                        set thistype.updateDist=this.moveSpeedBonus/thistype.updateDist
                        set thistype.updateUnitX=thistype.updateUnitX+thistype.xInc*thistype.updateDist
                        set thistype.updateUnitY=thistype.updateUnitY+thistype.yInc*thistype.updateDist
                    endif
                    call SetUnitX(thistype.updateUnit,thistype.updateUnitX)
                    call SetUnitY(thistype.updateUnit,thistype.updateUnitY)
                endif
            endif
            set this.x=thistype.updateUnitX
            set this.y=thistype.updateUnitY
        endmethod
        implement T32xs
        method modMoveSpeedBonus takes real amount returns nothing
            set this.moveSpeedBonus=this.moveSpeedBonus+amount*T32_PERIOD
            if this.moveSpeedBonus==0 and this.moveSpeedPercentBonus==0 then
                call this.stopPeriodic()
            else
                set this.x=GetUnitX(this.unit)
                set this.y=GetUnitY(this.unit)
                call this.startPeriodic()
            endif
        endmethod
        method getMoveSpeedBonus takes nothing returns real
            return this.moveSpeedBonus/T32_PERIOD
        endmethod
        method modMoveSpeedPercentBonus takes real amount returns nothing
            set this.moveSpeedPercentBonus=this.moveSpeedPercentBonus+amount*0.01
            if this.moveSpeedBonus==0 and this.moveSpeedPercentBonus==0 then
                call this.stopPeriodic()
            else
                set this.x=GetUnitX(this.unit)
                set this.y=GetUnitY(this.unit)
                call this.startPeriodic()
            endif
        endmethod
        method getMoveSpeedPercentBonus takes nothing returns real
            return this.moveSpeedPercentBonus/0.01
        endmethod
    endstruct

//library Status ends
//library TransportBuffer:
struct TransportBuffer extends DefaultBufferStruct
    lightning te
    effect e1
    effect e2
    unit target
    method addBuffer takes nothing returns nothing
        local real r = DistanceTwoUnits(u, target)
        if (not EquipmentData[u].heroData.transport) and (r < 1200) and (GetUnitState(u, UNIT_STATE_MANA) > 0 and (GetUnitState(target, UNIT_STATE_MANA) < GetUnitState(target, UNIT_STATE_MAX_MANA))) then
            set te=AddLightningEx( "DRAM", false, GetUnitX(u),GetUnitY(u),getUnitHeight(u), GetUnitX(target), GetUnitY(target),getUnitHeight(target) )
            set e1 = AddSpecialEffectTarget("Abilities\\Spells\\Other\\Drain\\ManaDrainTarget.mdl", u, "origin")
            set e2 = AddSpecialEffectTarget("Abilities\\Spells\\Other\\Drain\\ManaDrainCaster.mdl", target, "origin")
            call PlaySoundOnUnitBJ(gg_snd_transport,80, u)
            set EquipmentData[u].heroData.transport = true
        else
            set count = -1
            call DisplayInfo(GetOwningPlayer(u), "浼犺緭澶辫触")
        endif
    endmethod
    method action takes nothing returns nothing
        local real r
        call MoveLightningEx( te, false, GetUnitX(u),GetUnitY(u),getUnitHeight(u), GetUnitX(target), GetUnitY(target),getUnitHeight(target))
        if ModuloInteger(count, 25) == 0 then
            set r = DistanceTwoUnits(u, target)
            if (r < 1200) and (GetUnitState(u, UNIT_STATE_MANA) > 0 and (GetUnitState(target, UNIT_STATE_MANA) < GetUnitState(target, UNIT_STATE_MAX_MANA))) then
                call SetUnitState(u, UNIT_STATE_MANA, GetUnitState(u, UNIT_STATE_MANA) - 5)
                call SetUnitState(target, UNIT_STATE_MANA, GetUnitState(target, UNIT_STATE_MANA) + 5)
                call DisplayManaCost(u, 5)
            else
                set count = -1
            endif
        endif
    endmethod
    method removeBuffer takes nothing returns nothing
        set EquipmentData[u].heroData.transport = false
        if te != null then
            call DestroyLightning(te)
            set te = null
        endif
        if e1 != null then
            call DestroyEffect(e1)
            set e1 = null
        endif
        set target = null
        if e2 != null then
            call DestroyEffect(e2)
            set e2 = null
        endif
    endmethod
    
    static method create takes unit u, unit target, integer count returns TransportBuffer
        local TransportBuffer m = TransportBuffer.allocate(u, count)
        set m.target = target
        return m
    endmethod
endstruct

//library TransportBuffer ends
//library VectorLib:

//library VectorLib ends
//library YDWETimerSystem:
function YDWETimerSystem__NewTaskIndex takes nothing returns integer
	local integer h = YDWETimerSystem__TaskListIdleHead
	if YDWETimerSystem__TaskListIdleHead < 0 then
		if YDWETimerSystem__TaskListIdleMax >= 8000 then
			return 8100
		else
			set YDWETimerSystem__TaskListIdleMax = YDWETimerSystem__TaskListIdleMax + 1
			return YDWETimerSystem__TaskListIdleMax
		endif
	endif
	set YDWETimerSystem__TaskListIdleHead = YDWETimerSystem__TaskListIdle[h]
	return h
endfunction
function YDWETimerSystem__DeleteTaskIndex takes integer index returns nothing
	set YDWETimerSystem__TaskListIdle[index] = YDWETimerSystem__TaskListIdleHead
	set YDWETimerSystem__TaskListIdleHead = index
endfunction
//该函数序列处理
function YDWETimerSystem__NewTask takes real time, trigger proc returns integer
	local integer index = YDWETimerSystem__NewTaskIndex()
	local integer h = YDWETimerSystem__TaskListHead
	local integer t = R2I(100.*time) + YDWETimerSystem__CurrentTime
	local integer p
	set YDWETimerSystem__TaskListProc[index] = proc
	set YDWETimerSystem__TaskListTime[index] = t
	loop
		set p = YDWETimerSystem__TaskListNext[h]
		if p < 0 or YDWETimerSystem__TaskListTime[p] >= t then
		//	call BJDebugMsg("NewTask:"+I2S(index))
			set YDWETimerSystem__TaskListNext[h] = index
			set YDWETimerSystem__TaskListNext[index] = p
			return index
		endif
		set h = p
	endloop
	return index
endfunction
function YDWETimerSystemNewTask takes real time, trigger proc returns integer
	return YDWETimerSystem__NewTask(time, proc)
endfunction
function YDWETimerSystemGetCurrentTask takes nothing returns integer
	return YDWETimerSystem__CurrentIndex
endfunction
//删除单位
function YDWETimerSystem__RemoveUnit_CallBack takes nothing returns nothing
    call RemoveUnit(LoadUnitHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex))
    call RemoveSavedHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex)
endfunction
function YDWETimerRemoveUnit takes real time, unit u returns nothing
    call SaveUnitHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__NewTask(time, YDWETimerSystem__fnRemoveUnit), u)
endfunction
//摧毁计时器
function YDWETimerSystem__DestroyTimer_CallBack takes nothing returns nothing
    call DestroyTimer(LoadTimerHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex))
    call RemoveSavedHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex)
endfunction
function YDWETimerDestroyTimer takes real time, timer t returns nothing
    call SaveTimerHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__NewTask(time, YDWETimerSystem__fnDestroyTimer), t)
endfunction
//删除物品
function YDWETimerSystem__RemoveItem_CallBack takes nothing returns nothing
    call RemoveItem(LoadItemHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex))
    call RemoveSavedHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex)
endfunction
function YDWETimerRemoveItem takes real time, item it returns nothing
    call SaveItemHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__NewTask(time, YDWETimerSystem__fnRemoveItem), it)
endfunction
//删除特效
function YDWETimerSystem__DestroyEffect_CallBack takes nothing returns nothing
    call DestroyEffect(LoadEffectHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex))
    call RemoveSavedHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex)
endfunction
function YDWETimerDestroyEffect takes real time, effect e returns nothing
    call SaveEffectHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__NewTask(time, YDWETimerSystem__fnDestroyEffect), e)
endfunction
//删除闪电特效
function YDWETimerSystem__DestroyLightning_CallBack takes nothing returns nothing
    call DestroyLightning(LoadLightningHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex))
    call RemoveSavedHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex)
endfunction
function YDWETimerDestroyLightning takes real time, lightning lt returns nothing
	local integer i = YDWETimerSystem__NewTask(time, YDWETimerSystem__fnDestroyLightning)
    call SaveLightningHandle(YDHT, YDWETimerSystem__TimerHandle, i, lt)
endfunction
//运行触发器
function YDWETimerSystem__RunTrigger_CallBack takes nothing returns nothing
    call TriggerExecute(LoadTriggerHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex))
    call RemoveSavedHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__CurrentIndex)
endfunction
function YDWETimerRunTrigger takes real time, trigger trg returns nothing
    call SaveTriggerHandle(YDHT, YDWETimerSystem__TimerHandle, YDWETimerSystem__NewTask(time, YDWETimerSystem__fnRunTrigger), trg)
endfunction
//删除漂浮文字
function YDWETimerDestroyTextTag takes real time, texttag tt returns nothing
    local integer N=0
    local integer i=0
    if time <= 0 then
        set time = 0.01
    endif
    call SetTextTagPermanent(tt,false)
    call SetTextTagLifespan(tt,time)
    call SetTextTagFadepoint(tt,time)
endfunction
//中心计时器主函数
function YDWETimerSystem__Main takes nothing returns nothing
	local integer h = YDWETimerSystem__TaskListHead
	local integer p
	loop
		set YDWETimerSystem__CurrentIndex = YDWETimerSystem__TaskListNext[h]
		exitwhen YDWETimerSystem__CurrentIndex < 0 or YDWETimerSystem__CurrentTime < YDWETimerSystem__TaskListTime[YDWETimerSystem__CurrentIndex]
		//call BJDebugMsg("Task:"+I2S(CurrentIndex))
		call TriggerEvaluate(YDWETimerSystem__TaskListProc[YDWETimerSystem__CurrentIndex])
		call YDWETimerSystem__DeleteTaskIndex(YDWETimerSystem__CurrentIndex)
		set YDWETimerSystem__TaskListNext[h] = YDWETimerSystem__TaskListNext[YDWETimerSystem__CurrentIndex]
	endloop
	set YDWETimerSystem__CurrentTime = YDWETimerSystem__CurrentTime + 1
endfunction
//初始化函数
function YDWETimerSystem__Init takes nothing returns nothing
    set YDWETimerSystem__Timer = CreateTimer()
	set YDWETimerSystem__TimerHandle	= GetHandleId( YDWETimerSystem__Timer)
	set YDWETimerSystem__CurrentTime = 0
	set YDWETimerSystem__TaskListHead = 0
	set YDWETimerSystem__TaskListNext[0] = -1
	set YDWETimerSystem__TaskListIdleHead = 1
	set YDWETimerSystem__TaskListIdleMax = 1
	set YDWETimerSystem__TaskListIdle[1] = -1
	
	set YDWETimerSystem__fnRemoveUnit = CreateTrigger()
	set YDWETimerSystem__fnDestroyTimer = CreateTrigger()
	set YDWETimerSystem__fnRemoveItem = CreateTrigger()
	set YDWETimerSystem__fnDestroyEffect = CreateTrigger()
	set YDWETimerSystem__fnDestroyLightning = CreateTrigger()
	set YDWETimerSystem__fnRunTrigger = CreateTrigger()
	call TriggerAddCondition(YDWETimerSystem__fnRemoveUnit, Condition(function YDWETimerSystem__RemoveUnit_CallBack))
	call TriggerAddCondition(YDWETimerSystem__fnDestroyTimer, Condition(function YDWETimerSystem__DestroyTimer_CallBack))
	call TriggerAddCondition(YDWETimerSystem__fnRemoveItem, Condition(function YDWETimerSystem__RemoveItem_CallBack))
	call TriggerAddCondition(YDWETimerSystem__fnDestroyEffect, Condition(function YDWETimerSystem__DestroyEffect_CallBack))
	call TriggerAddCondition(YDWETimerSystem__fnDestroyLightning, Condition(function YDWETimerSystem__DestroyLightning_CallBack))
	call TriggerAddCondition(YDWETimerSystem__fnRunTrigger, Condition(function YDWETimerSystem__RunTrigger_CallBack))
	
    call TimerStart(YDWETimerSystem__Timer, 0.01, true, function YDWETimerSystem__Main)
endfunction
//循环类仍用独立计时器
function YDWETimerSystemGetRunIndex takes nothing returns integer
    return YDWETimerSystem__TimerSystem_RunIndex
endfunction
function YDWETimerSystem__RunPeriodicTriggerFunction takes nothing returns nothing
    local integer tid = GetHandleId( GetExpiredTimer())
    local trigger trg = LoadTriggerHandle(YDHT, tid, $D0001)
	call SaveInteger(YDHT, StringHash( I2S(GetHandleId( trg))), StringHash( "RunIndex"), LoadInteger(YDHT, tid, $D0002))
    if TriggerEvaluate(trg) then
        call TriggerExecute(trg)
    endif
    set trg = null
endfunction
function YDWETimerSystem__RunPeriodicTriggerFunctionByTimes takes nothing returns nothing
    local integer tid = GetHandleId( GetExpiredTimer())
    local trigger trg = LoadTriggerHandle(YDHT, tid, $D0001)
    local integer times = LoadInteger(YDHT, tid, $D0003)
	call SaveInteger(YDHT, StringHash( I2S(GetHandleId( trg))), StringHash( "RunIndex"), LoadInteger(YDHT, tid, $D0002))
    if TriggerEvaluate(trg) then
        call TriggerExecute(trg)
    endif
    set times = times - 1
    if times > 0 then
		call SaveInteger(YDHT, tid, $D0003, times)
      else
        call DestroyTimer(GetExpiredTimer())
        call FlushChildHashtable(YDHT, tid)
    endif
    set trg = null
endfunction
function YDWETimerRunPeriodicTrigger takes real timeout, trigger trg, boolean b, integer times, integer data returns nothing
    local timer t
    local integer tid
    local integer index = 0
    if timeout < 0 then
        return
      else
        set t = CreateTimer()
		set tid = GetHandleId( t)
    endif
    set YDWETimerSystem__TimerSystem_RunIndex = YDWETimerSystem__TimerSystem_RunIndex + 1
	call SaveTriggerHandle(YDHT, tid, $D0001, trg)
	call SaveInteger(YDHT, tid, $D0002, YDWETimerSystem__TimerSystem_RunIndex)
	set index = LoadInteger(YDHT, GetHandleId( trg), 'YDTS'+data)
    set index = index + 1
	call SaveInteger(YDHT, GetHandleId( trg), 'YDTS'+data, index)
	call SaveTimerHandle(YDHT, GetHandleId( trg), ('YDTS'+data)*index, t)
	
    if b == false then
		call SaveInteger(YDHT, tid, $D0003, times)
        call TimerStart(t, timeout, true, function YDWETimerSystem__RunPeriodicTriggerFunctionByTimes)
      else
        call TimerStart(t, timeout, true, function YDWETimerSystem__RunPeriodicTriggerFunction)
    endif
    set t = null
endfunction
function YDWETimerRunPeriodicTriggerOver takes trigger trg, integer data returns nothing
	local integer trgid = GetHandleId( trg)
    local integer index = LoadInteger(YDHT, trgid, 'YDTS'+data)
    local timer t
    loop
        exitwhen index <= 0
        set t = LoadTimerHandle(YDHT, trgid, ('YDTS'+data)*index)
        call DestroyTimer(t)
        call FlushChildHashtable(YDHT, GetHandleId( t))
		call RemoveSavedHandle(YDHT, trgid, ('YDTS'+data)*index)
        set index = index - 1
    endloop
	
    call RemoveSavedInteger(YDHT, trgid, 'YDTS'+data)
    set t = null
endfunction

//library YDWETimerSystem ends
//library CameraLock:
function TrackCamera takes real x, real y, integer i returns nothing
    if (GetLocalPlayer() == Player(i)) then
        call PanCameraToTimed(x, y, 1)
    endif
endfunction
function CameraLockAction takes nothing returns nothing
    local integer i = 0
    local real dir = 0
    local real x
    local real y
    local real d = 500
    if g_camera_lock then
        if heros[i] != null and IsUnitAliveBJ(heros[i]) then
            set dir = getFacing(heros[i])
            set x = GetUnitX(heros[i]) + Cos(dir) * d
            set y = GetUnitY(heros[i]) + Sin(dir) * d
            call TrackCamera(x, y, i)
        endif
    endif
endfunction
    
function CameraLockInit takes nothing returns nothing
    set moveTimer=CreateTimer()
    call TimerStart(moveTimer,0.1,true,function CameraLockAction)
endfunction

//library CameraLock ends
//library FakeMan:
function FakeManInit takes nothing returns nothing
endfunction
struct RealMan
    unit man
    implement List
    static method create takes unit man returns RealMan
        local RealMan ys = .allocate()
            set ys.man = man
            call ys.addList()
        return ys
    endmethod
    method onDestroy takes nothing returns nothing
        call .removeList()
    endmethod
    static method CheckLevel takes real x, real y, string lv returns string
        local real distance = 1000000
        local real temp
        local RealMan ys = .getFirst()
        loop
            exitwhen ys == 0
            set temp = DistanceUnitAndXY(ys.man, x, y)
            if temp < distance then
                set distance = temp
            endif
            set ys = ys.getNext()
        endloop
        if distance >= LV_FREEZ_DISTANCE then
            return lv
        endif
        return LV_ACTIVE
    endmethod
endstruct
function AddRealMan takes unit man returns nothing
    call RealMan.create(man)
endfunction

//library FakeMan ends
//library FogControl:
function FogControlAction takes nothing returns nothing
    local integer i = 0
    local real x
    local real y
    local location l
    loop
        exitwhen i >= PLAYER_COUNT
        if fogms[i] != null then
            call FogModifierStop(fogms[i])
            call DestroyFogModifier(fogms[i])
            set fogms[i] = null
        endif
        if g_fog and heros[i] != null and IsUnitAliveBJ(heros[i]) then
            set x = GetUnitX(heros[i])
            set y = GetUnitY(heros[i])
            set l = Location(x, y)
            set fogms[i] = CreateFogModifierRadiusLocBJ( true, Player(i), FOG_OF_WAR_VISIBLE, l, EquipmentData[heros[i]].heroData.vision)
            set l = null
        endif
        set i = i + 1
    endloop
endfunction
    
function FogControlInit takes nothing returns nothing
    set fctimer=CreateTimer()
    call TimerStart(fctimer,1,true,function FogControlAction)
endfunction

//library FogControl ends
//library ItemEquip:
function HasConflictItemType takes unit u,item itm returns boolean
local integer i=0
local integer t
local integer typeid=GetItemTypeId(itm)
local item ui
if HaveSavedInteger(ht,typeid,kit)==false then
    return false
endif
set t=LoadInteger(ht,typeid,kit)
loop
    exitwhen i>5
    set ui=UnitItemInSlot(u,i)
    if ui!=itm and LoadInteger(ht,GetItemTypeId(ui),kit)==t then
        return true
    endif
    set i=i+1
endloop
return false
endfunction
function UnequipGun takes unit u,item i returns nothing
endfunction
function EquipGun takes unit u,item i returns nothing
    local integer t = GetItemTypeId(i)
    local IGun gun = IndividualItemData[i].featureData.gun
    call gun.setOwner(u)
    set EquipmentData[u].gun = gun
    set EquipmentData[u].heroData.equips[GUN] = t
    call SetPlayerState(GetOwningPlayer(u), PLAYER_STATE_RESOURCE_FOOD_CAP, EquipmentData[u].gun.shooter.getClipSize())
endfunction
function EquipGunV2 takes unit u returns nothing
    local IGun gun = AutoRifle.create(u, 0)
    call gun.setOwner(u)
    set EquipmentData[u].gun = gun
    call SetPlayerState(GetOwningPlayer(u), PLAYER_STATE_RESOURCE_FOOD_USED, EquipmentData[u].heroData.clip_size)
    call SetPlayerState(GetOwningPlayer(u), PLAYER_STATE_RESOURCE_FOOD_CAP, EquipmentData[u].heroData.clip_size)
endfunction
function AddItemSpell takes unit u , integer itemType returns nothing
    local ItemTypeData data= getItemTypeData(itemType)
    local integer spell = data.spell
    local integer lv = GetUnitAbilityLevel(GetTriggerUnit(), spell)
    if lv == 0 then
        call UnitAddAbility(u, spell)
    endif
    call SetPlayerAbilityAvailable(GetOwningPlayer(u), spell, true )
    call data.destroy()
endfunction
function RemoveItemSpell takes unit u , integer itemType returns nothing
    local ItemTypeData data= getItemTypeData(itemType)
    local integer spell = data.spell
    call UnitRemoveAbility(u, spell)
    call SetPlayerAbilityAvailable(GetOwningPlayer(u), spell, false )
    //鍒犻櫎棰濆鎶€鑳?
    if itemType == 'I00Q' then
        call UnitRemoveAbility(u, 'A01Z')
    endif
    call data.destroy()
endfunction
function AddItemStaticAbility takes unit u, integer itemType returns nothing
local integer s1
local integer s2
local integer s3
local integer s4
local integer s5
local ItemTypeData data = getItemTypeData(itemType)
//textmacro instance: AddStaticAbility("s1")
    set s1 = data.s1
    if s1 != 0 then
        call UnitAddAbility(u, s1)
    endif
//end of: AddStaticAbility("s1")
//textmacro instance: AddStaticAbility("s2")
    set s2 = data.s2
    if s2 != 0 then
        call UnitAddAbility(u, s2)
    endif
//end of: AddStaticAbility("s2")
//textmacro instance: AddStaticAbility("s3")
    set s3 = data.s3
    if s3 != 0 then
        call UnitAddAbility(u, s3)
    endif
//end of: AddStaticAbility("s3")
call data.destroy()
endfunction
function RemoveItemStaticAbility takes unit u, integer itemType returns nothing
local integer s1
local integer s2
local integer s3
local integer s4
local integer s5
local ItemTypeData data = getItemTypeData(itemType)
//textmacro instance: RemoveStaticAbility("s1")
    set s1 = getItemTypeData(itemType).s1
    if s1 != 0 then
        call UnitRemoveAbility(u, s1)
    endif
//end of: RemoveStaticAbility("s1")
//textmacro instance: RemoveStaticAbility("s2")
    set s2 = getItemTypeData(itemType).s2
    if s2 != 0 then
        call UnitRemoveAbility(u, s2)
    endif
//end of: RemoveStaticAbility("s2")
//textmacro instance: RemoveStaticAbility("s3")
    set s3 = getItemTypeData(itemType).s3
    if s3 != 0 then
        call UnitRemoveAbility(u, s3)
    endif
//end of: RemoveStaticAbility("s3")
call data.destroy()
endfunction
function ItemEquip takes nothing returns nothing
    local item i=GetManipulatedItem()
    local unit u=GetTriggerUnit()
    local integer itemType = GetItemTypeId(i)
    local integer t
    local ItemTypeData itd
    local IDialog d
    local string s
    if GetUnitTypeId(u)== HERO then
        if hasItemTypeData(itemType) then
            set itd = getItemTypeData(itemType)
            set t = itd.itemType
            if t == AB1 or t == AB2 then
                if EquipmentData[u].heroData.equips[t] > 0 then
                    if t == AB1 then
                        set s = MAJOR_AB
                    else
                        set s = MINOR_AB
                    endif
                    set d = ChangeAbDialog.create("鏄惁鍒囨崲"+s+"锛焲n鎵€鏈夎姳璐圭殑鏀硅鐐规暟灏嗕細琚繑鍥?, GetOwningPlayer(u), t, EquipmentData[u].heroData.equips[t], itemType)
                    call d.display()
                else
                    call AddItemSpell(u, itemType)
                    call AddItemStaticAbility(u, itemType)
                    set EquipmentData[u].heroData.equips[t] = itemType
                endif
            elseif t == GUN then
                if EquipmentData[u].heroData.equips[t] > 0 then
                    set d = ChangeGunDialog.create("鏄惁鍒囨崲鏋锛焲n鎵€鏈夎姳璐圭殑鏀硅鐐规暟灏嗕細琚繑鍥?, GetOwningPlayer(u), t, EquipmentData[u].heroData.equips[t], itemType, i)
                    call d.display()
                else
                    call EquipGun(u, i)
                endif
            endif
            call itd.destroy()
        endif
    endif
    set u=null
endfunction
function DropItem takes unit u, integer t returns nothing
    local integer i = 0
    local item itm
    loop
        exitwhen i > 5
        set itm = UnitItemInSlot(u, i)
        if GetItemTypeId(itm) == t then
            call UnitRemoveItemSwapped(itm, u)
        endif
        set i = i + 1
    endloop
    set itm = null
endfunction
function UnEquipItem takes nothing returns nothing
    local item i=GetManipulatedItem()
    local unit u=GetTriggerUnit()
    local integer itemType=GetItemTypeId(i)
    if GetUnitTypeId(u)== HERO then
        if hasItemTypeData(itemType) then
            call RemoveItemSpell(u, itemType)
            call RemoveItemStaticAbility(u, itemType)
        endif 
    endif
    set u=null
endfunction
function InitItemEquip takes nothing returns nothing
local trigger t=CreateTrigger()
local trigger t2=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_PICKUP_ITEM )
call TriggerAddCondition(t,function ItemEquip)
call TriggerRegisterAnyUnitEventBJ( t2, EVENT_PLAYER_UNIT_DROP_ITEM )
call TriggerAddCondition(t2,function UnEquipItem)
set t=null
set t2=null
endfunction

//library ItemEquip ends
//library NetBuffer:
function InitNetBuffer takes nothing returns nothing
    set netgroup = NewGroup()
endfunction

//library NetBuffer ends
//library ShootTarget:
function ShootEnergy takes nothing returns nothing
//local damagetype dt = Damage_GetType()
//local unit ds = GetEventDamageSource()
local unit ds = GetAttacker()
//if dt == DAMAGE_TYPE_NORMAL and GetUnitTypeId(ds) == 'h000' then
if GetUnitTypeId(ds) == HERO or GetUnitTypeId(ds) == EVIL_MARIN then
    set EquipmentData[ds].heroData.shoot_target = GetTriggerUnit()
    //call BJDebugMsg(R2S( GetTimeOfDay()))
    if EquipmentData[ds].gun != null then
        call EquipmentData[ds].gun.fire()
    endif
elseif GetUnitTypeId(ds) == 'h00D' then
    //call SetUnitState(ds, UNIT_STATE_MANA, GetUnitState(ds, UNIT_STATE_MANA) - 5)
endif
set ds = null
endfunction
function ShootMove takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit()) == HERO and GetUnitAbilityLevel(GetTriggerUnit(), 'A025') > 0 and (GetIssuedOrderId() == OI_RIGHT_CLICK_MOVE or GetIssuedOrderId() == 851990) and GetUnitAbilityLevel(GetTriggerUnit(), 'A02H') == 0 then
    call IssueImmediateOrder( GetTriggerUnit(), "stop" )
    call PauseUnit(GetTriggerUnit(), true)
    call PauseUnit(GetTriggerUnit(), false)
    if not EquipmentData[GetTriggerUnit()].heroData.reload then
        set EquipmentData[GetTriggerUnit()].heroData.shoot_buffer = IMinBJ(EquipmentData[GetTriggerUnit()].heroData.shoot_buffer + EquipmentData[GetTriggerUnit()].heroData.shoot_count, EquipmentData[GetTriggerUnit()].heroData.shoot_count * 3)
    else
        call PlaySoundOnUnitBJ(gg_snd_clipempty, 100,GetTriggerUnit())
    endif
    //call BJDebugMsg("shoot buffer " + I2S(EquipmentData[GetTriggerUnit()].heroData.shoot_buffer))
    return false
endif
return true
endfunction
function Change takes nothing returns nothing
    local unit u
    if GetSpellAbilityId() == ranger then
        set u=GetTriggerUnit()
        call IssueImmediateOrderById(u, 851972)
        call UnitRemoveAbility(u, ranger)
        call UnitAddAbility(u, meeler)
        call RemoveUnit(EquipmentData[GetTriggerUnit()].heroData.aimu)
        set EquipmentData[GetTriggerUnit()].heroData.aimu = null
        set EquipmentData[GetTriggerUnit()].heroData.shoot_buffer = 0
    elseif GetSpellAbilityId() == meeler then
        set EquipmentData[GetTriggerUnit()].heroData.shoot_buffer = 0
        set u=GetTriggerUnit()
        call PlaySoundOnUnitBJ(gg_snd_reload, 100, u)
        call IssueImmediateOrderById(u, 851972)
        call UnitRemoveAbility(u, meeler)
        call UnitAddAbility(u, ranger)
        set EquipmentData[GetTriggerUnit()].heroData.aimu = CreateUnit(GetOwningPlayer(GetTriggerUnit()), 'e00K', GetUnitX(GetTriggerUnit())+10, GetUnitY(GetTriggerUnit())+10, 0)
        if mode_tip[GetPlayerId(GetOwningPlayer(u))] > 0 then
            set mode_tip[GetPlayerId(GetOwningPlayer(u))] = mode_tip[GetPlayerId(GetOwningPlayer(u))] - 1
            call DisplayInfo(GetOwningPlayer(u), "褰撳墠涓哄皠鍑绘ā寮忥紝鍙抽敭鏃犳硶绉诲姩锛屾寜Z鍒囨崲鍒版満鍔ㄦā寮忓彲鎭㈠绉诲姩")
        endif
    endif
    set u=null
endfunction
function InitShootTarget takes nothing returns nothing
set gtrgShootTarget=CreateTrigger()
set gtrgShootMove=CreateTrigger()
set gtrgShootChange=CreateTrigger()
//all Damage_RegisterEvent( gtrgShootTarget)
//call TriggerRegisterAnyUnitEventBJ( gtrgShootTarget, EVENT_PLAYER_UNIT_ATTACKED )
//call TriggerAddCondition(gtrgShootTarget,function ShootEnergy)
call TriggerRegisterAnyUnitEventBJ( gtrgShootMove, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER )
call TriggerRegisterAnyUnitEventBJ( gtrgShootMove, EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER )
call TriggerAddCondition(gtrgShootMove,function ShootMove)
call TriggerRegisterAnyUnitEventBJ(gtrgShootChange, EVENT_PLAYER_UNIT_SPELL_CHANNEL)
call TriggerAddCondition(gtrgShootChange, Condition(function Change))
endfunction

//library ShootTarget ends
//library Strong:
function DoStrongCondition takes nothing returns nothing
    local unit u = GetTriggerUnit()
    local real strong
    local real dam = GetEventDamage()
    local real doge
    if dam > 0.1 and IsHero(u) then
        set doge = EquipmentData[u].heroData.doge
        if GetRandomReal(0, 1) <= doge then
            call Damage_BlockAll()
            call DestroyEffect( AddSpecialEffect(E_DOGE, GetUnitX(u), GetUnitY(u)) )
        else
            set strong = EquipmentData[u].heroData.strong
            call Damage_Block(dam * strong)
        endif
    endif
    set u = null
endfunction
function InitStrong takes nothing returns nothing
local trigger doStrong_t=CreateTrigger()
call TriggerAddCondition(doStrong_t,function DoStrongCondition)
call Damage_RegisterEvent(doStrong_t)
set doStrong_t=null
endfunction

//library Strong ends
//library Stun:
function AddStun takes unit whichUnit returns nothing
        call Status[whichUnit].addStun()
    endfunction
    function RemoveStun takes unit whichUnit returns nothing
        call Status[whichUnit].removeStun()
    endfunction
    function Stun_IsUnitStunned takes unit whichUnit returns boolean
        return Status[whichUnit].isStunned()
    endfunction

//library Stun ends
//library TargetFilter:
    function IsLiveEnemy takes unit s,unit u returns boolean
        return s!= u and IsUnitAliveBJ(u) and IsUnitEnemy(s, GetOwningPlayer(u))
    endfunction
    function IsLiveAlly takes unit s,unit u returns boolean
        return s!= u and IsUnitAliveBJ(u) and IsUnitAlly(s, GetOwningPlayer(u))
    endfunction
    
    function IsLiveEnemyUnit takes unit s,unit u returns boolean
        return s!=u and IsUnitAliveBJ(u) and IsUnitEnemy(s, GetOwningPlayer(u)) and (Material[u].clazz == MC_UNIT)
    endfunction 
    function IsLiveAllyUnit takes unit s,unit u returns boolean
        return s!=u and IsUnitAliveBJ(u) and IsUnitAlly(s, GetOwningPlayer(u)) and (Material[u].clazz == MC_UNIT)
    endfunction 
    
    function IsLiveUnitOrDestroyableWall takes unit s,unit u returns boolean
        return s!=u and IsUnitAliveBJ(u) and ((Material[u].clazz == MC_UNIT) or IsWall2(u) or IsWall(u) or Material[u].clazz == MC_WALL)
    endfunction 
    function IsLiveEnemyUnitOrDestroyableWall takes unit s,unit u returns boolean
        return s!=u and IsUnitAliveBJ(u) and (IsUnitEnemy(s, GetOwningPlayer(u)) or IsWall2(u)) and ((Material[u].clazz == MC_UNIT) or IsWall2(u) or IsWall(u) or Material[u].clazz == MC_WALL)
    endfunction 
    
    function IsLiveUnit takes unit s, unit u returns boolean
        return IsUnitAliveBJ(u) and Material[u].clazz == MC_UNIT
    endfunction
    function IsLiveUnitOrWall takes unit s, unit u returns boolean
        return IsUnitAliveBJ(u) and (Material[u].clazz == MC_UNIT or Material[u].clazz == MC_WALL)
    endfunction
    
//textmacro instance: HasThingInRange("HasLiveEnemyUnitInRange","IsLiveEnemyUnit")
    function HasLiveEnemyUnitInRange takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit result = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null or result != null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            if s != ydl_unit and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveEnemyUnit(s, ydl_unit) then
                set result = ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return result
    endfunction
//end of: HasThingInRange("HasLiveEnemyUnitInRange","IsLiveEnemyUnit")
//textmacro instance: HasThingInRange("HasLiveUnitOrDestroyableWallInRange","IsLiveUnitOrDestroyableWall")
    function HasLiveUnitOrDestroyableWallInRange takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit result = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null or result != null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            if s != ydl_unit and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveUnitOrDestroyableWall(s, ydl_unit) then
                set result = ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return result
    endfunction
//end of: HasThingInRange("HasLiveUnitOrDestroyableWallInRange","IsLiveUnitOrDestroyableWall")
//textmacro instance: HasThingInRange("HasLiveUnitInRange","IsLiveUnit") 
    function HasLiveUnitInRange takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit result = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null or result != null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            if s != ydl_unit and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveUnit(s, ydl_unit) then
                set result = ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return result
    endfunction
//end of: HasThingInRange("HasLiveUnitInRange","IsLiveUnit") 
//textmacro instance: GetNearestThingInRange("GetNearestLiveUnit","IsLiveUnit")
    function GetNearestLiveUnit takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        set ru = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            set d=DistanceTwoUnits(s,ydl_unit)
            if ydl_unit != s and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveUnit(s, ydl_unit) and d<mind then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return ru
    endfunction
//end of: GetNearestThingInRange("GetNearestLiveUnit","IsLiveUnit")
//textmacro instance: GetNearestThingInRange("GetNearestLiveUnitOrWall","IsLiveUnitOrWall")
    function GetNearestLiveUnitOrWall takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        set ru = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            set d=DistanceTwoUnits(s,ydl_unit)
            if ydl_unit != s and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveUnitOrWall(s, ydl_unit) and d<mind then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return ru
    endfunction
//end of: GetNearestThingInRange("GetNearestLiveUnitOrWall","IsLiveUnitOrWall")
//textmacro instance: GetNearestThingInRange("GetNearestEnemy","IsLiveEnemyUnit")
    function GetNearestEnemy takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        set ru = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            set d=DistanceTwoUnits(s,ydl_unit)
            if ydl_unit != s and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveEnemyUnit(s, ydl_unit) and d<mind then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return ru
    endfunction
//end of: GetNearestThingInRange("GetNearestEnemy","IsLiveEnemyUnit")
    
    function GetNearestEnemyInGroup takes unit u,group g returns unit
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        local group tg=NewGroup()
        call GroupAddGroup(g,tg)
        set ru=null
        loop
            set ydl_unit = FirstOfGroup(tg)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(tg, ydl_unit)
            set d=DistanceTwoUnits(u,ydl_unit)
            if d<mind and IsLiveEnemy(u,ydl_unit)then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        set ydl_unit = null
        call ReleaseGroup(tg)
        return ru
    endfunction
    

//library TargetFilter ends
//library AIData:
function IsAIUnit takes unit u returns boolean
    return GetOwningPlayer(u)==Player(11) and Material[u].clazz == MC_UNIT
endfunction
struct AIData extends array
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()
IAIGroup currentAIGroup
IAIStrategy strategy
integer last_change
integer last_attack_tick
unit targetUnit
static method AIDS_filter takes unit u returns boolean
    if IsAIUnit(u) then
        return true
    endif
    return false
endmethod
private method AIDS_onCreate takes nothing returns nothing
local integer t = GetUnitTypeId(.unit)
set targetUnit=GetNearestEnemyInGroup(.unit,MonsterTargetGroup)
set last_change = Tick
if t == 'u002' then
set strategy = gBoss1AIStrategy
elseif t == 'z001' then
set strategy = gFleeRanger
else
set strategy = gDefaultAIStrategy
endif
call GetInMap(.unit)
endmethod
private method AIDS_onDestroy takes nothing returns nothing
set currentAIGroup=0
set targetUnit=null
endmethod
endstruct

//library AIData ends
//library AIGroup:
function InitAIGroup takes nothing returns nothing
    
endfunction
interface IAIGroup
group g
group tg
method getInterval takes nothing returns integer
method shouldLoop takes unit u returns boolean
method afterLoop takes unit u returns nothing
method ailoop takes unit u returns nothing
method addUnit takes unit u returns nothing
method removeUnit takes unit u returns nothing
method addpg takes unit u returns nothing
endinterface
struct AbstractGroup extends IAIGroup
method getInterval takes nothing returns integer
    return 100
endmethod
method shouldLoop takes unit u returns boolean
    return true
endmethod
method afterLoop takes unit u returns nothing
endmethod
method ailoop takes unit u returns nothing
endmethod
method addUnit takes unit u returns nothing
    local IAIGroup cg=AIData[u].currentAIGroup
    if cg!=0 then
        call cg.removeUnit(u)
    endif
    set AIData[u].currentAIGroup=this
    call GroupAddUnit(g,u)
endmethod
method removeUnit takes unit u returns nothing
    call GroupRemoveUnit(g, u)
    set AIData[u].currentAIGroup=0
endmethod
method addpg takes unit u returns nothing
endmethod
endstruct
struct FleeGroup extends AbstractGroup
implement T32x
static method create takes nothing returns FleeGroup
    local FleeGroup dag=FleeGroup.allocate()
    set dag.g=NewGroup()
    call dag.startPeriodic()
    return dag
endmethod
method periodic takes nothing returns nothing
    local unit u
    local real rist
    local real rr
    local real dir
    local real tx
    local real ty
    loop
        set u=FirstOfGroup(g)
        exitwhen u == null
        //if GetRandomReal(0, 1) < 2 then
            set rist = 500
            set rr = GetRandomReal(-pi/4, pi/4)
            set dir = unitDir(GetNearestEnemyInGroup(u,MonsterTargetGroup), u) + rr
            set tx = GetUnitX(u) + Cos(dir) * rist
            set ty = GetUnitY(u) + Sin(dir) * rist
            call IssuePointOrderById( u, 851986, tx, ty)
        //endif
        call removeUnit(u)
        call gDefaultAIGroup.addpg(u)
    endloop
    call GroupRefresh(g)
endmethod
endstruct
struct PostAttackGroup extends IAIGroup
implement T32x
static method create takes nothing returns PostAttackGroup
    local PostAttackGroup dag=PostAttackGroup.allocate()
    set dag.g=NewGroup()
    call dag.startPeriodic()
    return dag
endmethod
method getInterval takes nothing returns integer
    return -1
endmethod
method addpg takes unit u returns nothing
endmethod
method shouldLoop takes unit u returns boolean
    return false
endmethod
method afterLoop takes unit u returns nothing
endmethod
method ailoop takes unit u returns nothing
endmethod
method addUnit takes unit u returns nothing
    call GroupAddUnit(g, u)
endmethod
method removeUnit takes unit u returns nothing 
    call GroupRemoveUnit(g, u)
endmethod
method periodic takes nothing returns nothing
    local unit u
    if ModuloInteger(Tick,10)==0 then
        loop
            set u=FirstOfGroup(g)
            exitwhen u == null
            if AIData[u].last_attack_tick > 0 then
                set AIData[u].last_attack_tick = AIData[u].last_attack_tick - 1
            else
                call GroupRemoveUnit(g,u)
                call PostAttack(u)
            endif
        endloop
        call GroupRefresh(g)
    endif
endmethod
endstruct
struct DefaultAIGroup extends IAIGroup
    implement T32x
    group pg
    boolean inpg
    static method create takes nothing returns DefaultAIGroup
        local DefaultAIGroup dag=DefaultAIGroup.allocate()
        set dag.g=NewGroup()
        set dag.tg=NewGroup()
        set dag.pg = NewGroup()
        call GroupAddGroup(dag.pg,dag.tg)
        set dag.inpg = true
        call dag.startPeriodic()
        return dag
    endmethod
    method shouldLoop takes unit u returns boolean
        return Tick - Material[u].last_issue > 150
    endmethod
    method afterLoop takes unit u returns nothing
        set Material[u].last_issue = Tick
    endmethod
    method getInterval takes nothing returns integer
        return 6
    endmethod
    method ailoop takes unit u returns nothing
        local unit tu
        local real r
        local real d
        local real x
        local real y
        local real dir
        set tu=GetNearestEnemyInGroup(u,MonsterTargetGroup)
        if tu != null and IsUnitAliveBJ(tu) then
            set d=DistanceTwoUnits(u,tu)
            if d < 5000 and EquipmentData[tu].heroData.mr > 400 then
                set dir = unitDir(tu, u)
                if GetRandomReal(0, 1) > 0.5 and RAbsBJ(dir - EquipmentData[tu].heroData.mdir) > pi/2 then
                    set x=GetUnitX(u)+d*Cos(EquipmentData[tu].heroData.mdir)
                    set y=GetUnitY(u)+d*Sin(EquipmentData[tu].heroData.mdir)
                    call IssuePointOrderById(u, 851983, x, y)
                else
                    set x=GetUnitX(tu)+(d/2)*Cos(EquipmentData[tu].heroData.mdir)
                    set y=GetUnitY(tu)+(d/2)*Sin(EquipmentData[tu].heroData.mdir)
                    call IssuePointOrderById(u, 851983, x, y)
                endif
            else
                set dir=GetRandomReal(0,3.1416)
                set r=GetRandomReal(0,d/2)
                set x = GetUnitX(tu) + r * Cos(dir)
                set y = GetUnitY(tu) + r * Sin(dir)
                call IssuePointOrderById(u, 851983, x, y)
            endif
            //call BJDebugMsg("ailoop")
            if GetUnitTypeId(u) == 'u002' then
                call BJDebugMsg("range boss 851983")
            endif
        endif
        set tu=null
    endmethod
    method onDestroy takes nothing returns nothing
        call stopPeriodic()
        call ReleaseGroup(g)
        call ReleaseGroup(tg)
        call ReleaseGroup(pg)
    endmethod
    method periodic takes nothing returns nothing
        local unit u
        if ModuloInteger(Tick,aiintervel)==0 then
        set u=FirstOfGroup(tg)
        if u==null then
            call GroupRefresh(tg)
            if IsUnitGroupEmptyBJ(pg) then
                call GroupAddGroup(g,tg)
                set inpg = false
            else
                call GroupAddGroup(pg,tg)
                call GroupAddGroup(pg, g)
                call GroupClear(pg)
                call GroupRefresh(pg)
                set inpg = true
            endif
        else
            call GroupRemoveUnit(tg,u)
            if (not inpg and IsUnitInGroup(u,g)) or (inpg and IsUnitInGroup(u, pg)) then
                if IsUnitAliveBJ(u) then
                    if shouldLoop(u) then
                        call ailoop(u)
                        call afterLoop(u)
                    endif
                else
                    call removeUnit(u)
                endif
            endif
            set u=null
        endif
        endif
    endmethod
    method addUnit takes unit u returns nothing
        local IAIGroup cg=AIData[u].currentAIGroup
        if cg!=0 then
            call cg.removeUnit(u)
        endif
        set AIData[u].currentAIGroup=this
        call GroupAddUnit(g,u)
    endmethod
    method addpg takes unit u returns nothing
        local IAIGroup cg=AIData[u].currentAIGroup
        if cg!=0 then
            call cg.removeUnit(u)
        endif
        set AIData[u].currentAIGroup=this
        if IsUnitInGroup(u, g) then
            call GroupRemoveUnit(g, u)
        endif
        call GroupAddUnit(pg,u)
    endmethod
    method removeUnit takes unit u returns nothing
        if AIData[u].currentAIGroup == this then
            set AIData[u].currentAIGroup = 0
        endif
        call GroupRemoveUnit(g,u)
        call GroupRemoveUnit(pg, u)
        call GroupRefresh(g)
        call GroupRefresh(pg)
    endmethod
endstruct

//library AIGroup ends
//library DialogSystem:
function CancelDialog takes nothing returns nothing
    local dialog d=GetClickedDialogBJ()
    local button b=GetClickedButton()
    local IDialog data = GetDialogStructA(d)
    call data.button_clicked(b)
    call DialogDisplay(data.p, d, false)
    call data.destroy()
    call ClearDialogStructA(d)
endfunction
interface IDialog
    dialog d
    trigger dtr
    player p
    string name
    button cancel_button
    button array choses[20]
    integer choses_size
    method init takes nothing returns nothing
    method display takes nothing returns nothing
    method button_clicked takes button b returns nothing
endinterface
struct DefaultDialog extends IDialog
    static method create takes string name, player p returns DefaultDialog
        local DefaultDialog g=DefaultDialog.allocate()
        set g.d=DialogCreate()
        set g.dtr=CreateTrigger()
        set g.p = p
        set g.name = name
        set g.choses_size = 0
        call DialogSetMessage(g.d,name)
        call SetDialogStructA(g.d, g)
        call TriggerRegisterDialogEvent(g.dtr, g.d)
        call TriggerAddCondition(g.dtr, Condition(function CancelDialog))
        return g
    endmethod
    method button_clicked takes button b returns nothing
    endmethod
    method init takes nothing returns nothing
    endmethod
    method onDestroy takes nothing returns nothing
        local integer i = 0
        loop
            exitwhen i >= choses_size
            if GetButtonStructA(choses[i]) != 0 then
                call ClearButtonStructA(choses[i])
                set choses[i] = null
                set i = i+1
            endif
        endloop
        call DialogClear(d)
        call DialogDestroy(d)
        call TriggerClearConditions(dtr)
        call DestroyTrigger(dtr)
        set cancel_button = null
        set d = null
        set dtr = null
        set p = null
    endmethod
    method display takes nothing returns nothing
        call init()
        set cancel_button = DialogAddButton(d,"鍙栨秷",0)
        call DialogDisplay(p,d,true)
    endmethod
endstruct
struct SelectDifficultyDialog extends DefaultDialog
    method button_clicked takes button b returns nothing
        if b == choses[2] then
            call SetDifficulty(D_HELL)
            call DisplayInfoAll("绾㈣壊鐜╁閫夋嫨浜?鐙嫾锛堝湴鐙憋級 闅惧害")
        elseif b == choses[1] then
            call SetDifficulty(D_CRAZY)
            call DisplayInfoAll("绾㈣壊鐜╁閫夋嫨浜?鍕囧＋锛堥潪甯稿洶闅撅級 闅惧害")
        else
            call SetDifficulty(D_HARD)
            call DisplayInfoAll("绾㈣壊鐜╁閫夋嫨浜?鎴愬勾绀硷紙鍥伴毦锛?闅惧害")
        endif
    endmethod
    method init takes nothing returns nothing
        local button b
        set b = DialogAddButton(d, "鎴愬勾绀硷紙鍥伴毦锛? ,0)
        set choses[choses_size] = b
        set choses_size = choses_size + 1
        set b = DialogAddButton(d, "鍕囧＋锛堥潪甯稿洶闅撅級" ,0)
        set choses[choses_size] = b
        set choses_size = choses_size + 1
        set b = DialogAddButton(d, "鐙嫾锛堝湴鐙憋級" ,0)
        set choses[choses_size] = b
        set choses_size = choses_size + 1
        set b = null
    endmethod
    method display takes nothing returns nothing
        call init()
        call DialogDisplay(p,d,true)
    endmethod
endstruct
struct ChangeAbDialog extends DefaultDialog
    integer oi
    integer ni
    integer t
    static method create takes string name, player p, integer t, integer oi, integer ni returns ChangeAbDialog
        local ChangeAbDialog g=ChangeAbDialog.allocate(name,p)
        set g.oi = oi
        set g.ni = ni
        set g.t = t
        return g
    endmethod
    method button_clicked takes button b returns nothing
        local unit u
        if b != cancel_button then
            set u = heros[GetPlayerId(p)]
            call DropItem(u, oi)
            call AddItemSpell(u, ni)
            call AddItemStaticAbility(u, ni)
            set EquipmentData[u].heroData.equips[t] = ni
        else
            set u = heros[GetPlayerId(p)]
            call DropItem(u, ni)
        endif
        set u = null
    endmethod
    method init takes nothing returns nothing
        local button b
        local string s = "鍒囨崲"
        set b = DialogAddButton(d, s ,0)
        set choses[choses_size] = b
        set choses_size = choses_size + 1
        set b = null
    endmethod
endstruct
struct ChangeGunDialog extends DefaultDialog
    integer oi
    integer ni
    integer t
    item itm
    static method create takes string name, player p, integer t, integer oi, integer ni, item itm returns ChangeGunDialog
        local ChangeGunDialog g=ChangeGunDialog.allocate(name,p)
        set g.oi = oi
        set g.ni = ni
        set g.t = t
        set g.itm = itm
        return g
    endmethod
    method button_clicked takes button b returns nothing
        local unit u
        if b != cancel_button then
            set u = heros[GetPlayerId(p)]
            call DropItem(u, oi)
            call EquipGun(u, itm)
            set EquipmentData[u].heroData.equips[t] = ni
        else
            set u = heros[GetPlayerId(p)]
            call DropItem(u, ni)
        endif
        set u = null
    endmethod
    method init takes nothing returns nothing
        local button b
        local string s = "鍒囨崲"
        set b = DialogAddButton(d, s ,0)
        set choses[choses_size] = b
        set choses_size = choses_size + 1
        set b = null
    endmethod
endstruct
struct TransformDialog extends DefaultDialog
    ItemFeatureData fd
    static method create takes string name, player p, ItemFeatureData fd returns TransformDialog
        local TransformDialog g=TransformDialog.allocate(name,p)
        set g.fd = fd
        return g
    endmethod
    method button_clicked takes button b returns nothing
        local unit hero
        local ItemFeature f
        set f = GetButtonStructA(b)
        if b != cancel_button then
            if GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD) >= (f.lv+1)*f.gold then
                if GetPlayerState(p, PLAYER_STATE_RESOURCE_LUMBER) >= (f.lv+1)*f.wood then
                    set f.lv = f.lv + 1
                    call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD) - f.lv*f.gold )
                    call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_LUMBER, GetPlayerState(p, PLAYER_STATE_RESOURCE_LUMBER) - f.lv*f.wood )
                else
                    call DisplayText(p, "鏈ㄥご涓嶅锛岄渶瑕?" +I2S((f.lv+1)*f.wood))
                endif
            else
                call DisplayText(p, "榛勯噾涓嶅锛岄渶瑕?" +I2S((f.lv+1)*f.gold))
            endif
        else
            set hero = heros[GetPlayerId(p)]
            //call CreateItem(iUPGADE,GetUnitX(hero),GetUnitY(hero))
        endif
        set hero = null
    endmethod
    method init takes nothing returns nothing
        local button b
        local string s
//textmacro instance: AddFeatureButton("1")
        if fd.f1.maxlv > 0 and fd.f1.lv < fd.f1.maxlv then
            set s = fd.f1.name + " " + "(" + I2S(fd.f1.lv) + "/" + I2S(fd.f1.maxlv) + ")" + " "
            //if fd.f1.step > 0 then
            //    set s = s + "+" + " " + R2S(fd.f1.step)
            //else
            //    set s = s + "-" + " " + R2S(-fd.f1.step)
            //endif
            //set s = s + " " + I2S(fd.f1.gold * (fd.f1.lv+1)) + "G"
            if fd.f1.wood > 0 then
                set s = s + " " + I2S(fd.f1.wood * (fd.f1.lv+1)) + "璐圭敤"
            endif
            set b = DialogAddButton(d, s ,1)
            call SetButtonStructA(b ,fd.f1)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
        endif
//end of: AddFeatureButton("1")
//textmacro instance: AddFeatureButton("2")
        if fd.f2.maxlv > 0 and fd.f2.lv < fd.f2.maxlv then
            set s = fd.f2.name + " " + "(" + I2S(fd.f2.lv) + "/" + I2S(fd.f2.maxlv) + ")" + " "
            //if fd.f2.step > 0 then
            //    set s = s + "+" + " " + R2S(fd.f2.step)
            //else
            //    set s = s + "-" + " " + R2S(-fd.f2.step)
            //endif
            //set s = s + " " + I2S(fd.f2.gold * (fd.f2.lv+1)) + "G"
            if fd.f2.wood > 0 then
                set s = s + " " + I2S(fd.f2.wood * (fd.f2.lv+1)) + "璐圭敤"
            endif
            set b = DialogAddButton(d, s ,2)
            call SetButtonStructA(b ,fd.f2)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
        endif
//end of: AddFeatureButton("2")
//textmacro instance: AddFeatureButton("3")
        if fd.f3.maxlv > 0 and fd.f3.lv < fd.f3.maxlv then
            set s = fd.f3.name + " " + "(" + I2S(fd.f3.lv) + "/" + I2S(fd.f3.maxlv) + ")" + " "
            //if fd.f3.step > 0 then
            //    set s = s + "+" + " " + R2S(fd.f3.step)
            //else
            //    set s = s + "-" + " " + R2S(-fd.f3.step)
            //endif
            //set s = s + " " + I2S(fd.f3.gold * (fd.f3.lv+1)) + "G"
            if fd.f3.wood > 0 then
                set s = s + " " + I2S(fd.f3.wood * (fd.f3.lv+1)) + "璐圭敤"
            endif
            set b = DialogAddButton(d, s ,3)
            call SetButtonStructA(b ,fd.f3)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
        endif
//end of: AddFeatureButton("3")
//textmacro instance: AddFeatureButton("4")
        if fd.f4.maxlv > 0 and fd.f4.lv < fd.f4.maxlv then
            set s = fd.f4.name + " " + "(" + I2S(fd.f4.lv) + "/" + I2S(fd.f4.maxlv) + ")" + " "
            //if fd.f4.step > 0 then
            //    set s = s + "+" + " " + R2S(fd.f4.step)
            //else
            //    set s = s + "-" + " " + R2S(-fd.f4.step)
            //endif
            //set s = s + " " + I2S(fd.f4.gold * (fd.f4.lv+1)) + "G"
            if fd.f4.wood > 0 then
                set s = s + " " + I2S(fd.f4.wood * (fd.f4.lv+1)) + "璐圭敤"
            endif
            set b = DialogAddButton(d, s ,4)
            call SetButtonStructA(b ,fd.f4)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
        endif
//end of: AddFeatureButton("4")
//textmacro instance: AddFeatureButton("5")
        if fd.f5.maxlv > 0 and fd.f5.lv < fd.f5.maxlv then
            set s = fd.f5.name + " " + "(" + I2S(fd.f5.lv) + "/" + I2S(fd.f5.maxlv) + ")" + " "
            //if fd.f5.step > 0 then
            //    set s = s + "+" + " " + R2S(fd.f5.step)
            //else
            //    set s = s + "-" + " " + R2S(-fd.f5.step)
            //endif
            //set s = s + " " + I2S(fd.f5.gold * (fd.f5.lv+1)) + "G"
            if fd.f5.wood > 0 then
                set s = s + " " + I2S(fd.f5.wood * (fd.f5.lv+1)) + "璐圭敤"
            endif
            set b = DialogAddButton(d, s ,5)
            call SetButtonStructA(b ,fd.f5)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
        endif
//end of: AddFeatureButton("5")
        set b = null
    endmethod
endstruct
struct FreeTransformDialog extends TransformDialog
    method button_clicked takes button b returns nothing
        local unit hero
        local ItemFeature f
        set f = GetButtonStructA(b)
        if b != cancel_button then
            set f.lv = f.lv + 1
        else
            set hero = heros[GetPlayerId(p)]
            call CreateItem(iFREEUP,GetUnitX(hero),GetUnitY(hero))
        endif
        set hero = null
    endmethod
endstruct
struct ButtonTech
    integer id
    static method create takes integer id returns ButtonTech
        local ButtonTech g=ButtonTech.allocate()
        set g.id = id
        return g
    endmethod
endstruct
struct ChooseTechDialog extends DefaultDialog
    
    private method heroHasTech takes unit hero, integer tech returns boolean
        return false
    endmethod
    method getHotestTech takes unit hero, integer selectId1, integer selectId2, integer selectId3, integer selectId4 returns integer
        local integer array prob
        local integer size = EquipmentData[hero].heroData.tech_counter.size
        local string s = ""
        local integer i = 0
        local integer id = -1
        local integer r = 0
        local integer j = 0
        local integer k = 0
        local integer c = 0
        local integer t = 0
        local integer l = 0 
        local integer array randtree
        local integer array randtech
        //call BJDebugMsg("-------------------------")
        //calculate proberity
        loop
            exitwhen i >= TT_COUNT
            set prob[i] = EquipmentData[hero].heroData.tech_counter.cnt[i]
            //call BJDebugMsg("prob " + I2S(i) + " " + I2S(prob[i]))
            set i = i + 1
        endloop
        
        //rand seq tech tree chose
        set k = 0
        loop
            exitwhen k > TT_COUNT - 1
            set randtree[k] = k
            set k = k + 1
        endloop
        
        set j = 0
        loop
            exitwhen j >= TT_COUNT
            set k = GetRandomInt(0, TT_COUNT - 1)
            set r = GetRandomInt(0, TT_COUNT - 1)
            if (GetRandomReal(0,1) > 0.9) or (prob[r] <= prob[k] and r < k) then
                set t = randtree[r]
                set randtree[r] = randtree[k]
                set randtree[k] = t
            endif
            set j = j + 1
        endloop
            
        //main loop tech tree
        loop
            exitwhen id > 0 or l >= TT_COUNT
            set c = randtree[l]
            //call BJDebugMsg("tech tree " + I2S(c))
            //rand seq tech chose
            set k = 0
            loop
                exitwhen k >= TECH_TREE_COUNT[c]
                set randtech[k] = k
                set k = k + 1
            endloop
            
            set j = 0
            loop
                exitwhen j >= TECH_TREE_COUNT[c]
                set k = GetRandomInt(0, TECH_TREE_COUNT[c] - 1)
                //call BJDebugMsg("rand chose " + I2S(k))
                set t = randtech[0]
                set randtech[0] = randtech[k]
                set randtech[k] = t
                set j = j + 1
            endloop
            //loop chose tech
            set i = 0
            loop
                exitwhen id > 0 or i >= TECH_TREE_COUNT[c]
                set r= randtech[i]
                //call BJDebugMsg("tech nth " + I2S(r))
                //call BJDebugMsg("tech " + I2S(TECH_TREES[c].itms[r]))
                if TECH_TREES[c].itms[r] != selectId1 and TECH_TREES[c].itms[r] != selectId2 and TECH_TREES[c].itms[r] != selectId3 and TECH_TREES[c].itms[r] != selectId4 then
                    if not heroHasTech(hero, TECH_TREES[c].itms[r]) then
                        set id = TECH_TREES[c].itms[r]
                    endif
                endif
                set i = i + 1
            endloop 
            set l = l + 1
        endloop
        return id
    endmethod
    method button_clicked takes button b returns nothing
        local ButtonTech bt
        local integer pid
        local integer id
        local string name
        if b == choses[3] then
            call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED) + 2)
            call DisplayInfo(p, "鑾峰緱涓ょ偣绉戞妧鐐?)
        else
            set bt = GetButtonStructA(b)
            set pid = GetPlayerId(p)
            set id = bt.id
            set name = LoadStr(tdht,id,tdht_name)
            call DisplayInfo(p, "浣犲浼氫簡 " + name)
            set EquipmentData[heros[GetPlayerId(p)]].heroData.up_point = EquipmentData[heros[GetPlayerId(p)]].heroData.up_point - 1
            call UnitAddAbility(techs[pid], id)
            call DispatchTechAdd(id, GetUnitAbilityLevel(techs[pid], id), pid)
        endif
    endmethod
    
    method init takes nothing returns nothing
        local button b
        local unit hero = heros[GetPlayerId(p)]
        local integer tech1 = getHotestTech(hero,-1,-1,-1,-1)
        local integer tech2 = getHotestTech(hero,tech1,-1,-1,-1)
        local integer tech3 = getHotestTech(hero,tech1,tech2,-1,-1)
        local string s1
        local string s2
        local string s3
        local string s4
        local string s5
        //local integer tech2 = getHotestTech(hero,tech1,-1,-1,-1)
//textmacro instance: AddTechButton("1")
        if tech1 > 0 then
            //call BJDebugMsg(I2S(tech1))
            set s1 = LoadStr(tdht,tech1,tdht_name)
            set b = DialogAddButton(d, s1 ,0)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
            call SetButtonStructA(b, ButtonTech.create(tech1))
            set b = null
        endif
//end of: AddTechButton("1")
//textmacro instance: AddTechButton("2")
        if tech2 > 0 then
            //call BJDebugMsg(I2S(tech2))
            set s2 = LoadStr(tdht,tech2,tdht_name)
            set b = DialogAddButton(d, s2 ,0)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
            call SetButtonStructA(b, ButtonTech.create(tech2))
            set b = null
        endif
//end of: AddTechButton("2")
//textmacro instance: AddTechButton("3")
        if tech3 > 0 then
            //call BJDebugMsg(I2S(tech3))
            set s3 = LoadStr(tdht,tech3,tdht_name)
            set b = DialogAddButton(d, s3 ,0)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
            call SetButtonStructA(b, ButtonTech.create(tech3))
            set b = null
        endif
//end of: AddTechButton("3")
        set choses[3] = DialogAddButton(d, "涓ょ偣绉戞妧鐐? ,0)
    endmethod
    
    method display takes nothing returns nothing
        call init()
        call DialogDisplay(p,d,true)
    endmethod
    
endstruct
struct ChooseBonusDialog extends DefaultDialog
    method button_clicked takes button b returns nothing
        call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD) + 100)
    endmethod
    
    method init takes nothing returns nothing
        local button b
        local unit hero = heros[GetPlayerId(p)]
        set b = DialogAddButton(d, "閲戝竵+100" ,0)
        set choses[choses_size] = b
        set choses_size = choses_size + 1
        set b = null
    endmethod
    
    method display takes nothing returns nothing
        call init()
        call DialogDisplay(p,d,true)
    endmethod
    
endstruct

//library DialogSystem ends
//library HorrorOrder:
    function HorrorMove takes unit u returns nothing
        local unit ne
        local real tx
        local real ty
        local real dir
        set ne = GetNearestEnemy(u, 800)
        if ne != null then
            set dir = getTargetDir(ne, u) + GetRandomReal(-1.5,1.5)
        else
            set dir = GetRandomReal(0, 2 * pi)
        endif
        set tx = GetUnitX(u) + 1200 * Cos(dir)
        set ty = GetUnitY(u) + 1200 * Sin(dir)
        call IssuePointOrderById( u, OI_MOVE, tx, ty )
        set ne = null
    endfunction

//library HorrorOrder ends
//library AIStrategy:
function InitAIStrategy takes nothing returns nothing
//create ai group
set gDefaultAIGroup = DefaultAIGroup.create()
set gFleeGroup = FleeGroup.create()
//create strategy
set gDefaultAIStrategy=DefaultAIStrategy.create()
set gBoss1AIStrategy = Boss1AIStrategy.create()
set gWandRanger = WandRangerAIStrategy.create()
set gFleeRanger = FleeRangerAIStrategy.create()
endfunction
interface IAIStrategy 
method targetInRange takes unit u, unit tu ,real r returns nothing
method targetOutRange takes unit u returns nothing
method beHurted takes unit u, unit ds returns nothing
method getInMap takes unit u
method postAttack takes unit u returns nothing
endinterface
struct DefaultAIStrategy extends IAIStrategy
static method create takes nothing returns DefaultAIStrategy
local DefaultAIStrategy s=DefaultAIStrategy.allocate()
return s
endmethod
method postAttack takes unit u returns nothing
endmethod
method targetInRange takes unit u, unit tu ,real r returns nothing
endmethod
method targetOutRange takes unit u returns nothing
endmethod
method beHurted takes unit u, unit ds returns nothing
if Tick - Material[u].last_issue > 150 then
    call IssuePointOrderById(u, 851983, GetUnitX(ds), GetUnitY(ds))
    set Material[u].last_issue = Tick
    set AIData[u].targetUnit = ds
endif
endmethod
method getInMap takes unit u returns nothing
call gDefaultAIGroup.addUnit(u)
endmethod
endstruct
struct Boss1AIStrategy extends DefaultAIStrategy
method targetInRange takes unit u, unit tu ,real r returns nothing
    if GetUnitTypeId(u) != 'u004' and r < 400 then
        call BJDebugMsg("change melee " + R2S(r))
        call changeMelee()
        if Tick - AIData[u].last_change > 200 then
            set AIData[u].last_change = Tick
            set AIData[u].targetUnit = tu
        endif
    endif
    if GetUnitTypeId(u) != 'u002' and r >= 400 then
        call changeRange()
    endif
endmethod
method targetOutRange takes unit u returns nothing
    if GetUnitTypeId(u) != 'u002' then
        call changeRange()
    endif
endmethod
endstruct
struct FleeRangerAIStrategy extends DefaultAIStrategy
method beHurted takes unit u, unit ds returns nothing
    call gFleeGroup.addUnit(u)
endmethod
endstruct
struct WandRangerAIStrategy extends DefaultAIStrategy
method postAttack takes unit u returns nothing
    local real tx = GetUnitX(u)
    local real ty = GetUnitY(u)
    local real rist = 1000
    local real rr = GetRandomReal(0, 2 * pi)
    local real tx2 = tx + Cos(rr) * rist
    local real ty2 = ty + Sin(rr) * rist
    call IssuePointOrderById( u, OI_MOVE, tx2, ty2)
endmethod
endstruct

//library AIStrategy ends
//library CustomDamage:
function MyDamage takes unit s, unit t, real d returns nothing
    if IsAIUnit(t) then
        call BeHurted(t, s)
    endif
    call Damage_Spell(s, t, d)
endfunction
function NormalDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    call MyDamage(source,target,finalDamage)
endfunction
function rangeOneTimeSpellDamageToUnit takes unit source ,real x ,real y ,real radius, real damage, string efs,group gro returns nothing
    local group ydl_group
    local unit ydl_unit
    set ydl_group = CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, radius,null) 
        loop
        set ydl_unit = FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if IsLiveEnemy(source,ydl_unit) and (not IsUnitInGroup(ydl_unit,gro)) and Material[ydl_unit].clazz == MC_UNIT then
            call MyDamage(source,ydl_unit,damage)
            call GroupAddUnit(gro,ydl_unit )
        endif
        endloop
    call DestroyEffect( AddSpecialEffect(efs, x, y) )
    call DestroyGroup(ydl_group)
    set ydl_group = null
    set ydl_unit = null
endfunction
function BulletDamage takes unit source, unit target, real damage, string efs returns nothing
    local real finalDamage = damage
    if IsHero(source) then
        set finalDamage = finalDamage * (1 + EquipmentData[source].heroData.bullet_buf)
    endif
    call MyDamage(source,target,finalDamage)
    call DestroyEffect( AddSpecialEffect(efs, GetUnitX(target), GetUnitY(target)) )
endfunction
function AbliDamage takes unit source, unit target, real damage, string efs returns nothing
    call MyDamage(source,target,damage)
    //call BJDebugMsg("abli dmg " + R2S(damage))
    call DestroyEffect( AddSpecialEffect(efs, GetUnitX(target), GetUnitY(target)) )
endfunction
function ExplodeDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    call MyDamage(source,target,finalDamage)
endfunction
function rangeExplodeDamage takes unit source ,real x ,real y ,real radius, real damage returns nothing
    local unit ydl_unit
    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, radius,null) 
        loop
        set ydl_unit = FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        if IsLiveEnemyUnit(source,ydl_unit) then
            call ExplodeDamage(source,ydl_unit,damage)
        endif
        endloop
    set ydl_unit = null
endfunction
function RadiationDamage takes unit target returns nothing
    local real finalDamage = 1
    local real antrad
    if IsHero(target) then
        set finalDamage = finalDamage * (1 - EquipmentData[target].heroData.antrad)
        set finalDamage = RMaxBJ(0, finalDamage)
    endif
    call SetUnitLifeBJ(target, GetUnitStateSwap(UNIT_STATE_LIFE, target) - finalDamage)
endfunction
function KillMana takes unit source, unit target, real damage returns nothing
    local real mana = GetUnitState(target, UNIT_STATE_MANA)
    local real mb
    if IsHero(source) then
        set mb = EquipmentData[source].heroData.mana_boom_percent
        call BJDebugMsg(R2S(damage))
        call BJDebugMsg(R2S(damage*mb))
        call NormalDamage(source, target, damage*mb)
        call DestroyEffect(AddSpecialEffectZ(E_MANA_BOOM,GetUnitX(target),GetUnitY(target),100))
    endif
    call SetUnitState(target,UNIT_STATE_MANA, mana - damage)
    call DestroyEffect(AddSpecialEffectZ(E_KILL_MANA,GetUnitX(target),GetUnitY(target),100))
endfunction
function IceDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    local real frezz
    if IsHero(source) then
        set frezz = EquipmentData[source].heroData.frezz
        if GetRandomReal(0,1) <= frezz then
            call Frezz(source,target,1)
        endif
    endif
    call MyDamage(source,target,finalDamage)
endfunction
function FireDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    call MyDamage(source,target,finalDamage)
endfunction
function EnergyDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    call MyDamage(source,target,finalDamage)
endfunction
function LightningDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    call MyDamage(source,target,finalDamage)
endfunction
function BladeDamage takes unit source, unit target, real damage returns nothing
    //local real finalDamage = damage
    //local real kill_mana = damage * EquipmentData[source].heroData.kill_mana_percent
    call MyDamage(source,target,damage)
    call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl", GetUnitX(target), GetUnitY(target)))
    //call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl", target, "chest"))
    if false and GetRandomReal(0, 1) < 2 then
        call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Human\\HumanBlood\\BloodElfSpellThiefBlood.mdl", target, "chest"))
    endif
endfunction
function CollisionDamage takes unit source, unit target, real damage, real dir, boolean efs returns nothing
    local real colris = Material[target].colris
    local real coldmg = Material[source].coldmg
    local real finalDamage = (damage * (1 + coldmg)) * (1 - colris)
    local real colf = Material[source].colf
    //call BJDebugMsg("aa coldmg " + R2S(coldmg))
    //call BJDebugMsg("aa colris " + R2S(colris))
    call MyDamage(source,target,finalDamage)
    if colf == 1 then
        call Stun(source, target, 3)
    endif
    if finalDamage > 50 and efs then
        call KillUnit( CreateUnit(GetOwningPlayer(source),euCOLLISION,GetUnitX(target),GetUnitY(target),dir-(pi/2) ))
    endif
endfunction
function rangeSpellDamage takes unit source ,real x ,real y ,real radius, real damage, string efs returns nothing
    local unit ydl_unit
    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, radius,null) 
        loop
        set ydl_unit = FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        if IsLiveEnemy(source,ydl_unit) then
            call MyDamage(source,ydl_unit,damage)
        endif
        endloop
    call DestroyEffect( AddSpecialEffect(efs, x, y) )
    set ydl_unit = null
endfunction
function rangeSpellDamageOneUnit takes unit source ,real x ,real y ,real radius, real damage, string efs returns nothing
    local unit t=GetNearestEnemy(source,radius)
    call MyDamage(source,t,damage)
    call DestroyEffect( AddSpecialEffect(efs, x, y) )
    set t=null
endfunction

//library CustomDamage ends
//library MonsterTargetGroup:
function InitMonsterTargetGroup takes nothing returns nothing
    set MonsterTargetGroup=NewGroup()
    set MeleeGroup = NewGroup()
    set mtm = MonsterTargetGroupManager.create()
endfunction
function BeMonsterTarget takes unit u returns nothing
    call GroupAddUnit(MonsterTargetGroup,u)
    //call BJDebugMsg("BeMonsterTarget " + I2S(CountUnitsInGroup(MonsterTargetGroup)))
endfunction
function NotMonsterTarget takes unit u returns nothing
    call GroupRemoveUnit(MonsterTargetGroup,u)
    call GroupRefresh(MonsterTargetGroup)
    //call BJDebugMsg("NotMonsterTarget")
endfunction
struct MonsterTargetGroupManager
implement T32x
static method create takes nothing returns MonsterTargetGroupManager
    local MonsterTargetGroupManager dag=MonsterTargetGroupManager.allocate()
    call dag.startPeriodic()
    return dag
endmethod
method onDestroy takes nothing returns nothing
    call stopPeriodic()
endmethod
method periodic takes nothing returns nothing
    local unit u
    local group tg
    local group ydl_group
    local unit ydl_unit
    local unit u2
    if ModuloInteger(Tick,200)==0 then
        set tg = NewGroup()
        call GroupAddGroup(MonsterTargetGroup, tg)
        set u=FirstOfGroup(tg)
        loop
            exitwhen u == null
            if IsUnitAliveBJ(u) then
                set ydl_group = NewGroup()
                call GroupEnumUnitsInRange(ydl_group, GetUnitX(u), GetUnitY(u), 1500,null)
                loop
                    set ydl_unit = FirstOfGroup(ydl_group)
                    exitwhen ydl_unit == null
                    call GroupRemoveUnit(ydl_group, ydl_unit)
                    if u != ydl_unit and IsAIUnit(ydl_unit) and IsLiveEnemyUnit(u, ydl_unit) then
                        call GroupAddUnit(MeleeGroup, ydl_unit)
                        call TargetInRange(ydl_unit, u, DistanceTwoUnits(u, ydl_unit))
                    endif
                endloop
                call ReleaseGroup(ydl_group)
                set ydl_group = null
                set ydl_unit = null
            else
                call NotMonsterTarget(u)
            endif
            call GroupRemoveUnit(tg, u)
            set u = FirstOfGroup(tg)
        endloop
        set u = null
        call GroupRefresh(tg)
        call GroupAddGroup(MeleeGroup, tg)
        loop
            set u2 = FirstOfGroup(tg)
            exitwhen u2 == null
            call GroupRemoveUnit(tg, u2)
            if DistanceTwoUnits(u2, GetNearestEnemyInGroup(u2,MonsterTargetGroup)) > 1500 then
                call GroupRemoveUnit(MeleeGroup, u2)
                call TargetOutRange(u2)
            endif
        endloop
        set u2 = null
        call ReleaseGroup(tg)
        set tg = null
    endif
endmethod
endstruct

//library MonsterTargetGroup ends
//library Transform:
function TransformCondition takes nothing returns nothing
    local unit tu = GetTriggerUnit()
    local player owner = GetOwningPlayer(tu)
    local item ti = GetManipulatedItem()
    local integer tii = GetItemTypeId(ti)
    local item target_item = null
    local ItemFeatureData fd
    local ItemTypeData data
    local IDialog d
    local integer i = 0
    local string s = " 閫夋嫨涓€涓己鍖?
    local ItemTypeData itd = 0
//textmacro instance: QuickUpgrade("iUPGADE", "iFREEUP", "AB1")
    if GetUnitTypeId(tu)== HERO and tii == iUPGADE then
        loop
            exitwhen i > 5
            set itd = getItemTypeData(GetItemTypeId(UnitItemInSlot(tu, i)))
            if itd.itemType == AB1 then
                set target_item = UnitItemInSlot(tu, i)
            endif
            set i = i + 1
        endloop
        if target_item != null then
            set data = getItemTypeData(GetItemTypeId(target_item))
            set fd = IndividualItemData[target_item].featureData
            set d = TransformDialog.create(data.name +s,owner,fd)
            call d.display()
            call data.destroy()
        endif
    elseif GetUnitTypeId(tu)== HERO and tii == iFREEUP then
        loop
            exitwhen i > 5
            set itd = getItemTypeData(GetItemTypeId(UnitItemInSlot(tu, i)))
            if itd.itemType == AB1 then
                set target_item = UnitItemInSlot(tu, i)
            endif
            set i = i + 1
        endloop
        call itd.destroy()
        if target_item != null then
            set data = getItemTypeData(GetItemTypeId(target_item))
            set fd = IndividualItemData[target_item].featureData
            set d = FreeTransformDialog.create(data.name +" 鍏嶈垂寮哄寲",owner,fd)
            call d.display()
            call data.destroy()
        else
            call CreateItem(iFREEUP,GetUnitX(heros[GetPlayerId(owner)]),GetUnitY(heros[GetPlayerId(owner)]))
        endif
    endif
//end of: QuickUpgrade("iUPGADE", "iFREEUP", "AB1")
//textmacro instance: QuickUpgrade("'I011'", "'I010'", "AB2")
    if GetUnitTypeId(tu)== HERO and tii == 'I011' then
        loop
            exitwhen i > 5
            set itd = getItemTypeData(GetItemTypeId(UnitItemInSlot(tu, i)))
            if itd.itemType == AB2 then
                set target_item = UnitItemInSlot(tu, i)
            endif
            set i = i + 1
        endloop
        if target_item != null then
            set data = getItemTypeData(GetItemTypeId(target_item))
            set fd = IndividualItemData[target_item].featureData
            set d = TransformDialog.create(data.name +s,owner,fd)
            call d.display()
            call data.destroy()
        endif
    elseif GetUnitTypeId(tu)== HERO and tii == 'I010' then
        loop
            exitwhen i > 5
            set itd = getItemTypeData(GetItemTypeId(UnitItemInSlot(tu, i)))
            if itd.itemType == AB2 then
                set target_item = UnitItemInSlot(tu, i)
            endif
            set i = i + 1
        endloop
        call itd.destroy()
        if target_item != null then
            set data = getItemTypeData(GetItemTypeId(target_item))
            set fd = IndividualItemData[target_item].featureData
            set d = FreeTransformDialog.create(data.name +" 鍏嶈垂寮哄寲",owner,fd)
            call d.display()
            call data.destroy()
        else
            call CreateItem('I010',GetUnitX(heros[GetPlayerId(owner)]),GetUnitY(heros[GetPlayerId(owner)]))
        endif
    endif
//end of: QuickUpgrade("'I011'", "'I010'", "AB2")
    set tu = null
    set owner = null
    set ti = null
    set target_item = null
endfunction
function InitTransform takes nothing returns nothing
local trigger transform_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ( transform_t, EVENT_PLAYER_UNIT_PICKUP_ITEM )
call TriggerAddCondition(transform_t,function TransformCondition)
set transform_t=null
endfunction

//library Transform ends
//library Buffer:
function MoveBufferStruct takes nothing returns nothing
    call DefaultBufferStruct.loopMoveAll()
endfunction
    
function BufferStructInit takes nothing returns nothing
    set moveTimer=CreateTimer()
    call TimerStart(moveTimer,0.02,true,function MoveBufferStruct)
endfunction
interface IBufferStruct
    unit u
    
    integer count
    
    boolean flag
    
    method condition takes nothing returns boolean
    method addBuffer takes nothing returns nothing
    
    method removeBuffer takes nothing returns nothing
    
    method finish takes nothing returns nothing
    
    method init takes unit u, integer count returns nothing
    method action takes nothing returns nothing
endinterface
struct DefaultBufferStruct extends IBufferStruct
    implement List
    
    method condition takes nothing returns boolean
        set count = count - 1
        call action()
        return count >= 0 and IsUnitAliveBJ(u)
    endmethod
    
    method action takes nothing returns nothing
    endmethod
    
    method addBuffer takes nothing returns nothing
    endmethod
    
    method removeBuffer takes nothing returns nothing
    endmethod
    
    method init takes unit u, integer count returns nothing
    endmethod
    
    method start takes nothing returns nothing
        set flag =true
        call addBuffer()
    endmethod
       
    static method create takes unit u, integer count returns DefaultBufferStruct
        local DefaultBufferStruct m=DefaultBufferStruct.allocate()
        set m.u=u
        set m.count=count
        set m.flag=false
        call m.addList()
        call m.init(u, count)
        return m
    endmethod
    
    method onDestroy takes nothing returns nothing
        if flag then
            call removeBuffer()
        endif
        set u=null
        call removeList()
        call finish()
    endmethod
    
    method finish takes nothing returns nothing
    endmethod
    
    static method loopMoveAll takes nothing returns nothing
         local boolean r
         local DefaultBufferStruct m = getFirst() 
             loop
                 exitwhen m == 0
                 if m.flag then
                     set r = m.condition()
                     if r then
                     else
                        call m.destroy()
                     endif
                     set m = m.getNext()
                 endif
             endloop
    endmethod
    
endstruct
struct BoundUnitEffectStruct extends DefaultBufferStruct
    unit eu
    
    integer uid
    
    real bais
    
    string animate
    
    real z
    
    method addBuffer takes nothing returns nothing
        set eu = CreateUnit(GetOwningPlayer(u), uid, GetUnitX(u), GetUnitY(u), bais)
        call SetUnitFlyHeight(eu,GetUnitFlyHeight(u) + z,0)
        call SetUnitAnimation( eu, animate )
    endmethod
    
    method action takes nothing returns nothing
        call SetUnitX(eu, GetUnitX(u))
        call SetUnitY(eu, GetUnitY(u))
        call SetUnitFlyHeight(eu,GetUnitFlyHeight(u) + z,0)
    endmethod
    
    method removeBuffer takes nothing returns nothing
        call KillUnit(eu)
    endmethod
    
    static method create takes unit u, integer count, integer uid, real bais, string animate, real z returns BoundUnitEffectStruct
        local BoundUnitEffectStruct m=BoundUnitEffectStruct.allocate(u, count)
        set m.uid = uid
        set m.bais = bais
        set m.animate = animate
        set m.z = z
        return m
    endmethod
    
    method finish takes nothing returns nothing
        set eu=null
    endmethod
    
endstruct
struct ElectricWhipBufferStruct extends DefaultBufferStruct
    unit source
       
    real dam
    
    vector pref
    
    private lightning l
    method condition takes nothing returns boolean
        local real dis = DistanceTwoUnits(source, u)
        set count = count - 1
        call action()
        return count >= 0 and dis > 200 and IsUnitAliveBJ(source) and IsUnitAliveBJ(u)
    endmethod
    
    private method removef takes vector v returns nothing
        call Velocity[u].a.subtract(v)
    endmethod
    
    private method addf takes vector v returns nothing
        call Velocity[u].a.add(v)
    endmethod
    
    private method getReturnForce takes nothing returns vector
        local real fl = 0.5
        local vector v = Velocity[u].v
        local real len = v.getLength()
        local vector dir = getDirVector(u, source, fl*5)
        local real angle = vector.getAngle(v, dir)
        local real a = Sin(angle) * len
        local real sd
        local vector r
        local real dl
        if angle >= (pi / 2) then
            set sd = len
        else
            set sd = a
        endif
        if sd > fl then
            set r = vector.create(-v.x,-v.y,-v.z)
            call r.setLength(RMinBJ(len, fl))
            call r.add(dir)
            call dir.destroy()
            return r
        else
            if angle >= (pi / 2) then
                set dl = SquareRoot(fl*fl - a*a) - SquareRoot(len*len - a*a)
            else
                set dl = SquareRoot(fl*fl - a*a) + SquareRoot(len*len - a*a)
            endif
            set r = vector.create(dir.x,dir.y,dir.z)
            call r.setLength(dl)
            call r.subtract(v)
            call r.add(dir)
            call dir.destroy()
            return r
        endif
        return dir
    endmethod
    method addBuffer takes nothing returns nothing
        set l = AddLightningEx( "CLPB", false, GetUnitX(source),GetUnitY(source),getUnitHeight(source), GetUnitX(u), GetUnitY(u),getUnitHeight(u) )
    endmethod
    
    method action takes nothing returns nothing
        local vector returnForce
        set returnForce = getReturnForce()
        call removef( pref)
        set pref.x = returnForce.x
        set pref.y = returnForce.y
        set pref.z = returnForce.z
        call returnForce.destroy()
        call addf( pref)
        call LightningDamage(source, u, dam/50)
        call MoveLightningEx( l, false, GetUnitX(source),GetUnitY(source),getUnitHeight(source), GetUnitX(u), GetUnitY(u),getUnitHeight(u))
    endmethod
    
    method removeBuffer takes nothing returns nothing
        call DestroyLightning(l)
        call removef(pref)
        call pref.destroy()
        set l = null
        set source = null
        set u = null
    endmethod
    
    static method create takes unit u, integer count, unit source, real dam returns ElectricWhipBufferStruct
        local ElectricWhipBufferStruct m = ElectricWhipBufferStruct.allocate(u, count)
        set m.source = source
        set m.dam = dam
        set m.pref = vector.create(0,0,0)
        return m
    endmethod
    
    method finish takes nothing returns nothing
    endmethod
    
endstruct

//library Buffer ends
//library Radiation:
function DoRadiationCondition takes nothing returns nothing
    local integer i = 0
    loop
        exitwhen i > 4 
        if heros[i] != null and IsUnitAliveBJ(heros[i]) and UnitHasBuffBJ(heros[i], 'B004') then
            call RadiationDamage(heros[i])
        endif
        set i = i + 1
    endloop
endfunction
function InitRadiation takes nothing returns nothing
local trigger doRadiation_t=CreateTrigger()
call TriggerAddCondition(doRadiation_t,function DoRadiationCondition)
call TriggerRegisterTimerEventPeriodic( doRadiation_t, 1.00 )
set doRadiation_t=null
endfunction

//library Radiation ends
//library Stage1:
function SetupStage1 takes nothing returns nothing
    
endfunction
function Stage1Clear takes nothing returns nothing
    local unit ydl_unit
    //clear wall1
    call GroupEnumUnitsInRect(ENUM_GROUP, gg_rct_stage1_wall1,null)
    loop
        set ydl_unit = FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        if GetUnitTypeId(ydl_unit) == 'h006' then
            call KillUnit(ydl_unit)
        endif
    endloop
    call RegionAddRect(playable_region, gg_rct_stage1_exit)
    call RegionAddRect(playable_region, gg_rct_stage2_1)
    call RegionAddRect(playable_region, gg_rct_stage2_2)
    call RegionAddRect(playable_region, gg_rct_stage2_3)
    call RegionAddRect(playable_region, gg_rct_stage2_4)
    call RegionAddRect(playable_region, gg_rct_stage2_5)
    call RegionAddRect(playable_region, gg_rct_stage2_6)
    call RegionAddRect(playable_region, gg_rct_stage2_7)
    call RegionAddRect(playable_region, gg_rct_stage2_8)
    call RegionAddRect(playable_region, gg_rct_stage2_fire1)
    call RegionAddRect(playable_region, gg_rct_stage2_fire2)
    call RegionAddRect(playable_region, gg_rct_stage2_fire3)
    set ydl_unit = null
    set fire_region = CreateRegion()
    call RegionAddRect(fire_region, gg_rct_stage2_fire1)
    call RegionAddRect(fire_region, gg_rct_stage2_fire2)
    call RegionAddRect(fire_region, gg_rct_stage2_fire3)
endfunction
function Stage1Wave3 takes nothing returns nothing
    //call BJDebugMsg("s1w3c " + I2S(s1w3c))
    if s1w3c > 0 then
        //call SummonMonster('u000', gg_rct_stage1)
        //call SummonMonster('u005', gg_rct_stage1)
        if s1w3c <= 3 then
            call SummonMonster('u005', gg_rct_stage1)
        else
            call SummonMonster('u000', gg_rct_stage1)
        endif
        set s1w3c = s1w3c - 1
    else
        if GetPlayerState(Player(11), PLAYER_STATE_RESOURCE_FOOD_USED) == 0 then
            call DestroyTimer(GetExpiredTimer())
            //call BJDebugMsg("stage1 smmon finish")
        endif
    endif
endfunction
function Stage1Wave2 takes nothing returns nothing
    //call BJDebugMsg("s1w2c " + I2S(s1w2c))
    local real r
    if s1w2c > 0 then
        set s1w2c = s1w2c - 1
        set r = GetRandomReal(0, 1)
        if r <= 0.1 then
            call SummonMonster('u006', gg_rct_stage1)
        //elseif r <= 0.15 then
            //call SummonMonster('u007', gg_rct_stage1)
        else
            call SummonMonster('u000', gg_rct_stage1)
        endif
        //call SummonMonster('u000', gg_rct_stage1)
    else
        if GetPlayerState(Player(11), PLAYER_STATE_RESOURCE_FOOD_USED) == 0 then
            //call TimerStart(CreateTimer(), 1, true, function Stage1Wave3)
            call DestroyTimer(GetExpiredTimer())
            set g_ge = false
            call Stage1Clear()
        endif
    endif
endfunction
function Stage1Wave1 takes nothing returns nothing
    //call BJDebugMsg("s1w1c " + I2S(s1w1c))
    if s1w1c > 0 then
        set s1w1c = s1w1c - 1
        call SummonMonster('u006', gg_rct_stage1)
    else
        if GetPlayerState(Player(11), PLAYER_STATE_RESOURCE_FOOD_USED) == 0 then
            call TimerStart(CreateTimer(), 1, true, function Stage1Wave2)
            call DestroyTimer(GetExpiredTimer())
        endif
    endif
endfunction
function Stage1Mission takes nothing returns nothing
    local integer i = 0
    local location l 
    local unit hero
    loop
        exitwhen i >= PLAYER_COUNT
        if CurrentPlaying(Player(i)) then
            set l = GetRandomLocInRect(gg_rct_stage1_hero)
            set hero = CreateUnit(Player(i),HERO,GetLocationX(l), GetLocationY(l),0)
            call RegisterReviveSystem(hero)
            call BeHealth(GetPlayerId(GetOwningPlayer(hero)))
            call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl", l))
            set heros[i] = hero
            set mode_tip[i] = 3
            if herosType[i] == 'H00B' then
                call UnitAddAbility(hero, 'A028')
                call UnitAddAbility(hero, 'A029')
            else
                call UnitAddAbility(hero, 'A02E')
                call UnitAddAbility(hero, 'A02F')
            endif
            call BeMonsterTarget(hero)
            call EquipGunV2(hero)
            //call SetCameraBoundsToRectForPlayerBJ( Player(i), gg_rct_stage1)
            call PanCameraToTimedForPlayer(Player(i), GetLocationX(l), GetLocationY(l), 0)
        endif
        set i = i + 1
    endloop
    set hero = null
    set l = null
    call PlaySoundBJ( gg_snd_alicebeep )
    call DisplayInfoAll("鏂颁换鍔★細娓呯悊涓€鍙峰尯鍩?)
    //call CinematicFadeBJ( bj_CINEFADETYPE_FADEIN, 2, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 0, 0, 0, 0 )
    call TimerStart(CreateTimer(), 1, true, function Stage1Wave1)
    set g_gr2 = CreateRegion()
    call RegionAddRect(g_gr2, gg_rct_stage1)
    set g_gx1 = GetRectMinX(gg_rct_stage1)
    set g_gx2 = GetRectMaxX(gg_rct_stage1)
    set g_gy1 = GetRectMinY(gg_rct_stage1)
    set g_gy2 = GetRectMaxY(gg_rct_stage1)
    set r_m_yaocao = 10
    set g_ge = true
    set playable_region = CreateRegion()
    call RegionAddRect(playable_region, gg_rct_stage1)
endfunction
function EquipSound takes nothing returns nothing
    call PlaySoundBJ( gg_snd_equip1 )
endfunction
function EquipSound2 takes nothing returns nothing
    call PlaySoundBJ( gg_snd_equip2 )
endfunction
function StartStage1 takes nothing returns nothing
    //call CinematicFadeBJ( bj_CINEFADETYPE_FADEOUT, 2, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 0, 0, 0, 0 )
    //call TimerStart(CreateTimer(), 3, false, function EquipSound)
    //call TimerStart(CreateTimer(), 5, false, function EquipSound2)
    //call TimerStart(CreateTimer(), 10, false, function Stage1Mission)
    call Stage1Mission()
endfunction
function InitStage1 takes nothing returns nothing
    local trigger trg = CreateTrigger()
    local unit t = null
    local timer tim
    local integer i = 0
    local location l
    //call TriggerRegisterPlayerSelectionEventBJ( trg, Player(0), true )
    //call TriggerRegisterPlayerSelectionEventBJ( trg, Player(1), true )
    //call TriggerRegisterPlayerSelectionEventBJ( trg, Player(2), true )
    call CreateFogModifierRectBJ( true, Player(0), FOG_OF_WAR_VISIBLE, gg_rct_pick_hero )
    call CreateFogModifierRectBJ( true, Player(1), FOG_OF_WAR_VISIBLE, gg_rct_pick_hero )
    call CreateFogModifierRectBJ( true, Player(2), FOG_OF_WAR_VISIBLE, gg_rct_pick_hero )
    //call TriggerAddAction(trg, function PickHeroActions)
    call CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), 'h009', 1278, -1770, 0)
    call CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), 'n001', GetRectCenterX(gg_rct_pow0), GetRectCenterY(gg_rct_pow0), 0)
    call CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), 'n001', GetRectCenterX(gg_rct_pow1), GetRectCenterY(gg_rct_pow1), 0)
    call CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), 'n001', GetRectCenterX(gg_rct_pow2), GetRectCenterY(gg_rct_pow2), 0)
    call CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), 'n001', GetRectCenterX(gg_rct_pow3), GetRectCenterY(gg_rct_pow3), 0)
    //set t = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), 'h00D', GetRectCenterX(gg_rct_stage1_tlcannon), GetRectCenterY(gg_rct_stage1_tlcannon), 0)
    //call TriggerRegisterUnitManaEvent( gg_trg_ManaChange, t, LESS_THAN, 0.50 )
    //call TriggerRegisterUnitManaEvent( gg_trg_ManaGrow, t, GREATER_THAN, 2)
    call CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), 'H00B', 5626, 6151, -pi/2 * bj_RADTODEG)
    call CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), 'H00C', 6142, 6151, -pi/2 * bj_RADTODEG)
    //call SetCameraBoundsToRectForPlayerBJ( Player(0), gg_rct_pick_hero )
    //call SetCameraBoundsToRectForPlayerBJ( Player(1), gg_rct_pick_hero )
    //call SetCameraBoundsToRectForPlayerBJ( Player(2), gg_rct_pick_hero )
    loop
        exitwhen i >= PLAYER_COUNT
        if CurrentPlaying(Player(i)) then
            set l = GetRandomLocInRect(gg_rct_mancome)
            call CreateUnit(Player(i), 'n002', GetLocationX(l), GetLocationY(l), GetRandomReal(0, 2*pi) * bj_RADTODEG)
        endif
        set i = i +1
    endloop
    set trg = null
    set l = null
    set t = null
endfunction

//library Stage1 ends
//library PhysicsSystem:
function AddVelocity takes unit u, vector n returns nothing
    call Velocity[u].v.add(n)
endfunction
function ClearVelocity takes unit u returns nothing
    call Velocity[u].v.setLength(0)
    call Velocity[u].a.setLength(0)
endfunction
function AddForce takes unit u, vector a returns nothing
    call Velocity[u].a.add(a)
endfunction
function RemoveForce takes unit u, vector a returns nothing
    call Velocity[u].a.subtract(a)
endfunction
function Push takes unit u, real dir, real d, real h, integer s returns nothing
    local real d2 = (1 - Material[u].pushris) * d
    local vector a = vector.create(d2*Cos(dir),d2*Sin(dir), h)
    local PushForceStruct pfs = PushForceStruct.create(u, s, a)
    call pfs.start()
endfunction
struct PushForceStruct extends DefaultBufferStruct
    vector fc
    method condition takes nothing returns boolean
        set count = count - 1
        call action()
        return count >= 0
    endmethod
    method addBuffer takes nothing returns nothing
        call AddForce(u, fc)
    endmethod
    
    method removeBuffer takes nothing returns nothing
        call RemoveForce(u, fc)
    endmethod
    
    static method create takes unit u, integer count, vector fc returns PushForceStruct
        local PushForceStruct m=PushForceStruct.allocate(u, count)
        set m.fc=fc
        return m
    endmethod
    
    method finish takes nothing returns nothing
        call fc.destroy()
    endmethod
    
endstruct

//library PhysicsSystem ends
//library EquipmentData:
struct EquipmentData extends array
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()
    
    implement T32xs
    
    IGun gun
    
    IHeroData heroData
    
    static method AIDS_filter takes unit u returns boolean
        if IsHero(u) or GetUnitTypeId(u) == EVIL_MARIN then
            return true
        endif
        return false
    endmethod
    
    private method AIDS_onCreate takes nothing returns nothing
        local integer i = 0
        //set this.gun = IceMachineGun.create(.unit)
        set this.heroData = IHeroData.create()
        set this.heroData.bullets = gun.shooter.getClipSize()
        set this.heroData.shoot_energy_max = 100
        set this.heroData.shoot_energy = 100
        set this.heroData.shoot_energy_reg = 1
        set this.heroData.shoot_range_buff = 0
        //set this.heroData.shoot_speed_buff = 0.0
        //set this.heroData.last_shoot_tick = -999
        set this.heroData.reload = false
        set this.heroData.shoot_rist = 0.0
        set this.heroData.a_shoot_back = 0.0
        set this.heroData.a_shoot_back_log = 0.0
        set this.heroData.kill_mana_percent = 0.0
        set this.heroData.mana_boom_percent = 0.0
        set this.heroData.up_point = 10
        set this.heroData.bonus_point = 0
        set this.heroData.tech_counter = TechCounter.create()
        set this.heroData.tech_counter.cnt[TT_GENERAL] = 1
        set this.heroData.tech_counter.size = 1
        set this.heroData.save = 0.0
        set this.heroData.strong = 0.0
        set this.heroData.antrad = 0.0
        set this.heroData.doge = 0
        set this.heroData.frezz = 0.0
        set this.heroData.fire_charge = 1.0
        set this.heroData.machine_gun_buff = 1.0
        set this.heroData.vision = 2000
        set this.heroData.reloade = null
        set this.heroData.ee = null
        set this.heroData.smartDartsCount = 0
        set this.heroData.mx = 0
        set this.heroData.my = 0
        set this.heroData.mr = 0
        set this.heroData.mdir = 0
        set this.heroData.bullet_buf = 0
        set this.heroData.gamble_buf = 0
        set this.heroData.shoot_count = 6
        set this.heroData.shoot_tick = 4
        set this.heroData.clip_size = 60
        set this.heroData.melee_interval = 38
        set this.heroData.reload_cost = 10
        set this.heroData.energy_consum = 1
        set this.heroData.speedup = false
        set this.heroData.jump_refresh = false
        set this.heroData.transport= false
        loop
            exitwhen i >=5
            set this.heroData.smartDarts[i] = 0
            set i = i + 1
        endloop
        call startPeriodic()
        call AIDS_addLock()
    endmethod
        
    private method AIDS_onDestroy takes nothing returns nothing
        
    endmethod
    private method AimLoop takes nothing returns nothing
        if this.heroData.aimu != null then
            call SetUnitX(this.heroData.aimu, GetUnitX(.unit) + 12)
            call SetUnitY(this.heroData.aimu, GetUnitY(.unit) + 10)
            if not EquipmentData[.unit].heroData.reload and EquipmentData[.unit].heroData.shoot_buffer > 0 and ModuloInteger(Tick,EquipmentData[.unit].heroData.shoot_tick) == 0 and IsUnitAliveBJ(.unit) then
                call EquipmentData[.unit].gun.fire()
                call SetUnitAnimationByIndex(.unit, 2)
                //call SetUnitFacing(.unit, EquipmentData[.unit].heroData.jump_direction * bj_RADTODEG)
                set EquipmentData[.unit].heroData.shoot_buffer = EquipmentData[.unit].heroData.shoot_buffer - 1
            endif
        endif
    endmethod
    private method MeleeLoop takes nothing returns nothing
        local unit target
        local real dir
        local real x
        local real y
        local unit ydl_unit
        if GetUnitAbilityLevel(.unit, 'A026') > 0 and IsUnitAliveBJ(.unit) and GetUnitAbilityLevel(.unit, 'A02H') == 0 then
            if EquipmentData[.unit].heroData.melee_cooldown <= 0 then
                set target = GetNearestEnemy(.unit, 350)
                if target != null and RAbsBJ(getUnitHeight(target) - getUnitHeight(.unit)) <= 100 and (not IsUnitInvisible(target, GetOwningPlayer(.unit))) then
                    set dir=Atan2(GetUnitY(target) - GetUnitY(.unit), GetUnitX(target) - GetUnitX(.unit))
                    set x=GetUnitX(.unit) + 100 * Cos(dir)
                    set y=GetUnitY(.unit) + 100 * Sin(dir)
                    call KillUnit(CreateUnit(GetOwningPlayer(.unit), 'e00L', x, y, dir*bj_RADTODEG))
                    set EquipmentData[.unit].heroData.melee_cooldown = EquipmentData[.unit].heroData.melee_interval
                    //damage
                    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, 300,null) 
                    loop
                        set ydl_unit = FirstOfGroup(ENUM_GROUP)
                        exitwhen ydl_unit == null
                        call GroupRemoveUnit(ENUM_GROUP, ydl_unit) 
                        if IsLiveEnemyUnit(.unit,ydl_unit) and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(.unit)) <= 100 then
                            call Push(ydl_unit, getTargetDir(.unit, ydl_unit), 5.5, 0, 5)
                            //call PlaySoundOnUnitBJ(gg_snd_togglemeele, 100, .unit)
                            call BladeDamage(.unit, ydl_unit, 120)
                        endif
                    endloop
                endif
            else
                set EquipmentData[.unit].heroData.melee_cooldown = EquipmentData[.unit].heroData.melee_cooldown - 1
            endif
        endif
        set target = null
        set ydl_unit = null
    endmethod
    private method FireLoop takes nothing returns nothing
        if ModuloInteger(Tick,10) == 0 then
            if this.heroData.fe != null then
                call DestroyEffect(this.heroData.fe)
                set this.heroData.fe = null
            endif
            if GetUnitAbilityLevel(.unit, 'A02H') == 0 and IsPointInRegion(fire_region, GetUnitX(.unit), GetUnitY(.unit)) and getUnitHeight(.unit) < -200 then
                set this.heroData.fe = AddSpecialEffectTarget("Environment\\LargeBuildingFire\\LargeBuildingFire0.mdl",.unit,"chest")
                call SetUnitLifeBJ(.unit, RMaxBJ(1, GetUnitState(.unit, UNIT_STATE_LIFE) - 5))
            endif
        endif
    endmethod
    private method HitWallLoop takes nothing returns nothing
        if Material[.unit].nohitwall > 0 then
            set Material[.unit].nohitwall = Material[.unit].nohitwall - 1
        endif
    endmethod
    private method EnergyLoop takes nothing returns nothing
        if ModuloInteger(Tick,50) == 0 then
            if this.heroData.ee != null then
                call DestroyEffect(this.heroData.ee)
                set this.heroData.ee = null
            endif
            if GetUnitAbilityLevel(.unit, 'A02H') == 0 then
                if ModuloInteger(Tick,200) == 0 and GetUnitState(.unit, UNIT_STATE_MANA) <= 0 then
                    set this.heroData.ee = AddSpecialEffectTarget("Abilities\\Spells\\Orc\\Purge\\PurgeBuffTarget.mdl",.unit,"origin")
                    call SetUnitLifeBJ(.unit, RMaxBJ(1, GetUnitState(.unit, UNIT_STATE_LIFE) - 20))
                    call DisplayWarning(GetOwningPlayer(.unit), "缁寸敓绯荤粺宸插仠姝㈣繍浣滐紝璇峰敖蹇ˉ鍏呰兘閲?)
                else
                    call SetUnitManaBJ(.unit, GetUnitState(.unit, UNIT_STATE_MANA) - EquipmentData[.unit].heroData.energy_consum)
                    //call DisplayManaCostSmall(.unit, EquipmentData[.unit].heroData.energy_consum)
                endif
            endif
        endif
    endmethod
    private method AdjustAiIntervel takes nothing returns nothing
        local integer uf
        if ModuloInteger(Tick,200) == 0 then
            if CurrentPlaying(GetOwningPlayer(.unit)) then
                call BeMonsterTarget(.unit)
            else
                call NotMonsterTarget(.unit)
            endif
            set uf = GetPlayerState(Player(11), PLAYER_STATE_RESOURCE_FOOD_USED)
            if uf > 300 then
                set aiintervel = 15
                call BJDebugMsg("ai15")
            elseif uf > 200 then
                set aiintervel = 10
                call BJDebugMsg("ai10")
            elseif uf > 100 then
                set aiintervel = 6
            else
                set aiintervel = 3
            endif
            //call BJDebugMsg("AI interval " + I2S(aiintervel))
        endif
    endmethod
    private method PredictMoveDirection takes nothing returns nothing
        local real x
        local real y
        local real d
        local real r
        if ModuloInteger(Tick,100) == 0 then
            set x = GetUnitX(.unit)
            set y = GetUnitY(.unit)
            set d = getDir(this.heroData.mx, this.heroData.my, x, y)
            set r = DistanceTwo(x, y, this.heroData.mx, this.heroData.my)
            set this.heroData.mdir = d
            set this.heroData.mx = x
            set this.heroData.my = y
            set this.heroData.mr = r
        endif
    endmethod
    
    method periodic takes nothing returns nothing
        local boolean reload = this.heroData.reload
        local real c = this.heroData.shoot_energy
        local real max = this.heroData.shoot_energy_max
        local real n = RMinBJ(max, c + this.heroData.shoot_energy_reg)
        local location l = null
        if reload and c < max then
            set this.heroData.shoot_energy = n
            if n == max then
                if IsHero(.unit) and GetUnitState(.unit, UNIT_STATE_MANA) >= EquipmentData[.unit].heroData.reload_cost then
                    set this.heroData.reload = false
                    call UnitRemoveAbility(.unit, 'Abun')
                    call SetUnitState(.unit, UNIT_STATE_MANA, GetUnitState(.unit, UNIT_STATE_MANA) - EquipmentData[.unit].heroData.reload_cost)
                    call SetPlayerState(GetOwningPlayer(.unit),PLAYER_STATE_RESOURCE_FOOD_USED, EquipmentData[.unit].heroData.clip_size)
                    call DisplayManaCost(.unit, EquipmentData[.unit].heroData.reload_cost)
                    //call DisplayFloatText(GetUnitX(.unit),GetUnitY(.unit),"瑁呭脊瀹屾垚锛?"+I2S(EquipmentData[.unit].heroData.reload_cost),1)
                    call PlaySoundOnUnitBJ( gg_snd_clipin1, 100,.unit)
                    //call SetSoundPosition( gg_snd_clipin1, GetUnitX(.unit), GetUnitY(.unit), 0 )
                    //call SetSoundPosition( gg_snd_clipin1, 0,0, 0 )
                    //call PlaySoundBJ( gg_snd_clipin1 )
                    //set l = Location(0,0)
                    //call PlaySoundAtPointBJ( gg_snd_clipin1, 100, l, 0 )
                    //call RemoveLocation(l)
                    if EquipmentData[.unit].heroData.reloade != null then
                        call DestroyEffect(EquipmentData[.unit].heroData.reloade)
                        set EquipmentData[.unit].heroData.reloade = null
                    endif
                else
                    set this.heroData.reload = false
                    call UnitRemoveAbility(.unit, 'Abun')
                    set this.heroData.bullets = gun.shooter.getClipSize()
                    call DisplayFloatText(GetUnitX(.unit),GetUnitY(.unit),"瑁呭脊瀹屾垚锛?,1)
                endif
            endif
        endif
        call EnergyLoop()
        call AimLoop()
        call PredictMoveDirection()
        call AdjustAiIntervel()
        call MeleeLoop()
        call FireLoop()
        call HitWallLoop()
    endmethod 
    
endstruct

//library EquipmentData ends
//library Missle:
function missleRangeOneTimeActionToUnit takes IMissle source ,real x ,real y ,real radius,group gro returns nothing
    local group ydl_group
    local unit ydl_unit
    //set ydl_group = NewGroup()
    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, radius,null) 
        loop
        set ydl_unit = FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        //if DistanceUnitAndXY(ydl_unit,x,y) <= Material[ydl_unit].volume + radius then
        
            if IsLiveEnemyUnitOrDestroyableWall(source.owner,ydl_unit) and (not IsUnitInGroup(ydl_unit,gro)) then
                call source.debuffEnemy(ydl_unit)
                call source.damageEnemy(ydl_unit)
                call GroupAddUnit(gro,ydl_unit )
            elseif IsLiveAllyUnit(source.owner,ydl_unit) and (not IsUnitInGroup(ydl_unit,gro)) then
            //call BJDebugMsg("fdsa")
                call source.healAlly(ydl_unit)
                call GroupAddUnit(gro,ydl_unit)
            elseif IsUnitAliveBJ(ydl_unit) and ydl_unit == source.owner and source.origin_life - source.life > LEAVE_COUNT then
                call source.hitSelf(ydl_unit)
                call GroupAddUnit(gro,ydl_unit )
            endif
        //endif
        endloop
    //call ReleaseGroup(ydl_group)
    //set ydl_group = null
    set ydl_unit = null
endfunction
//copy of first method
function missleRangeOneTimeExplodeToUnit takes IMissle source ,real x ,real y ,real radius returns nothing
    local group ydl_group
    local unit ydl_unit
    //set ydl_group = NewGroup()
    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, radius,null) 
        loop
        set ydl_unit = FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        //if DistanceUnitAndXY(ydl_unit,x,y) <= Material[ydl_unit].volume + radius then
        
            if IsLiveEnemyUnitOrDestroyableWall(source.owner,ydl_unit) then
                call source.debuffExplodeEnemy(ydl_unit)
                call source.damageExplodeEnemy(ydl_unit)
            endif
        //endif
        endloop
    //call ReleaseGroup(ydl_group)
    //set ydl_group = null
    set ydl_unit = null
endfunction
interface IMissle
    
    unit missle
    unit owner
    integer life
    integer origin_life
    group damaged
    boolean started
    method doDamage takes real radius returns nothing
    method getFinalDamage takes nothing returns real
    method fireMissle takes vector vi returns nothing
    method onFire takes nothing returns nothing
    method getOriginalDamage takes nothing returns real
    method getMissleId takes nothing returns integer
    method step takes nothing returns nothing
    method getLife takes nothing returns integer
    method substep takes nothing returns nothing
    method explode takes nothing returns nothing
    method damageEnemy takes unit target returns nothing
    method debuffEnemy takes unit target returns nothing
    method debuffExplodeEnemy takes unit target returns nothing
    method damageExplodeEnemy takes unit target returns nothing
    method healAlly takes unit target returns nothing
    method hitSelf takes unit self returns nothing
    method refreshDamagedGroup takes nothing returns nothing
    method troughDamage takes unit target returns nothing
    method alwaysTrough takes nothing returns boolean
endinterface
struct Missle extends IMissle
    method getMissleId takes nothing returns integer
        return 'e000'
    endmethod
    
    method refreshDamagedGroup takes nothing returns nothing
        local group newGroup
        local unit ydl_unit
        if not IsUnitGroupEmptyBJ(damaged) then
            set newGroup = CreateGroup()
            loop
            set ydl_unit = FirstOfGroup(damaged)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(damaged, ydl_unit)
            if DistanceTwoUnits(missle, ydl_unit) <= REDAMAGE_DISTANCE then
                call GroupAddUnit(newGroup, ydl_unit)
            endif
            endloop
            set damaged = newGroup
        endif
        set newGroup = null
        set ydl_unit = null
    endmethod
    method troughDamage takes unit target returns nothing
    endmethod
    method alwaysTrough takes nothing returns boolean
        return false
    endmethod
    method debuffExplodeEnemy takes unit target returns nothing
    endmethod
    method damageExplodeEnemy takes unit target returns nothing
    endmethod
    
    method doDamage takes real radius returns nothing
        local real x = GetUnitX(missle)
        local real y = GetUnitY(missle)
        call missleRangeOneTimeActionToUnit(this,x,y,radius,damaged)
    endmethod
    
    method damageEnemy takes unit target returns nothing
        call BulletDamage(owner, target, getFinalDamage(), SMALL_BLOOD)
        call destroy()
    endmethod
    
    method debuffEnemy takes unit target returns nothing
    endmethod
    
    method healAlly takes unit target returns nothing
        //call HealUnit(owner, target, 50, HEAL_TYPE_NORMAL)
        //call destroy()
    endmethod
    
    method hitSelf takes unit self returns nothing
    endmethod
    
    
    method fireMissle takes vector vi returns nothing
        set missle = CreateUnit(GetOwningPlayer(owner), getMissleId(), GetUnitX(owner), GetUnitY(owner), getDeg(vi.y, vi.x))
        if GetUnitFlyHeight(owner) > g_sd_th then
            call SetUnitFlyHeight(missle, GetUnitFlyHeight(owner), 0)
        endif
        set life = getLife()
        set origin_life = life
        call onFire()
        set started = true
        call Velocity[missle].v.destroy()
        set Velocity[missle].v = vi
        set Velocity[missle].missleStruct = this
    endmethod
    
    method onFire takes nothing returns nothing
    endmethod
    
    method substep takes nothing returns nothing
    endmethod
    
    method getLife takes nothing returns integer
        return 30
    endmethod
    
    static method create takes unit owner returns Missle
        local Missle m=Missle.allocate()
        //set m.damaged=NewGroup()
        set m.damaged=CreateGroup()
        set m.owner=owner
        set m.started=false
        return m
    endmethod
    
    method step takes nothing returns nothing
        set life = life - 1
        call substep()
        if life <= 0 then
            call destroy()
        endif
    endmethod
    
    method getFinalDamage takes nothing returns real
        local real od = getOriginalDamage()
        return od
    endmethod
    
    method getOriginalDamage takes nothing returns real
        return 50.0
    endmethod
    
    method hitGround takes nothing returns nothing
        call destroy()
    endmethod
    
    method explode takes nothing returns nothing
        //call BJDebugMsg("explode")
    endmethod
    
    method onDestroy takes nothing returns nothing
        call explode()
        set owner=null
        call KillUnit(missle)
        call GroupClear(damaged)
        call DestroyGroup(damaged)
        //call GroupRefresh(damaged)
        //call ReleaseGroup(damaged)
        set damaged = null
        set missle=null
    endmethod
    
endstruct
struct TroughMissle extends Missle
    
    method damageEnemy takes unit target returns nothing
        local real consume
        call troughDamage(target)
        if not alwaysTrough() then
            set consume = ( Material[target].hardness * Material[target].volume ) / 100
            if life <= consume then
                call destroy()
            else
                set life = life - R2I(consume)
            endif
        endif
    endmethod
    
    method troughDamage takes unit target returns nothing
        call BulletDamage(owner, target, getFinalDamage(), SMALL_BLOOD)
    endmethod
    
endstruct
struct ShootGunMissle extends Missle
    method getLife takes nothing returns integer
        return 15
    endmethod
endstruct
struct IceMissle extends Missle
    method getMissleId takes nothing returns integer
        return bICE_MISSLE
    endmethod
    
    method damageEnemy takes unit target returns nothing
        call IceDamage(owner, target, getFinalDamage())
        call destroy()
    endmethod
    
    method debuffEnemy takes unit target returns nothing
        local unit dummy
        set dummy = CreateUnit(GetOwningPlayer(owner),MAGIC,GetUnitX(target),GetUnitY(target),0)
        call IssueTargetOrderById( dummy, 852226,target )
        set dummy = null
    endmethod
    
endstruct
struct FireMissle extends Missle
    method damageEnemy takes unit target returns nothing
        call FireDamage(owner, target, getFinalDamage())
        call destroy()
    endmethod
    
    method getMissleId takes nothing returns integer
        return bFIRE_MISSLE
    endmethod
    
    method debuffEnemy takes unit target returns nothing
        call ApplyBurn(owner, target, 1, 3)
    endmethod
endstruct
struct SmallDarts extends Missle
    method getMissleId takes nothing returns integer
        return 'e002'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 100.0
    endmethod
    method damageEnemy takes unit target returns nothing
        call BladeDamage(owner, target, getFinalDamage())
        call destroy()
    endmethod
endstruct
struct ElectricWhip extends Missle
    private lightning l
    
    method getMissleId takes nothing returns integer
        return bELECTRIC
    endmethod 
    
    method getOriginalDamage takes nothing returns real
        return 0.0
    endmethod
    
    method getLife takes nothing returns integer
        return R2I(getf2value(owner, iELECTRIC))
    endmethod
    
    method debuffEnemy takes unit target returns nothing
        call ElectricBlow(owner, target)
        call ElectricWhipBufferStruct.create(target, 150, owner, 5).start()
    endmethod
    
    method onFire takes nothing returns nothing
        set l = AddLightningEx( "CLPB", false, GetUnitX(missle),GetUnitY(missle),getUnitHeight(missle), GetUnitX(owner), GetUnitY(owner),getUnitHeight(owner) )
    endmethod
    
    method substep takes nothing returns nothing
        call MoveLightningEx( l, false, GetUnitX(missle),GetUnitY(missle),getUnitHeight(missle), GetUnitX(owner), GetUnitY(owner),getUnitHeight(owner) )
    endmethod
    
    method explode takes nothing returns nothing
        call DestroyLightning(l)
    endmethod
    
endstruct
struct ReturnDarts extends TroughMissle
    vector pref
    
    method getMissleId takes nothing returns integer
        set pref = vector.create(0,0,0)
        return 'e003'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 130.0
    endmethod
    method getLife takes nothing returns integer
        return 10000
    endmethod
    method debuffEnemy takes unit target returns nothing
        //call DestroyEffect( AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)) )
        //call ApplyBleed(owner, target, 1, 10)
    endmethod
    method hitSelf takes unit self returns nothing
        call destroy()
    endmethod
    method getFinalDamage takes nothing returns real
        local item itm = GetItemByTypeId(owner, iRETURN)
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real daminc = f2.getValue()
        local real od = getOriginalDamage()
        set itm = null
        return od + daminc
    endmethod
    
    method troughDamage takes unit target returns nothing
        call BladeDamage(owner, target, getFinalDamage())
    endmethod
    
    private method getReturnForce takes nothing returns vector
        local real fl = 0.7
        local vector v = Velocity[missle].v
        local real len = v.getLength()
        local vector dir = getDirVector(missle, owner, fl*5)
        local real angle = vector.getAngle(v, dir)
        local real a = Sin(angle) * len
        local real sd
        local vector r
        local real dl
        if angle >= (pi / 2) then
            set sd = len
        else
            set sd = a
        endif
        if sd > fl then
            set r = vector.create(-v.x,-v.y,-v.z)
            call r.setLength(RMinBJ(len, fl))
            call r.add(dir)
            call dir.destroy()
            return r
        else
            if angle >= (pi / 2) then
                set dl = SquareRoot(fl*fl - a*a) - SquareRoot(len*len - a*a)
            else
                set dl = SquareRoot(fl*fl - a*a) + SquareRoot(len*len - a*a)
            endif
            set r = vector.create(dir.x,dir.y,dir.z)
            call r.setLength(dl)
            call r.subtract(v)
            call r.add(dir)
            call dir.destroy()
            return r
        endif
        return dir
    endmethod
    method explode takes nothing returns nothing
        call pref.destroy()
    endmethod
    
    method substep takes nothing returns nothing
        local vector returnForce
        set returnForce = getReturnForce()
        call RemoveForce(missle, pref)
        set pref.x = returnForce.x
        set pref.y = returnForce.y
        set pref.z = returnForce.z
        call returnForce.destroy()
        call AddForce(missle, pref)
    endmethod
endstruct
struct LeaveDarts extends TroughMissle
    vector pref
    
    method getMissleId takes nothing returns integer
        set pref = vector.create(0,0,0)
        return 'e003'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 100.0
    endmethod
    method getLife takes nothing returns integer
        return 1000
    endmethod
    method debuffEnemy takes unit target returns nothing
        call DestroyEffect( AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)) )
        call ApplyBleed(owner, target, 1, 10)
    endmethod
    method getFinalDamage takes nothing returns real
        local item itm = GetItemByTypeId(owner, iRETURN)
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real daminc = f2.getValue()
        local real od = getOriginalDamage()
        set itm = null
        return od + daminc
    endmethod
    
    method troughDamage takes unit target returns nothing
        call BladeDamage(owner, target, getFinalDamage())
    endmethod
    
    private method getReturnForce takes nothing returns vector
        local item itm = GetItemByTypeId(owner, iRETURN)
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        local vector dir = getDirVector(missle, owner, 6)
        set itm = null
        return dir
    endmethod
    method explode takes nothing returns nothing
        call pref.destroy()
    endmethod
    
    method substep takes nothing returns nothing
        local vector returnForce
        set returnForce = getReturnForce()
        call RemoveForce(missle, pref)
        set pref.x = returnForce.x
        set pref.y = returnForce.y
        set pref.z = returnForce.z
        call returnForce.destroy()
        call AddForce(missle, pref)
    endmethod
endstruct
struct LeaveDartsV2 extends TroughMissle
    vector pref
    
    method getMissleId takes nothing returns integer
        set pref = vector.create(0,0,0)
        return 'e003'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 100.0
    endmethod
    method getLife takes nothing returns integer
        return 1000
    endmethod
    method debuffEnemy takes unit target returns nothing
        //call DestroyEffect( AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)) )
    endmethod
    method getFinalDamage takes nothing returns real
        return 1000.0
    endmethod
    
    method troughDamage takes unit target returns nothing
        call BladeDamage(owner, target, getFinalDamage())
    endmethod
    
    private method getReturnForce takes nothing returns vector
        local real tx= GetUnitX(owner)
        local real ty= GetUnitY(owner)
        local real tz= getUnitHeight(owner) + 70
        local real ux= GetUnitX(missle)
        local real uy= GetUnitY(missle)
        local real uz= getUnitHeight(missle)
        local vector dir = vector.create(tx - ux , ty - uy , tz - uz)
        call dir.setLength(4)
        return dir
    endmethod
    method explode takes nothing returns nothing
        call pref.destroy()
    endmethod
    
    method substep takes nothing returns nothing
        local vector returnForce
        if ModuloInteger(Tick, 5) == 0 then
            set returnForce = getReturnForce()
            call RemoveForce(missle, pref)
            set pref.x = returnForce.x
            set pref.y = returnForce.y
            set pref.z = returnForce.z
            call returnForce.destroy()
            call AddForce(missle, pref)
        endif
    endmethod
endstruct
struct GuardDarts extends TroughMissle
    real offset
    static method create takes unit owner, real offset returns thistype
        local thistype m=thistype.allocate(owner)
        call BJDebugMsg("offset " + R2S(offset))
        set m.offset = offset
        return m
    endmethod
    method getMissleId takes nothing returns integer
        return 'e00M'
    endmethod
    method alwaysTrough takes nothing returns boolean
        return true
    endmethod
    method getLife takes nothing returns integer
        return 400
    endmethod
    method debuffEnemy takes unit target returns nothing
        call Push(target, getTargetDir(owner, target), 10, 0, 5)
        //call DestroyEffect( AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)) )
    endmethod
    method getFinalDamage takes nothing returns real
        return 350.0
    endmethod
    method troughDamage takes unit target returns nothing
        call BladeDamage(owner, target, getFinalDamage())
    endmethod
    method substep takes nothing returns nothing
        local real x= GetUnitX(owner)
        local real y= GetUnitY(owner)
        local real tz= getUnitHeight(owner) + 70
        local real r = offset + Tick * 0.4
        local real tx = x + 200 * Cos(r)
        local real ty = y + 200 * Sin(r)
        call MoveUnit(missle, tx, ty, tz)
        call ClearVelocity(missle)
    endmethod
endstruct
struct BackGrenade extends Missle
    method getMissleId takes nothing returns integer
        return 'e009'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 100.0
    endmethod
    method debuffEnemy takes unit target returns nothing
        local integer lv = R2I(IndividualItemData[GetItemByTypeId(owner, iBKGRENADE)].featureData.f3.getValue())
        if lv > 0 then
            call Stun(owner, target, lv)
        endif
    endmethod
    method damageEnemy takes unit target returns nothing
    endmethod
    method explode takes nothing returns nothing
        local real x = GetUnitX(missle)
        local real y = GetUnitY(missle)
        local item itm = GetItemByTypeId(owner, iBKGRENADE)
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real radius = f2.getValue()
        call missleRangeOneTimeActionToUnit(this,x,y,radius,damaged)
        call DestroyEffect( AddSpecialEffect(E_TUNDER_CLAP, x, y) )
        set itm = null
    endmethod
    method getLife takes nothing returns integer
        return 300
    endmethod
endstruct
struct PushGrenade extends Missle
    method getMissleId takes nothing returns integer
        return 'e00A'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 100.0
    endmethod
    method debuffEnemy takes unit target returns nothing
        local item itm = GetItemByTypeId(owner, iPSGRENADE)
        local ItemFeature f3 = IndividualItemData[itm].featureData.f3
        local real speed = f3.getValue()
        local real lv = IndividualItemData[GetItemByTypeId(owner, iPSGRENADE)].featureData.f4.getValue()
        local real facing = getTargetDir(missle, target)
        if lv > 0 then
            call Clap(owner, target, R2I(lv))
        endif
        call Push(target, facing, speed, 0, 5)
        set itm = null
    endmethod
    method damageEnemy takes unit target returns nothing
    endmethod
    method explode takes nothing returns nothing
        local real x = GetUnitX(missle)
        local real y = GetUnitY(missle)
        local item itm = GetItemByTypeId(owner, iPSGRENADE)
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real radius = f2.getValue()
        call missleRangeOneTimeActionToUnit(this,x,y,radius,damaged)
        call DestroyEffect( AddSpecialEffect(E_CLAP, x, y) )
        set itm = null
    endmethod
    method getLife takes nothing returns integer
        return 300
    endmethod
endstruct
struct Mine extends Missle
    
    boolean active
    
    integer count
    
    method getMissleId takes nothing returns integer
        return 'e00B'
    endmethod 
    method substep takes nothing returns nothing
        if active == false then
            if life < getLife() - getDeployTime() and HasLiveEnemyUnitInRange(missle, 200) != null then
                set active = true
            endif
        else
            if count > 0 then
                set count = count - 1
            else
                call destroy()
            endif
        endif
    endmethod
    method explode takes nothing returns nothing
        local real x = GetUnitX(missle)
        local real y = GetUnitY(missle)
        call DestroyEffect( AddSpecialEffect(E_MINE_EXPLODE, x, y) )
        call rangeExplodeDamage(owner, x, y, 200, 300)
    endmethod
    method getLife takes nothing returns integer
        return 3000
    endmethod
    method getDeployTime takes nothing returns integer
        return 122
    endmethod
    static method create takes unit owner returns Mine
        local Mine m=Mine.allocate(owner)
        set m.active=false
        set m.count=20
        return m
    endmethod
endstruct
struct ShoulderCannonMissle extends Missle
    method damageEnemy takes unit target returns nothing
        call destroy()
    endmethod
    method debuffExplodeEnemy takes unit target returns nothing
        call Push(target, getTargetDir(missle, target), 5, 0, 5)
    endmethod
    method damageExplodeEnemy takes unit target returns nothing
        local item itm = GetItemByTypeId(owner, 'I00P')
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        local real d = abidmg_seed * 0.8 * (1 + (0.1 * f1.lv)) 
        set itm = null
        call AbliDamage(owner, target, d, "")
    endmethod
    method explode takes nothing returns nothing
        local real x = GetUnitX(missle)
        local real y = GetUnitY(missle)
        call missleRangeOneTimeExplodeToUnit(this,x,y, 400)
        call DestroyEffect( AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl", x, y) )
    endmethod
    
    method getLife takes nothing returns integer
        return 30
    endmethod
    method getOriginalDamage takes nothing returns real
        return 10.0
    endmethod
    
    method getMissleId takes nothing returns integer
        return 'e00E'
    endmethod
endstruct
struct AcidMissle extends Missle
    method damageEnemy takes unit target returns nothing
        call BulletDamage(owner, target, getFinalDamage(), SMALL_BLOOD)
        call destroy()
    endmethod
    
    method getLife takes nothing returns integer
        return 100
    endmethod
    method getOriginalDamage takes nothing returns real
        return 5.0
    endmethod
    
    method getMissleId takes nothing returns integer
        return 'e00H'
    endmethod
endstruct
struct SpearMissle extends Missle
    method getLife takes nothing returns integer
        return 30
    endmethod
    method getOriginalDamage takes nothing returns real
        return g_missle_damage + 20
    endmethod
    method getMissleId takes nothing returns integer
        return 'e00F'
    endmethod
endstruct
struct NetMissle extends Missle
    method getLife takes nothing returns integer
        return 30
    endmethod
    method getOriginalDamage takes nothing returns real
        return 0.0
    endmethod
    method getMissleId takes nothing returns integer
        return 'e00I'
    endmethod
    method damageEnemy takes unit target returns nothing
        local item itm
        local ItemFeature f1
        local ItemFeature f2
        local integer t
        if not IsUnitInGroup(target, netgroup) then
            set itm = GetItemByTypeId(owner, 'I012')
            set f1 = IndividualItemData[itm].featureData.f1
            set f2 = IndividualItemData[itm].featureData.f2
            set t = 5
            if f1.lv > 0 then
                set t = t + f1.lv * 2
            endif
            call ApplyBleed(owner, target, 20 + 20 * f2.lv, t)
            call Net(owner, target, t)
            call NetBuffer.create(target, 50).start()
            call destroy()
            set itm = null
        endif
    endmethod
endstruct
struct SmartDarts extends TroughMissle
    vector pref
    
    unit t
    
    integer count
    
    integer swift
    
    method getMissleId takes nothing returns integer
        set pref = vector.create(0,0,0)
        return 'e003'
    endmethod
    
    method getOriginalDamage takes nothing returns real
        return 500.0
    endmethod
    method getLife takes nothing returns integer
        local item itm = GetItemByTypeId(owner, 'I00Q')
        local ItemFeature f4 = IndividualItemData[itm].featureData.f4
        return 300 + (f4.lv * 100)
    endmethod
    method debuffEnemy takes unit target returns nothing
        //call DestroyEffect( AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)) )
        //call ApplyBleed(owner, target, 1, 10)
    endmethod
    
    static method create takes unit owner, unit target returns thistype
        local thistype m=thistype.allocate(owner)
        set m.t = target
        set m.count = 3
        set m.swift = 0
        return m
    endmethod
    method hitSelf takes unit self returns nothing
        set swift = 10
    endmethod
    method getFinalDamage takes nothing returns real
        local item itm = GetItemByTypeId(owner, 'I00Q')
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        local real d = abidmg_seed * 0.7 * (1 + (0.1 * f1.lv)) 
        set itm = null
        return d
    endmethod
    
    method troughDamage takes unit target returns nothing
        call AbliDamage(owner, target, getFinalDamage(), "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl")
        if target == t then
            set count = count - 1
            set swift = 10
            if count == 0 then
                set t = null
                call destroy()
            endif
        endif
    endmethod
    
    private method getReturnForce takes nothing returns vector
        local real fl = 0.7
        local vector v = Velocity[missle].v
        local real len = v.getLength()
        local vector dir = getDirVector(missle, t, fl*5)
        local real angle = vector.getAngle(v, dir)
        local real a = Sin(angle) * len
        local real sd
        local vector r
        local real dl
        if swift > 0 then
            set swift = swift - 1
            return vector.create(0,0,0)
        endif
        if angle >= (pi / 2) then
            set sd = len
        else
            set sd = a
        endif
        if sd > fl then
            set r = vector.create(-v.x,-v.y,-v.z)
            call r.setLength(RMinBJ(len, fl))
            call r.add(dir)
            call dir.destroy()
            return r
        else
            if angle >= (pi / 2) then
                set dl = SquareRoot(fl*fl - a*a) - SquareRoot(len*len - a*a)
            else
                set dl = SquareRoot(fl*fl - a*a) + SquareRoot(len*len - a*a)
            endif
            set r = vector.create(dir.x,dir.y,dir.z)
            call r.setLength(dl)
            call r.subtract(v)
            call r.add(dir)
            call dir.destroy()
            return r
        endif
        return dir
    endmethod
    method explode takes nothing returns nothing
        local unit ydl_unit
        local real x
        local real y
        local item itm = GetItemByTypeId(owner, 'I00Q')
        local ItemFeature f3 = IndividualItemData[itm].featureData.f3
        if f3.lv > 0 then
            set x = GetUnitX(missle)
            set y = GetUnitY(missle)
            call GroupEnumUnitsInRange(ENUM_GROUP, x, y, 350,null) 
            loop
                set ydl_unit = FirstOfGroup(ENUM_GROUP)
                exitwhen ydl_unit == null
                call GroupRemoveUnit(ENUM_GROUP, ydl_unit) 
                if IsLiveEnemyUnitOrDestroyableWall(owner,ydl_unit) then
                    call Push(ydl_unit, getTargetDir(missle, ydl_unit), 5, 0, 5)
                    call AbliDamage(owner, ydl_unit, abidmg_seed * 1.5 * (1 + f3.lv * 0.2), "")
                endif
            endloop
            call FlowerDestroy(x, y, "Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl")
            call SetPlayerAbilityAvailable( GetOwningPlayer(owner), 'A01O', true)
            call UnitRemoveAbility(owner, 'A01Z')
        endif
        call pref.destroy()
    endmethod
    
    method substep takes nothing returns nothing
        local vector returnForce
        if not IsUnitAliveBJ(t) then
            set t = owner
        endif
        if IsUnitAliveBJ(t) then
            set returnForce = getReturnForce()
            call RemoveForce(missle, pref)
            set pref.x = returnForce.x
            set pref.y = returnForce.y
            set pref.z = returnForce.z
            call returnForce.destroy()
            call AddForce(missle, pref)
        endif
    endmethod
endstruct

//library Missle ends
//library Shooter:
function shootz takes unit owner, unit target, real rist returns vector
    local real ux = GetUnitX(owner)
    local real uy = GetUnitY(owner)
    local real uz = getUnitHeight(owner)
    local real tx = GetUnitX(target)
    local real ty = GetUnitY(target)
    local real tz = getUnitHeight(target)
    local real rr = GetRandomReal(0, 2 * pi)
    local real tx2 = tx + Cos(rr) * rist
    local real ty2 = ty + Sin(rr) * rist
    local vector t = vector.create(tx2 - ux, ty2 - uy, tz - uz)
    return t
endfunction
interface IShooter
    unit owner
    IMissleFactory factory
    
    method shoot takes vector dir returns nothing
    method getEnergyConsume takes nothing returns integer
    method subshoot takes vector dir returns nothing
    method getRist takes nothing returns real
    method shootCount takes nothing returns integer
    method getOriginSpeed takes nothing returns real
    method getClipSize takes nothing returns integer
    method shoothz takes nothing returns integer
    method tick takes nothing returns nothing
    method calcn takes nothing returns integer
    
endinterface
struct AbstractShooter extends IShooter
    implement T32xs
    
    method tick takes nothing returns nothing
    endmethod
    method calcn takes nothing returns integer
        return 1
    endmethod
    
    method periodic takes nothing returns nothing
        call tick()
    endmethod
        
    static method create takes unit owner ,IMissleFactory factory returns thistype
        local thistype s=thistype.allocate()
        set s.owner=owner
        set s.factory=factory
        call s.startPeriodic()
        return s
    endmethod
    
    method shoothz takes nothing returns integer
        return 50
    endmethod
    
    method getClipSize takes nothing returns integer
        return 10
    endmethod
    
    method shootCount takes nothing returns integer
        return 1
    endmethod
    method getRist takes nothing returns real
        return 100.0
    endmethod
    method getOriginSpeed takes nothing returns real
        return 60.0
    endmethod
    
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call m.fireMissle(dir)
    endmethod
    
    method getEnergyConsume takes nothing returns integer
        return 1
    endmethod
    method subshoot takes vector dir returns nothing
    endmethod
    
    method onDestroy takes nothing returns nothing
        call stopPeriodic()
        call factory.destroy()
        set owner=null
    endmethod
    
endstruct
struct NetShooter extends AbstractShooter
    private integer c
    static method create takes unit owner ,IMissleFactory factory, integer c returns NetShooter
        local NetShooter m = NetShooter.allocate(owner, factory)
        set m.c = c
        return m
    endmethod
    method shoot takes vector dir returns nothing
        local integer i = 0
        local IMissle m = 0
        local vector v = 0
        local integer r = c / 2
        local real p = 0.15
        local real k = 0 - r*p
        loop
            exitwhen i >= c
            set v = vector.create(dir.x, dir.y, dir.z)
            if k != 0 then
                call v.rotate(vector.create(0, 0, 1), k)
            endif
            set m=factory.createMissle(owner)
            call m.fireMissle(v)
            set i = i + 1
            set k = k + p
        endloop
    endmethod
endstruct
struct SingleShooter extends AbstractShooter
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call m.fireMissle(dir)
    endmethod
endstruct
struct TripleShooter extends AbstractShooter
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        local vector v
        call m.fireMissle(dir)
        //2
        set v = vector.create(dir.x, dir.y, dir.z)
        call v.rotate(vector.create(0, 0, 1), -0.3)
        set m=factory.createMissle(owner)
        call m.fireMissle(v)
        //3
        set v = vector.create(dir.x, dir.y, dir.z)
        call v.rotate(vector.create(0, 0, 1), 0.3)
        set m=factory.createMissle(owner)
        call m.fireMissle(v)
    endmethod
endstruct
struct Multi5Shooter extends AbstractShooter
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        local vector v
        call m.fireMissle(dir)
        //2
        set v = vector.create(dir.x, dir.y, dir.z)
        call v.rotate(vector.create(0, 0, 1), -0.6)
        set m=factory.createMissle(owner)
        call m.fireMissle(v)
        //3
        set v = vector.create(dir.x, dir.y, dir.z)
        call v.rotate(vector.create(0, 0, 1), 0.3)
        set m=factory.createMissle(owner)
        call m.fireMissle(v)
        //4
        set v = vector.create(dir.x, dir.y, dir.z)
        call v.rotate(vector.create(0, 0, 1), -0.3)
        set m=factory.createMissle(owner)
        call m.fireMissle(v)
        //5
        set v = vector.create(dir.x, dir.y, dir.z)
        call v.rotate(vector.create(0, 0, 1), 0.6)
        set m=factory.createMissle(owner)
        call m.fireMissle(v)
    endmethod
endstruct
struct ShoulderCannonShooter extends AbstractShooter
    
    integer c
    
    integer c2
    
    vector d
    
    integer t
    static method create takes unit owner ,IMissleFactory factory returns thistype
        local thistype s=thistype.allocate(owner, factory)
        local item itm = GetItemByTypeId(owner, 'I00P')
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        set s.c = 2 + f2.lv * 2
        set s.c2 = 1
        return s
    endmethod
    
    private method getRotateDir takes integer c returns real
        if c == 1 then
            return 0
        elseif c == 2 then
            return 0.1
        elseif c == 3 then
            return 0
        elseif c == 4 then
            return -0.1
        elseif c == 5 then
            return 0
        elseif c == 6 then
            return 0.1
        endif
        return 0.0
    endmethod
    method tick takes nothing returns nothing
        local vector v
        if ModuloInteger(Tick - this.t, 4) == 0 then
            if this.c2 <= this.c then
                set v = vector.create(d.x, d.y, d.z)
                call v.rotate(vector.create(0, 0, 1), getRotateDir(this.c2))
                call factory.createMissle(owner).fireMissle(v)
                set this.c2 = this.c2 + 1
            else
                call destroy()
            endif
        endif
    endmethod
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        set this.d = vector.create(dir.x, dir.y, dir.z)
        call dir.rotate(vector.create(0, 0, 1), -0.1)
        call m.fireMissle(dir)
        set this.t = Tick
    endmethod
endstruct
struct GrenadeThrower extends AbstractShooter
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call m.fireMissle(dir)
    endmethod
endstruct
struct MineThrower extends AbstractShooter
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call m.fireMissle(dir)
    endmethod
endstruct
struct DefaultShooter extends AbstractShooter
    method calcn takes nothing returns integer
        local integer n = 0
        local real t = 0.0025
        set n = (Material[owner].shot_tick + shoothz() + Material[owner].shot_fast_buff) / SHOTHZ
        set Material[owner].shot_tick = ModuloInteger(Material[owner].shot_tick + shoothz() + Material[owner].shot_fast_buff, SHOTHZ)
        //call BJDebugMsg("n " + I2S(n) + " st " + I2S(Material[owner].shot_tick))
        if n == 0 then
            if GetUnitAbilityLevel(owner, 'A015') > 20 then
                set t = t / (GetUnitAbilityLevel(owner, 'A015')/20)
            endif
            if ((GetTimeOfDay() - Material[owner].last_fire)/t) * (shoothz() + Material[owner].shot_fast_buff) > 100 then
                set n = 1
                set Material[owner].shot_tick = 0
            endif
        endif
        if n > 0 then
            //call BJDebugMsg(R2S(GetTimeOfDay() - Material[owner].last_fire))
            set Material[owner].last_fire = GetTimeOfDay()
            //call SetUnitAnimation( owner, "attack" )
        elseif GetTimeOfDay() - Material[owner].last_fire > 0.04 then
            call SetUnitAnimation( owner, "stand" )
        endif
        return n
    endmethod
    method shoot takes vector dir returns nothing
        local integer ec = getEnergyConsume()
        local vector vdir
        local integer i = 1
        local integer n = 0
        local real t = 0.0025
        set n = calcn()
        loop
            exitwhen i > n * shootCount()
            set i = i + 1
            set vdir = getShootVector()
            if IsHero(owner) then
                if not EquipmentData[owner].heroData.reload and GetPlayerState(GetOwningPlayer(owner), PLAYER_STATE_RESOURCE_FOOD_USED) >= ec then
                    call energyConsume(ec)
                    call backForce(getShootDir())
                    call subshoot(vdir)
                    set Material[owner].last_shoot = GetTimeOfDay()
                else
                    if not EquipmentData[owner].heroData.reload then
                        set EquipmentData[this.owner].heroData.shoot_energy = 0
                        call SetPlayerState(GetOwningPlayer(owner),PLAYER_STATE_RESOURCE_FOOD_USED, 0)
                        call UnitAddAbility(owner, 'Abun')
                        call DisplayFloatText(GetUnitX(owner),GetUnitY(owner),"瑁呭脊锛?,1)
                        call PlaySoundOnUnitBJ( gg_snd_WindWalk, 100, owner )
                        set EquipmentData[owner].heroData.reload = true
                        set EquipmentData[owner].heroData.shoot_buffer = 0
                        //if EquipmentData[owner].heroData.reloade != null then
                            //call DestroyEffect(EquipmentData[owner].heroData.reloade)
                        //endif
                        //set EquipmentData[owner].heroData.reloade = AddSpecialEffectTarget("Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl",owner,"overhead")
                    endif
                endif
            else
                if not EquipmentData[owner].heroData.reload and EquipmentData[owner].heroData.bullets >= ec then
                    call energyConsume(ec)
                    call backForce(getShootDir())
                    call subshoot(vdir)
                    set Material[owner].last_shoot = GetTimeOfDay()
                else
                    if not EquipmentData[owner].heroData.reload then
                        set EquipmentData[this.owner].heroData.shoot_energy = 0
                        set EquipmentData[this.owner].heroData.bullets = 0
                        call UnitAddAbility(owner, 'Abun')
                        set EquipmentData[owner].heroData.reload = true
                    endif
                    call DisplayFloatText(GetUnitX(owner),GetUnitY(owner),"瑁呭脊锛?,1)
                endif 
            endif
        endloop
    endmethod
    
    method getSpeed takes nothing returns real
        return getOriginSpeed()
    endmethod
    
    method getShootDir takes nothing returns real
        return EquipmentData[owner].heroData.jump_direction
    endmethod
    
    method getShootVector takes nothing returns vector
        //local unit target = EquipmentData[this.owner].heroData.shoot_target
        local real ux = GetUnitX(owner)
        local real uy = GetUnitY(owner)
        local real uz = getUnitHeight(owner)
        local real tx = EquipmentData[owner].heroData.stx
        local real ty = EquipmentData[owner].heroData.sty
        //local real tz = getUnitHeight(target)
        local real tz = EquipmentData[owner].heroData.stz
        local real rr = GetRandomReal(0, 2 * pi)
        local real hr = EquipmentData[owner].heroData.shoot_rist
        local real rist = getRist() * RMaxBJ(0,(1 - hr)) * SquareRoot(Pow(ty-uy,2)+Pow(tx-ux,2)) / 900
        local real tx2 = tx + Cos(rr) * rist
        local real ty2 = ty + Sin(rr) * rist
        local vector t = vector.create(tx2 - ux, ty2 - uy, tz - uz)
        call t.setLength(getSpeed())
        return t
    endmethod
    
    method subshoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call m.fireMissle(dir)
    endmethod
    
    method getEnergyConsume takes nothing returns integer
        return 1
    endmethod
    
    method energyConsume takes integer consume returns nothing
        local integer l
        if IsHero(owner) then
            set l = GetPlayerState(GetOwningPlayer(owner), PLAYER_STATE_RESOURCE_FOOD_USED)
            call SetPlayerState(GetOwningPlayer(owner),PLAYER_STATE_RESOURCE_FOOD_USED, l - consume)
        else
            set l = EquipmentData[owner].heroData.bullets
            set EquipmentData[owner].heroData.bullets = l - consume
        endif
    endmethod
    
    method backForce takes real vdir returns nothing
        local real facing = vdir + pi
        call Push(owner, facing, EquipmentData[owner].heroData.a_shoot_back_log, 0, 5)
    endmethod
    
endstruct
struct ShootGunShooter extends DefaultShooter
    method shootCount takes nothing returns integer
        return 12
    endmethod
    method getRist takes nothing returns real
        return 200.0
    endmethod
    method getOriginSpeed takes nothing returns real
        return 80.0
    endmethod
endstruct
struct MachineGunShooter extends DefaultShooter
    method shoothz takes nothing returns integer
        return 40
    endmethod
    method getClipSize takes nothing returns integer
        return 60
    endmethod
endstruct
struct AutoShooter extends DefaultShooter
    method calcn takes nothing returns integer
        return 1
    endmethod
    method getClipSize takes nothing returns integer
        return 60
    endmethod
endstruct

//library Shooter ends
//library AIAttack:
function AIAttackCondition takes nothing returns nothing
local unit ds = GetAttacker()
local integer t = GetUnitTypeId(ds)
local unit u = GetTriggerUnit()
local real sx
local real sy
local real tx
local real ty
local unit u1
local real r1
local IShooter shooter
local IMissleFactory factory
local vector dir
if t == 'u002' then
    set sx = GetUnitX(ds)
    set sy = GetUnitY(ds)
    set tx = GetUnitX(GetTriggerUnit())
    set ty = GetUnitY(GetTriggerUnit())
    set u1 = CreateUnit(Player(11), 'u000', sx, sy, 0)
    set Material[u1].nocollision = 20
    call Velocity[u1].v.destroy()
    set Velocity[u1].v = GetGrenadeVector(sx, sy, tx, ty)
    set r1 = GetGrenadeTrajectory(sx, sy, tx, ty)
    call Velocity[u1].v.setLength(GetRandomReal(r1, r1*3))
    set u1 = null
elseif t == 'z001' then
    set factory = AcidMissleFactory.create()
    set shooter = SingleShooter.create(ds, factory)
    set dir = shootz(ds, u, 150)
    call dir.setLength(GetRandomReal(22, 30))
    call shooter.shoot(dir)
    call shooter.destroy()
endif
set ds = null
set u = null
endfunction
function InitAIAttack takes nothing returns nothing
set gtrgAIAttack=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ( gtrgAIAttack, EVENT_PLAYER_UNIT_ATTACKED )
call TriggerAddCondition(gtrgAIAttack,function AIAttackCondition)
endfunction

//library AIAttack ends
//library Velocity:
function LoopCollisionGroupUnit takes nothing returns nothing
    local unit u = GetEnumUnit()
    local group tempGroup = NewGroup()
    call GroupEnumUnitsInRange(tempGroup, GetUnitX(u), GetUnitY(u), Material[u].volume,null)
    if CountUnitsInGroup(tempGroup) == 1 then
        call GroupRemoveUnit(COLLISION_GROUP, u)
    endif
    call ReleaseGroup(tempGroup)
    set tempGroup = null
endfunction
function LoopCollisionGroup takes nothing returns nothing
    call ForGroup(COLLISION_GROUP, function LoopCollisionGroupUnit)
    call GroupRefresh(COLLISION_GROUP)
endfunction
function MoveMissles takes nothing returns nothing
    call VelocityUnit.loopMoveAllMissles()
endfunction
    
function MissleInit takes nothing returns nothing
    set missleMoveTimer=CreateTimer()
    set collisionGroupTimer = CreateTimer()
    set COLLISION_GROUP = NewGroup()
    call TimerStart(missleMoveTimer,0.03125,true,function MoveMissles)
    call TimerStart(collisionGroupTimer,1,true,function LoopCollisionGroup)
endfunction
function BulletCollision takes unit b, unit u, real r returns nothing
    local Missle missle = Velocity[b].missleStruct
    call missle.doDamage(r)
endfunction
function UnitHitWall takes unit s, unit u, real v, real dir, boolean efs returns nothing
    call CollisionDamage(s, u, v, dir, efs)
endfunction
function UnitCollision takes unit u1, unit u2 returns nothing
    local real x1 = GetUnitX(u1)
    local real y1 = GetUnitY(u1)
    local real x2 = GetUnitX(u2)
    local real y2 = GetUnitY(u2)
    local vector vn = vector.create(x1 - x2, y1 - y2,0)
    local vector v_un = vector.unitVector(vn)
    local vector v_ut = vector.create(-v_un.y, v_un.x,0)
    local vector v1 = Velocity[u1].v
    local vector v2 = Velocity[u2].v
    
    local vector dv1 = vector.create(x2-x1,y2-y1,0)
    local vector dv2 = vector.create(x1-x2,y1-y2,0)
    local real pv1 = vector.projectionVector(v1,dv1).getLength()
    local real pv2 = vector.projectionVector(v2,dv2).getLength()
    local real pvd = (pv1 + pv2)/2
    
    local real m1 = Material[u1].weight
    local real m2 = Material[u2].weight
    local real v1n = vector.dotProduct(v_un, v1)
    local real v1t = vector.dotProduct(v_ut, v1)
    local real v2n = vector.dotProduct(v_un, v2)
    local real v2t = vector.dotProduct(v_ut, v2)
    local real v1tPrime = v1t
    local real v2tPrime = v2t
    local real v1nPrime = (v1n * (m1 - m2)) + 2 * m2 * v2n / (m1 + m2)
    local real v2nPrime = (v2n * (m2 - m1)) + 2 * m1 * v1n / (m1 + m2)
    local vector v_v1nPrime = vector.scale2(v_un,v1nPrime)
    local vector v_v1tPrime = vector.scale2(v_ut,v1tPrime)
    local vector v_v2nPrime = vector.scale2(v_un,v2nPrime)
    local vector v_v2tPrime = vector.scale2(v_ut,v2tPrime)
    set v1.x = v_v1nPrime.x + v_v1tPrime.x
    set v1.y = v_v1nPrime.y + v_v1tPrime.y
    set v2.x = v_v2nPrime.x + v_v2tPrime.x
    set v2.y = v_v2nPrime.y + v_v2tPrime.y
    
    
    if IsWall(u1) or IsWall2(u1) or Material[u1].clazz == MC_WALL then
        call v1.setLength(0)
    elseif IsWall(u2) or IsWall2(u2) or Material[u2].clazz == MC_WALL then
        call v2.setLength(0)
    endif
    if pvd > DAMAGE_SPEED then
        call UnitHitWall(u1,u2,pvd,getTargetDir(u1,u2),true)
        call UnitHitWall(u2,u1,pvd,getTargetDir(u2,u1),false)
    endif
endfunction
struct VelocityUnit
    implement List
    
    unit target
    
    static method create takes unit target returns VelocityUnit
        local VelocityUnit m=VelocityUnit.allocate()
        set m.target=target
        call m.addList()
        return m
    endmethod
    
    method onDestroy takes nothing returns nothing
        set target=null
        call removeList()
    endmethod
    
    static method loopMoveAllMissles takes nothing returns nothing
         local string fakeManLv
         local VelocityUnit m = getFirst() 
             loop
                 exitwhen m == 0
                 set fakeManLv = RealMan.CheckLevel(GetUnitX(m.target), GetUnitY(m.target), Material[m.target].fakelv)
                 if fakeManLv == LV_ACTIVE then
                    call Velocity[m.target].periodic()
                 elseif fakeManLv == LV_DESTORY then
                    call KillUnit(m.target)
                 endif
                 set m = m.getNext()
             endloop
    endmethod
endstruct
struct Velocity extends array
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()
    vector v
    
    vector a
    
    VelocityUnit vu
    
    Missle missleStruct
    
    static method AIDS_filter takes unit u returns boolean
        local string materialType = Material[u].clazz
        if GetUnitTypeId(u)== HERO or GetUnitTypeId(u) == 'ewsp' then
            return true
        endif
        if materialType == MC_BULLET or materialType == MC_UNIT or materialType == MC_ARROW or materialType == MC_STONE or materialType == MC_MINE then
            return true
        endif
        return false
    endmethod
    
    private method AIDS_onCreate takes nothing returns nothing
        if GetUnitTypeId(.unit)==HERO then
            set this.v = vector.create(0,0,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            set this.a = vector.create(0,0,0)
            set this.vu = VelocityUnit.create(.unit)
        else
            set this.v = vector.create(0,0,0)
            set this.a = vector.create(0,0,0)
            set this.vu = VelocityUnit.create(.unit)
        endif
    endmethod
        
    private method AIDS_onDestroy takes nothing returns nothing
        call v.destroy()
        call a.destroy()
        call missleStruct.destroy()
        call this.vu.destroy()
    endmethod
    
    method periodic takes nothing returns nothing
        local real x = GetUnitX(.unit)
        local real y = GetUnitY(.unit)
        local real z = getUnitHeight(.unit)
        local real v
        local real a = this.a.getLength()
        local real fz
        local real tx
        local real ty
        local real tz
        local real f1
        local real f2 
        local real af
        local real fs
        local real as
        local unit tu = null
        local string clazz = Material[.unit].clazz
        local vector gravity
        local boolean unitHitWall = false
        local real addon = 0
        local real dir
        if IsUnitAliveBJ(.unit) or Material[.unit].deadcnt > 0 then
            if not IsUnitAliveBJ(.unit) and Material[.unit].deadcnt > 0 then
                set Material[.unit].deadcnt = Material[.unit].deadcnt - 1
            endif
            set fz = GetUnitFlyHeight(.unit)
            if fz > 0.1 then
                if clazz == MC_UNIT or clazz == MC_STONE or clazz == MC_MINE then
                    //fly unit
                    if GetUnitTypeId(.unit) != 'u009' then
                        //set gravity = vector.create(0,0,-2)
                        set gravity = vector.create(0,0,Material[.unit].g)
                        call this.v.add(gravity)
                    endif
                endif
            endif
            set v = this.v.getLength()
            if v > 0 or clazz == MC_ARROW then
                //if GetUnitTypeId(.unit) == 'u000' then
                //call BJDebugMsg("velocity "+R2S(v) + R2S(this.v.x)+ " " + R2S(this.v.y)+ " " + R2S(this.v.z))
                //endif
                //call BJDebugMsg("v " + R2S(v))
                //call BJDebugMsg("f1 " + R2S(f1))
                //call BJDebugMsg("f2 " + R2S(f2))
                //call BJDebugMsg("af " + R2S(af))
                set tz = z + this.v.z
                set tx = x + this.v.x
                set ty = y + this.v.y
                //call BJDebugMsg(R2S(fz) + " " + R2S(this.v.z))
                //call BJDebugMsg("z " + R2S(tz))
                call MoveUnit(.unit, tx, ty, tz)
                //hit ground
                if fz < 0.1 and this.v.z < 0 then
                    //set this.v.z = 0
                    if Material[.unit].ground_action == GROUND_DESTROY then
                        call missleStruct.destroy()
                    elseif Material[.unit].ground_action == GROUND_STICK then
                        call this.v.setLength(0)
                    endif 
                endif
                //F
                if clazz == MC_UNIT or clazz == MC_ARROW or clazz == MC_STONE or clazz == MC_MINE then
                    set f2 = Material[.unit].airk * v * v / 10
                    if fz > 0.1 or clazz == MC_ARROW then
                        set af = f2 / Material[.unit].weight
                    else
                        set f1 = Material[.unit].weight * g * u / 20
                        set af = (f1 + f2) / Material[.unit].weight
                    endif
                    if af >= v then
                        call this.v.setLength(0)
                    else
                        call this.v.setLength(v - af)
                    endif
                endif
                //hit wall
                set dir = Atan2(this.v.y, this.v.x)
                if getTerrianHeight(x + 10 * Cos(dir),y + 10 * Sin(dir)) > z + 5 then
                    //call BJDebugMsg("prepare hit wall")
                    if clazz == MC_BULLET or clazz == MC_STONE then
                        call missleStruct.destroy()
                    elseif clazz == MC_ARROW then
                    elseif clazz == MC_UNIT then
                        if v > DAMAGE_SPEED and Material[.unit].nohitwall <= 0 then
                            call UnitHitWall(.unit, .unit,v,getDir(x,y,tx,ty),true)
                        endif
                        set unitHitWall = true
                    elseif clazz == MC_MINE then
                        set unitHitWall = true
                    endif
                endif 
                //CollisionRefresh
                if clazz == MC_BULLET or clazz == MC_ARROW then
                    call missleStruct.refreshDamagedGroup()
                endif
                //Collision
                if Material[.unit].nocollision <= 0 then
                    if IsUnitAliveBJ(.unit) then
                        //handle boss big collision
                        if false and GetPlayerId(GetOwningPlayer(.unit)) < 3 then
                            if IsBoss(EquipmentData[heros[GetPlayerId(GetOwningPlayer(.unit))]].heroData.shoot_target) then
                                set addon = Material[EquipmentData[heros[GetPlayerId(GetOwningPlayer(.unit))]].heroData.shoot_target].volume
                            endif
                        endif
                        if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE then
                            set tu = HasLiveUnitOrDestroyableWallInRange(.unit, addon + RMaxBJ( Material[.unit].volume,v + BULLET_RANGE_ADDON))
                        elseif clazz == MC_UNIT then
                            set tu = GetNearestLiveUnitOrWall(.unit, Material[.unit].volume)
                        endif
                        if tu != null then
                            if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE then
                                call BulletCollision(.unit, tu, addon + RMaxBJ( Material[.unit].volume,v + BULLET_RANGE_ADDON))
                            elseif clazz == MC_UNIT then
                                if IsUnitInGroup(.unit, COLLISION_GROUP) and IsUnitInGroup(tu, COLLISION_GROUP) then
                                else
                                    call UnitCollision(.unit, tu)
                                    call GroupAddUnit(COLLISION_GROUP, .unit)
                                    call GroupAddUnit(COLLISION_GROUP, tu)
                                endif
                            endif
                        endif 
                    endif
                else
                    set Material[.unit].nocollision = Material[.unit].nocollision - 1
                endif
            endif
            if a > 0 then
                //call BJDebugMsg("as " + R2S(as))
                //call BJDebugMsg("a " + R2S(a))
                if v == 0 and clazz == MC_UNIT then
                    //set fs = Material[.unit].weight * g * us / 30
                    //set as = fs / Material[.unit].weight
                    set as = g * us /30
                    if a > as then
                        call this.v.add(this.a)
                    endif
                else
                    call this.v.add(this.a)
                endif
            endif
            if unitHitWall then
                call this.v.setLength(0)
            endif
            if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE or clazz == MC_MINE then
                call missleStruct.step()
            endif
        else
            call this.vu.destroy()
        endif
        set tu = null
    endmethod 
    
endstruct

//library Velocity ends
//===========================================================================
// 
// 閾佽鎴樺＋
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Sat Oct 17 18:58:35 2020
//   Map Author: abcdnned
// 
//===========================================================================
//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************
function InitGlobals takes nothing returns nothing
    set udg_r = 0
endfunction
//***************************************************************************
//*
//*  Sounds
//*
//***************************************************************************
function InitSounds takes nothing returns nothing
    set gg_snd_clipin1 = CreateSound( "war3mapImported\\clipin1.wav", false, true, true, 10, 10, "MissilesEAX" )
    call SetSoundDuration( gg_snd_clipin1, 299 )
    call SetSoundChannel( gg_snd_clipin1, 11 )
    call SetSoundVolume( gg_snd_clipin1, 127 )
    call SetSoundPitch( gg_snd_clipin1, 1.0 )
    call SetSoundDistances( gg_snd_clipin1, 600.0, 10000.0 )
    call SetSoundDistanceCutoff( gg_snd_clipin1, 3000.0 )
    call SetSoundConeAngles( gg_snd_clipin1, 0.0, 0.0, 127 )
    call SetSoundConeOrientation( gg_snd_clipin1, 0.0, 0.0, 0.0 )
    set gg_snd_WindWalk = CreateSound( "Abilities\\Spells\\Orc\\WindWalk\\WindWalk.wav", false, true, true, 10, 10, "MissilesEAX" )
    call SetSoundParamsFromLabel( gg_snd_WindWalk, "WindWalk" )
    call SetSoundDuration( gg_snd_WindWalk, 566 )
    call SetSoundChannel( gg_snd_WindWalk, 11 )
    call SetSoundDistances( gg_snd_WindWalk, 600.0, 10000.0 )
    call SetSoundDistanceCutoff( gg_snd_WindWalk, 3000.0 )
    set gg_snd_AxeMissileLaunch1 = CreateSound( "Abilities\\Weapons\\Axe\\AxeMissileLaunch1.wav", false, true, true, 10, 10, "MissilesEAX" )
    call SetSoundParamsFromLabel( gg_snd_AxeMissileLaunch1, "AxeMissileLaunch" )
    call SetSoundDuration( gg_snd_AxeMissileLaunch1, 617 )
    set gg_snd_alicebeep = CreateSound( "war3mapImported\\alicebeep.wav", false, false, true, 10, 10, "MissilesEAX" )
    call SetSoundDuration( gg_snd_alicebeep, 279 )
    call SetSoundChannel( gg_snd_alicebeep, 11 )
    call SetSoundVolume( gg_snd_alicebeep, 127 )
    call SetSoundPitch( gg_snd_alicebeep, 1.0 )
    set gg_snd_togglefiremode = CreateSound( "war3mapImported\\togglefiremode.mp3", false, true, true, 10, 10, "MissilesEAX" )
    call SetSoundDuration( gg_snd_togglefiremode, 191 )
    call SetSoundChannel( gg_snd_togglefiremode, 11 )
    call SetSoundVolume( gg_snd_togglefiremode, 127 )
    call SetSoundPitch( gg_snd_togglefiremode, 1.0 )
    call SetSoundDistances( gg_snd_togglefiremode, 600.0, 10000.0 )
    call SetSoundDistanceCutoff( gg_snd_togglefiremode, 3000.0 )
    call SetSoundConeAngles( gg_snd_togglefiremode, 0.0, 0.0, 127 )
    call SetSoundConeOrientation( gg_snd_togglefiremode, 0.0, 0.0, 0.0 )
    set gg_snd_clipempty = CreateSound( "war3mapImported\\clipempty_pistol.wav", false, true, true, 10, 10, "MissilesEAX" )
    call SetSoundDuration( gg_snd_clipempty, 531 )
    call SetSoundChannel( gg_snd_clipempty, 11 )
    call SetSoundVolume( gg_snd_clipempty, 127 )
    call SetSoundPitch( gg_snd_clipempty, 1.0 )
    call SetSoundDistances( gg_snd_clipempty, 600.0, 10000.0 )
    call SetSoundDistanceCutoff( gg_snd_clipempty, 3000.0 )
    call SetSoundConeAngles( gg_snd_clipempty, 0.0, 0.0, 127 )
    call SetSoundConeOrientation( gg_snd_clipempty, 0.0, 0.0, 0.0 )
    set gg_snd_togglemeele = CreateSound( "Units\\Orc\\HeroBladeMaster\\HeroBladeMasterAttack1.wav", false, true, true, 10, 10, "CombatSoundsEAX" )
    call SetSoundParamsFromLabel( gg_snd_togglemeele, "HeroBladeMasterAttack1" )
    call SetSoundDuration( gg_snd_togglemeele, 1200 )
    set gg_snd_reload = CreateSound( "war3mapImported\\reload.wav", false, true, true, 10, 10, "MissilesEAX" )
    call SetSoundDuration( gg_snd_reload, 287 )
    call SetSoundChannel( gg_snd_reload, 11 )
    call SetSoundVolume( gg_snd_reload, 127 )
    call SetSoundPitch( gg_snd_reload, 1.0 )
    call SetSoundDistances( gg_snd_reload, 600.0, 10000.0 )
    call SetSoundDistanceCutoff( gg_snd_reload, 3000.0 )
    call SetSoundConeAngles( gg_snd_reload, 0.0, 0.0, 127 )
    call SetSoundConeOrientation( gg_snd_reload, 0.0, 0.0, 0.0 )
    set gg_snd_equip2 = CreateSound( "war3mapImported\\plasmariflereload.mp3", false, false, false, 10, 10, "DefaultEAXON" )
    call SetSoundDuration( gg_snd_equip2, 3456 )
    call SetSoundChannel( gg_snd_equip2, 0 )
    call SetSoundVolume( gg_snd_equip2, 127 )
    call SetSoundPitch( gg_snd_equip2, 1.0 )
    set gg_snd_equip1 = CreateSound( "war3mapImported\\equip_armor.mp3", false, false, false, 10, 10, "DefaultEAXON" )
    call SetSoundDuration( gg_snd_equip1, 1314 )
    call SetSoundChannel( gg_snd_equip1, 0 )
    call SetSoundVolume( gg_snd_equip1, 127 )
    call SetSoundPitch( gg_snd_equip1, 1.0 )
    set gg_snd_transport = CreateSound( "Abilities\\Spells\\Human\\ManaShield\\ManaShieldCaster1.wav", false, true, true, 10, 10, "SpellsEAX" )
    call SetSoundParamsFromLabel( gg_snd_transport, "ManaShieldCastSound" )
    call SetSoundDuration( gg_snd_transport, 2554 )
    set gg_snd_opengate = CreateSound( "Sound\\Ambient\\DoodadEffects\\LargeCityGateOpen1.wav", false, false, false, 10, 10, "DefaultEAXON" )
    call SetSoundParamsFromLabel( gg_snd_opengate, "GateOpenSound" )
    call SetSoundDuration( gg_snd_opengate, 1445 )
endfunction
//***************************************************************************
//*
//*  Destructable Objects
//*
//***************************************************************************
function CreateAllDestructables takes nothing returns nothing
    local destructable d
    local trigger t
    local real life
    set gg_dest_DTg5_0047 = CreateDestructable( 'DTg5', -9472.0, 12288.0, 270.000, 0.900, 0 )
endfunction
//***************************************************************************
//*
//*  Items
//*
//***************************************************************************
function CreateAllItems takes nothing returns nothing
    local integer itemID
    call CreateItem( 'I015', -13571.4, 6279.9 )
    call CreateItem( 'I015', -14336.7, 6278.0 )
    call CreateItem( 'I015', 5368.8, 10000.3 )
    call CreateItem( 'I015', 5760.2, 13452.4 )
    call CreateItem( 'I015', 4992.3, 13444.1 )
    call CreateItem( 'I015', 5755.4, 12680.2 )
    call CreateItem( 'I015', -10896.3, 10879.6 )
    call CreateItem( 'I015', -8520.4, 10192.2 )
    call CreateItem( 'I015', -11196.4, 7098.0 )
    call CreateItem( 'I015', 5759.3, 10379.1 )
    call CreateItem( 'I015', 5763.1, 9600.4 )
    call CreateItem( 'I015', 4992.1, 12680.2 )
    call CreateItem( 'I015', -8653.6, 8977.5 )
    call CreateItem( 'I015', -7981.3, 5824.1 )
    call CreateItem( 'I015', -9755.6, 6461.8 )
    call CreateItem( 'I015', 4991.0, 9608.1 )
    call CreateItem( 'I015', 4988.7, 10379.1 )
    call CreateItem( 'I015', 5371.9, 13061.3 )
    call CreateItem( 'I018', -9216.7, 12808.3 )
    call CreateItem( 'I018', -11180.5, 5174.8 )
    call CreateItem( 'I018', -11427.6, 6763.5 )
    call CreateItem( 'I018', -8453.0, 5958.0 )
    call CreateItem( 'I018', -9468.7, 772.8 )
    call CreateItem( 'I018', -9985.9, 776.0 )
    call CreateItem( 'I018', -8701.4, 13325.8 )
    call CreateItem( 'I018', -9472.5, -766.6 )
    call CreateItem( 'I018', -8723.8, 5500.3 )
    call CreateItem( 'I018', -9981.9, -759.7 )
    call CreateItem( 'I018', -9722.5, 2298.6 )
    call CreateItem( 'I018', -10244.6, 13830.9 )
    call CreateItem( 'I018', -10391.9, 6630.8 )
    call CreateItem( 'I018', -8702.5, 13828.7 )
    call CreateItem( 'I018', -9731.6, 12811.7 )
    call CreateItem( 'I018', -10241.9, 13318.8 )
    call CreateItem( 'I018', -9988.3, 2308.9 )
    call CreateItem( 'I018', -9470.5, 2308.9 )
    call CreateItem( 'I018', -9725.9, 776.0 )
    call CreateItem( 'I018', -8130.7, 7282.5 )
    call CreateItem( 'I018', -8796.0, 8812.5 )
    call CreateItem( 'I018', -9605.5, 9362.2 )
    call CreateItem( 'I018', -10428.2, 10913.3 )
    call CreateItem( 'I018', -11048.9, 10668.0 )
    call CreateItem( 'I018', -10964.5, 8432.0 )
    call CreateItem( 'I018', -10763.5, 8264.3 )
    call CreateItem( 'I018', -10897.5, 5911.5 )
    call CreateItem( 'I018', -11086.8, 7543.7 )
    call CreateItem( 'I018', -9086.7, 9367.1 )
    call CreateItem( 'I018', -10817.6, 9682.7 )
    call CreateItem( 'I018', -10752.7, 9563.3 )
    call CreateItem( 'I018', -8782.9, 10338.1 )
    call CreateItem( 'I018', -9215.5, 14340.6 )
    call CreateItem( 'I018', -9730.0, 14336.7 )
    call CreateItem( 'I018', -9727.0, -763.1 )
    call CreateItem( 'I019', -6910.9, -2296.2 )
    call CreateItem( 'I019', -6910.9, -1272.2 )
    call CreateItem( 'I019', -6910.9, -1528.2 )
    call CreateItem( 'I019', 8189.5, 12291.9 )
    call CreateItem( 'I019', 8699.2, 12308.0 )
    call CreateItem( 'I019', -6910.9, -1784.2 )
    call CreateItem( 'I019', -6910.9, -2040.2 )
    call CreateItem( 'I019', 8698.9, 11786.1 )
    call CreateItem( 'I019', -8705.0, 12803.3 )
    call CreateItem( 'I019', -10244.5, 12809.9 )
    call CreateItem( 'I019', -10241.3, 14343.7 )
    call CreateItem( 'I019', -8700.5, 14347.5 )
    call CreateItem( 'I019', 8706.0, 11271.3 )
    call CreateItem( 'I019', 8701.7, 10754.9 )
    call CreateItem( 'I019', 8192.6, 10754.9 )
    call CreateItem( 'I019', 7676.4, 10761.7 )
    call CreateItem( 'I019', 7168.9, 10751.5 )
    call CreateItem( 'I019', 7173.7, 11271.3 )
    call CreateItem( 'I019', 7163.6, 11786.1 )
    call CreateItem( 'I019', 7169.0, 12308.0 )
    call CreateItem( 'I019', 7679.5, 12302.6 )
endfunction
//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************
//===========================================================================
function CreateUnitsForPlayer11 takes nothing returns nothing
    local player p = Player(11)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'z002', -10029.1, 11729.1, 290.081 )
    set u = CreateUnit( p, 'z002', -9679.5, 11733.1, 192.190 )
    set u = CreateUnit( p, 'z002', -9272.6, 11725.1, 0.176 )
    set u = CreateUnit( p, 'z002', -8928.7, 11725.1, 68.809 )
    set u = CreateUnit( p, 'z002', -10394.8, 11759.3, 260.219 )
    set u = CreateUnit( p, 'z002', -8587.2, 11694.6, 34.894 )
    set u = CreateUnit( p, 'u008', -8209.6, 4455.3, 22.171 )
    set u = CreateUnit( p, 'u008', -8431.4, 4307.1, 118.667 )
    set u = CreateUnit( p, 'u008', -8232.9, 3935.8, 255.923 )
    set u = CreateUnit( p, 'u008', -8129.0, 4229.3, 10.218 )
    set u = CreateUnit( p, 'u008', -8350.8, 4165.8, 231.170 )
    set u = CreateUnit( p, 'u008', -8201.5, 4116.6, 218.514 )
    set u = CreateUnit( p, 'u008', -8000.9, 3923.4, 177.039 )
    set u = CreateUnit( p, 'u008', -7962.4, 4126.3, 31.268 )
    set u = CreateUnit( p, 'u008', -11107.9, 4400.9, 334.764 )
    set u = CreateUnit( p, 'u008', -11393.2, 4313.2, 209.966 )
    set u = CreateUnit( p, 'u008', -11261.3, 4017.7, 193.464 )
    set u = CreateUnit( p, 'u008', -11212.6, 4236.4, 4.307 )
    set u = CreateUnit( p, 'u008', -11341.0, 4158.0, 43.024 )
    set u = CreateUnit( p, 'u008', -11074.1, 4102.0, 263.548 )
    set u = CreateUnit( p, 'u008', -11132.7, 3862.6, 309.516 )
    set u = CreateUnit( p, 'u008', -11003.3, 4243.5, 209.768 )
    set u = CreateUnit( p, 'u008', -11328.5, 4482.3, 260.505 )
    set u = CreateUnit( p, 'u008', -8023.2, 4473.7, 171.436 )
endfunction
//===========================================================================
function CreateNeutralPassiveBuildings takes nothing returns nothing
    local player p = Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'ncop', 5632.0, 6144.0, 270.000 )
    set u = CreateUnit( p, 'ncop', 6144.0, 6144.0, 270.000 )
    set u = CreateUnit( p, 'h009', -1792.0, 11520.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -1088.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -1344.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -1472.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -1600.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -1728.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -1856.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -1984.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -2112.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -2240.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3136.0, -2496.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -1088.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -1344.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -1472.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -1600.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -1728.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -1856.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -1984.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -2112.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -2240.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3264.0, -2496.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3392.0, 11712.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3392.0, 11584.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3392.0, 11456.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3392.0, 11328.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3264.0, 11712.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3264.0, 11584.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3264.0, 11456.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3264.0, 11328.0, 270.000 )
    set u = CreateUnit( p, 'nwgt', 7936.0, 11520.0, 270.000 )
    set u = CreateUnit( p, 'nwgt', -6400.0, -1792.0, 270.000 )
    call WaygateSetDestination( u, GetRectCenterX(gg_rct_stage2_start), GetRectCenterY(gg_rct_stage2_start) )
    call WaygateActivate( u, true )
    set u = CreateUnit( p, 'nwgt', -9472.0, 13568.0, 270.000 )
    call WaygateSetDestination( u, GetRectCenterX(gg_rct_stage3_start), GetRectCenterY(gg_rct_stage3_start) )
    call WaygateActivate( u, true )
    set u = CreateUnit( p, 'nwgt', -9728.0, -2816.0, 270.000 )
    call WaygateSetDestination( u, GetRectCenterX(gg_rct_stage1_hero), GetRectCenterY(gg_rct_stage1_hero) )
    call WaygateActivate( u, true )
    set u = CreateUnit( p, 'h006', 3136.0, 11712.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3136.0, 11584.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3136.0, 11456.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3136.0, 11328.0, 270.000 )
endfunction
//===========================================================================
function CreateNeutralPassive takes nothing returns nothing
    local player p = Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set gg_unit_h00G_0050 = CreateUnit( p, 'h00G', -13951.2, 6275.1, 201.536 )
endfunction
//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
endfunction
//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer11( )
endfunction
//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreateNeutralPassiveBuildings( )
    call CreatePlayerBuildings( )
    call CreateNeutralPassive( )
    call CreatePlayerUnits( )
endfunction
//***************************************************************************
//*
//*  Regions
//*
//***************************************************************************
function CreateRegions takes nothing returns nothing
    local weathereffect we
    set gg_rct_lock_1 = Rect( 6912.0, 8512.0, 7616.0, 9120.0 )
    set gg_rct_lock_2 = Rect( 7680.0, 8512.0, 8384.0, 9120.0 )
    set gg_rct_lock_3 = Rect( 8448.0, 8512.0, 9152.0, 9120.0 )
    set gg_rct_lock_11 = Rect( 6912.0, 7840.0, 7616.0, 8448.0 )
    set gg_rct_start = Rect( 8320.0, -2208.0, 9376.0, -1312.0 )
    set gg_rct_start_road_1 = Rect( -32.0, -3072.0, 2560.0, -512.0 )
    set gg_rct_start_road_gate = Rect( 4160.0, -1856.0, 4288.0, -1728.0 )
    set gg_rct_pow0 = Rect( -2112.0, -5184.0, -1984.0, -5056.0 )
    set gg_rct_pow3 = Rect( 4544.0, -5184.0, 4672.0, -5056.0 )
    set gg_rct_pow2 = Rect( 4544.0, 1472.0, 4672.0, 1600.0 )
    set gg_rct_pow1 = Rect( -2112.0, 1472.0, -1984.0, 1600.0 )
    set gg_rct_itmtest = Rect( -800.0, 96.0, -672.0, 256.0 )
    set gg_rct_tower2 = Rect( 3616.0, 704.0, 5440.0, 2368.0 )
    set gg_rct_tower0 = Rect( -2912.0, -5952.0, -1056.0, -4192.0 )
    set gg_rct_tower3 = Rect( 3680.0, -5920.0, 5440.0, -4192.0 )
    set gg_rct_tower1 = Rect( -2848.0, 640.0, -1216.0, 2400.0 )
    set gg_rct_tech = Rect( -3232.0, 4992.0, -2368.0, 5760.0 )
    set gg_rct_stage1_start = Rect( 1056.0, -1952.0, 1536.0, -1568.0 )
    set gg_rct_pick_hero = Rect( 4736.0, 5024.0, 7040.0, 7008.0 )
    set gg_rct_stage1 = Rect( -2976.0, -6048.0, 5536.0, 2464.0 )
    set gg_rct_stage1_tlcannon = Rect( -1248.0, 1056.0, -1152.0, 1152.0 )
    set gg_rct_mancome = Rect( 5568.0, 5440.0, 6208.0, 5696.0 )
    set gg_rct_stage1_hero = Rect( 960.0, -2272.0, 1664.0, -2112.0 )
    set gg_rct_stag1_speed1 = Rect( -3776.0, -1472.0, -3520.0, -1120.0 )
    set gg_rct_stag1_speed2 = Rect( -3776.0, -1984.0, -3520.0, -1632.0 )
    set gg_rct_stag1_speed3 = Rect( -3776.0, -2496.0, -3520.0, -2144.0 )
    set gg_rct_stage1_wall1 = Rect( -3424.0, -2752.0, -2976.0, -896.0 )
    set gg_rct_stage2_start = Rect( -10048.0, -2944.0, -9376.0, -2688.0 )
    set gg_rct_stage1_exit = Rect( -7040.0, -2528.0, -2976.0, -1024.0 )
    set gg_rct_stage2_1 = Rect( -10656.0, -3488.0, -8800.0, -2144.0 )
    set gg_rct_stage2_2 = Rect( -10272.0, -2176.0, -9184.0, 3712.0 )
    set gg_rct_stage2_3 = Rect( -11680.0, 3680.0, -7776.0, 11328.0 )
    set gg_rct_stage2_jump1 = Rect( -9888.0, 5056.0, -9568.0, 5280.0 )
    set gg_rct_stage2_fire1 = Rect( -11680.0, 5728.0, -7776.0, 11328.0 )
    set gg_rct_stage2_fire2 = Rect( -11680.0, 4768.0, -10304.0, 5856.0 )
    set gg_rct_stage2_fire3 = Rect( -9152.0, 4896.0, -7776.0, 5824.0 )
    set gg_rct_stage2_refresh1 = Rect( -10304.0, 8544.0, -10080.0, 8736.0 )
    set gg_rct_stage2_refresh2 = Rect( -10272.0, 9184.0, -10048.0, 9376.0 )
    set gg_rct_stage2_refresh3 = Rect( -10272.0, 9824.0, -10080.0, 10016.0 )
    set gg_rct_stage2_refresh4 = Rect( -9632.0, 9824.0, -9440.0, 10016.0 )
    set gg_rct_stage2_refresh5 = Rect( -10944.0, 9824.0, -10720.0, 10016.0 )
    set gg_rct_stage2_refresh6 = Rect( -9632.0, 10464.0, -9440.0, 10688.0 )
    set gg_rct_stage2_refresh7 = Rect( -9856.0, -96.0, -9600.0, 96.0 )
    set gg_rct_stage2_refresh8 = Rect( -9856.0, 1440.0, -9600.0, 1632.0 )
    set gg_rct_stage2_refresh9 = Rect( -9856.0, 2976.0, -9600.0, 3168.0 )
    set gg_rct_stage2_4 = Rect( -14208.0, 9728.0, -11328.0, 10112.0 )
    set gg_rct_stage2_5 = Rect( -10624.0, 11168.0, -8320.0, 12096.0 )
    set gg_rct_stage2_6 = Rect( -10560.0, 12512.0, -8384.0, 14656.0 )
    set gg_rct_stage2_speed1 = Rect( -14144.0, 9120.0, -13760.0, 9408.0 )
    set gg_rct_stage2_speed2 = Rect( -14720.0, 8256.0, -13632.0, 8640.0 )
    set gg_rct_stage2_speed3 = Rect( -14272.0, 7488.0, -13184.0, 7872.0 )
    set gg_rct_stage2_speed4 = Rect( -14720.0, 6720.0, -13632.0, 7104.0 )
    set gg_rct_stage2_7 = Rect( -14208.0, 8512.0, -13696.0, 9856.0 )
    set gg_rct_stage2_8 = Rect( -14720.0, 5920.0, -13184.0, 8832.0 )
    set gg_rct_stage2_gate = Rect( -9920.0, 11904.0, -9056.0, 12640.0 )
    set gg_rct_stage2_9 = Rect( -9632.0, 12064.0, -9344.0, 12544.0 )
    set gg_rct_stage3_jump_up = Rect( -2016.0, 12800.0, -1568.0, 13152.0 )
    set gg_rct_stage3_jump_down = Rect( -2016.0, 9888.0, -1568.0, 10240.0 )
    set gg_rct_stage3_jump_right = Rect( -480.0, 11296.0, -128.0, 11744.0 )
    set gg_rct_stage3_jump_left = Rect( -3456.0, 11296.0, -3104.0, 11744.0 )
    set gg_rct_stage3_start = Rect( -2144.0, 10944.0, -1440.0, 11200.0 )
    set gg_rct_stage3 = Rect( -6432.0, 6880.0, 2848.0, 16160.0 )
    set gg_rct_stage3_pow_ul = Rect( -5440.0, 14016.0, -5312.0, 14144.0 )
    set gg_rct_stage3_pow_ur = Rect( 704.0, 15040.0, 832.0, 15168.0 )
    set gg_rct_stage3_pow_dr = Rect( 1728.0, 8896.0, 1856.0, 9024.0 )
    set gg_rct_stage3_pow_dl = Rect( -4416.0, 7872.0, -4288.0, 8000.0 )
    set gg_rct_stage3_center = Rect( -4128.0, 9216.0, 512.0, 13824.0 )
    set gg_rct_stage3_way = Rect( 2752.0, 11296.0, 7040.0, 11776.0 )
    set gg_rct_stage3_end = Rect( 6880.0, 10464.0, 8992.0, 12576.0 )
    set gg_rct_stage3_speeddown = Rect( -5568.0, 12864.0, -5184.0, 13120.0 )
    set gg_rct_stage3_speedright = Rect( -3392.0, 7744.0, -3136.0, 8128.0 )
    set gg_rct_stage3_speedup = Rect( 1600.0, 9920.0, 1984.0, 10176.0 )
    set gg_rct_stage3_speedleft = Rect( -448.0, 14912.0, -192.0, 15264.0 )
    set gg_rct_stage3_sr2 = Rect( 4512.0, 11328.0, 4800.0, 11712.0 )
    set gg_rct_stage3_sr1 = Rect( 3488.0, 11328.0, 3776.0, 11712.0 )
    set gg_rct_stage3_sr3 = Rect( 5536.0, 11328.0, 5824.0, 11712.0 )
    set gg_rct_stage3_sr4 = Rect( 6560.0, 11328.0, 6848.0, 11712.0 )
    set gg_rct_stage3_hide5 = Rect( 4736.0, 12416.0, 6016.0, 13696.0 )
    set gg_rct_stage3_hide4 = Rect( 3200.0, 13056.0, 4800.0, 13184.0 )
    set gg_rct_stage3_hide1 = Rect( 3200.0, 9856.0, 3360.0, 13088.0 )
    set gg_rct_stage3_hide2 = Rect( 3264.0, 9856.0, 4832.0, 9984.0 )
    set gg_rct_stage3_hide3 = Rect( 4736.0, 9344.0, 6016.0, 10592.0 )
endfunction
//***************************************************************************
//*
//*  Cameras
//*
//***************************************************************************
function CreateCameras takes nothing returns nothing
    set gg_cam_lv1 = CreateCameraSetup( )
    call CameraSetupSetField( gg_cam_lv1, CAMERA_FIELD_ZOFFSET, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_lv1, CAMERA_FIELD_ROTATION, 89.7, 0.0 )
    call CameraSetupSetField( gg_cam_lv1, CAMERA_FIELD_ANGLE_OF_ATTACK, 312.4, 0.0 )
    call CameraSetupSetField( gg_cam_lv1, CAMERA_FIELD_TARGET_DISTANCE, 2415.8, 0.0 )
    call CameraSetupSetField( gg_cam_lv1, CAMERA_FIELD_ROLL, 0.0, 0.0 )
    call CameraSetupSetField( gg_cam_lv1, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0 )
    call CameraSetupSetField( gg_cam_lv1, CAMERA_FIELD_FARZ, 5000.0, 0.0 )
    call CameraSetupSetDestPosition( gg_cam_lv1, -534.3, 1418.3, 0.0 )
endfunction
//***************************************************************************
//*
//*  Custom Script Code
//*
//***************************************************************************
//TESH.scrollpos=24
//TESH.alwaysfold=0
function TextTagBigger takes nothing returns nothing
    local timer tim=GetExpiredTimer()
    local integer dec=GetHandleId(tim)
    local texttag tex=LoadTextTagHandle(ht,dec,ktex)
    local real count=LoadReal(ht,dec,ksteps)
    local string dam=LoadStr(ht,dec,kdamage)
    if count>0 then
        call SetTextTagTextBJ( tex, dam, 10*(1+Sin(((25-count)/25)*3.14159) ))
        set count=count-1
        call SaveReal(ht,dec,ksteps,count)
    else
        call YDWETimerDestroyTextTag( 1.7, tex )
        call FlushChildHashtable(ht,dec)
        call DestroyTimer(tim)
    endif
    set tim=null
    set tex=null
endfunction
function DisplayDamageCA takes nothing returns nothing
    local timer tim
    local unit tu
    local real count=15
    local integer dec
    local real damr=GetEventDamage()
    local string dam
    local texttag tex
    if damr>1 then
        set tim=CreateTimer()
        set tu=GetTriggerUnit()
        set dec=GetHandleId(tim)
        set dam=I2S(R2I(damr))
        if GetOwningPlayer(tu) == Player(11) then
            set tex= CreateTextTagUnitBJ( dam, tu, 0.00, 10, 70, 70, 100, 0 )
        else
            set tex= CreateTextTagUnitBJ( dam, tu, 0.00, 10, 120, 70, 70, 0 )
        endif
        call SetTextTagVelocityBJ( tex, GetRandomReal(50.00,75.00), GetRandomReal(80.00,100.00) )
        call SaveReal(ht,dec,ksteps,count)
        call SaveTextTagHandle(ht,dec,ktex,tex)
        call SaveStr(ht,dec,kdamage,dam)
        call TimerStart(tim,0.02,true,function TextTagBigger)
        set tim=null
        set tu= null
        set tex=null
    endif
endfunction
function InitDisplayDamageSystem takes nothing returns nothing
    local trigger trg
    set trg=CreateTrigger()
    call YDWESyStemAnyUnitDamagedRegistTrigger( trg )
    call TriggerAddCondition(trg,function DisplayDamageCA)
    set trg=null
endfunction
//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************
//===========================================================================
// Trigger: Stage2Gate
//===========================================================================
//TESH.scrollpos=2
//TESH.alwaysfold=0
function OpenGate takes nothing returns nothing
    call ModifyGateBJ( bj_GATEOPERATION_OPEN, gg_dest_DTg5_0047 )
    call PlaySoundBJ(gg_snd_opengate)
endfunction
function Trig_Stage2GateActions takes nothing returns nothing
    local integer i = 0
    call SetUnitAnimation( gg_unit_h00G_0050, "death" )
    loop
        exitwhen i > 2
        call CreateFogModifierRectBJ( true, Player(i), FOG_OF_WAR_VISIBLE, gg_rct_stage2_gate )
        call RegionAddRect(playable_region, gg_rct_stage2_9)
        call RegionAddRect(playable_region, gg_rct_stage3)
        call PanCameraToTimedForPlayer(Player(i), -9476, 12178, 1.5)
        set i = i + 1
    endloop
    call TimerStart(CreateTimer(), 2, false, function OpenGate)
endfunction
//===========================================================================
function InitTrig_Stage2Gate takes nothing returns nothing
    set gg_trg_Stage2Gate = CreateTrigger()
    call TriggerRegisterUnitManaEvent( gg_trg_Stage2Gate, gg_unit_h00G_0050, GREATER_THAN_OR_EQUAL, 9.90 )
    call TriggerAddAction(gg_trg_Stage2Gate, function Trig_Stage2GateActions)
endfunction
//===========================================================================
// Trigger: Stage1
//
// 33638103 鐢佃瘽
//===========================================================================
//TESH.scrollpos=161
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Stage1T
//
// Abilities\Spells\Items\TomeOfRetraining\TomeOfRetrainingCaster.mdl
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_Stage1TActions takes nothing returns nothing
    local unit tg = GetTriggerUnit()
    local integer i = 0
    local location l
    local real x
    local real y
    local real d
    local real r
    local unit ydl_unit
    if IsHero(tg) the
        //call BJDebugMsg("enger")
        call GroupEnumUnitsInRange(ENUM_GROUP, GetUnitX(tg), GetUnitY(tg), 500,null) 
        loop
            set ydl_unit = FirstOfGroup(ENUM_GROUP)
            exitwhen ydl_unit == null or GetUnitTypeId(ydl_unit) == 'n001'
            call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        endloop
        if ydl_unit != null then
            //call BJDebugMsg("in")
            loop
                exitwhen i > 4
                set i = i + 1
                set d = GetRandomReal(0, 800.0)
                set r = GetRandomReal(0, 2*pi)
                set x = GetUnitX(tg) + d * Cos(r)
                set y = GetUnitY(tg) + d * Sin(r)
                call CreateItem('I00T', x, y)
            endloop
            set d = GetRandomReal(0, 800.0)
            set r = GetRandomReal(0, 2*pi)
            set x = GetUnitX(tg) + d * Cos(r)
            set y = GetUnitY(tg) + d * Sin(r)
            call CreateItem('I015', x, y)
            call RemoveUnit(ydl_unit)
            //call DisableTrigger(GetTriggeringTrigger())
            call CreateEffect("Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl", GetUnitX(ydl_unit), GetUnitY(ydl_unit))
        endif
        //call BJDebugMsg("end")
    endif
    set l = null
    set tg = null
    set ydl_unit = null
endfunction
//===========================================================================
function InitTrig_Stage1T takes nothing returns nothing
    set gg_trg_Stage1T = CreateTrigger()
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_Stage1T, gg_rct_pow0 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_Stage1T, gg_rct_pow1 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_Stage1T, gg_rct_pow2 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_Stage1T, gg_rct_pow3 )
    call TriggerAddAction(gg_trg_Stage1T, function Trig_Stage1TActions)
endfunction
//===========================================================================
// Trigger: Resources
//===========================================================================
//TESH.scrollpos=12
//TESH.alwaysfold=0
//===========================================================================
// Trigger: InitJobData
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Strong
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0
//===========================================================================
// Trigger: TransportEnergy
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct TransportEnergy extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A02N'
    endmethod
    
    method onEffect takes nothing returns nothing
        //local real dis
        //set dis = DistanceTwoUnits(caster, targetUnit)
        //if dis < 400 or (IsHero(targetUnit) and dis < 800) then
            call TransportBuffer.create(caster, targetUnit, 250).start()
        //else
            //call DisplayInfo(GetOwningPlayer(caster), "璺濈澶繙")
        //endif
    endmethod
endstruct
//===========================================================================
// Trigger: HolyLight
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct HolyLight extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A02E'
    endmethod
    
    method onEffect takes nothing returns nothing
        if IsLiveEnemy(caster, targetUnit) then
            call EnergyDamage(caster, targetUnit, 970)
        endif
    endmethod
endstruct
//===========================================================================
// Trigger: ReviveSpell
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct ReviveSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A02H'
    endmethod
    
    method onFinish takes nothing returns nothing
        call BeHealth(GetPlayerId(GetOwningPlayer(caster)))
        call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl", GetUnitX(caster), GetUnitY(caster)))
        call PauseUnit(caster, true)
        call SetUnitAnimationByIndex(caster, 0)
        call PauseUnit(caster, false)
    endmethod
endstruct
//===========================================================================
// Trigger: DawnHammer
//
//     local unit dummy
//     set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
//     call IssueTargetOrderById( dummy, 852226,target )
//     set dummy = null
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct DawnHammer extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A02F'
    endmethod
    
    method onEffect takes nothing returns nothing
        local unit dummy
        set dummy = CreateUnit(GetOwningPlayer(caster),MAGIC,targetX,targetY,0)
        call IssuePointOrderById( dummy, 852591, targetX, targetY )
        set dummy = null
        call SetPlayerState(GetOwningPlayer(caster), PLAYER_STATE_RESOURCE_LUMBER, GetPlayerState(GetOwningPlayer(caster), PLAYER_STATE_RESOURCE_LUMBER) - 5)
    endmethod
    
endstruct
//===========================================================================
// Trigger: NetGun
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct NetSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A021'
    endmethod
    
    method onChannel takes nothing returns nothing
        local item itm = GetItemByTypeId(caster, 'I012')
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local ItemFeature f3 = IndividualItemData[itm].featureData.f3
        local NetMissleFactory factory = NetMissleFactory.create()
        local NetShooter shooter = NetShooter.create(caster, factory, 3 + 2*f3.lv)
        local vector dir = getDirVector(caster, targetUnit, 60)
        //call BJDebugMsg("net")
        call shooter.shoot(dir)
        set itm = null
    endmethod
endstruct//===========================================================================
// Trigger: ShootBost
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct ShootBostSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01T'
    endmethod
    
    method onChannel takes nothing returns nothing
        local item itm = GetItemByTypeId(caster, 'I00Y')
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local ItemFeature f3 = IndividualItemData[itm].featureData.f3 
        if f2.lv > 0 then
            call SetPlayerState(GetOwningPlayer(caster),PLAYER_STATE_RESOURCE_FOOD_USED ,GetPlayerState(GetOwningPlayer(caster), PLAYER_STATE_RESOURCE_FOOD_CAP))
        endif
        call ShootBostBuffer.create(caster,R2I((6+f3.lv)*50), 20 + f1.lv).start()
        set itm = null
    endmethod
endstruct//===========================================================================
// Trigger: PowerPunch
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
struct PowerPunchSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01Y'
    endmethod
    
    method onChannel takes nothing returns nothing
        local unit ydl_unit
        local location loc = Location(casterX, casterY)
        local item itm = GetItemByTypeId(caster, 'I00Z')
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local ItemFeature f3 = IndividualItemData[itm].featureData.f3
        local ItemFeature f4 = IndividualItemData[itm].featureData.f4
        local ItemFeature f5 = IndividualItemData[itm].featureData.f5
        call GroupEnumUnitsInRange(ENUM_GROUP, casterX, casterY, 500 + (50 * f3.lv),null) 
        loop
            set ydl_unit = FirstOfGroup(ENUM_GROUP)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(ENUM_GROUP, ydl_unit) 
            if IsLiveEnemyUnitOrDestroyableWall(caster,ydl_unit) then
                call Stun(caster, ydl_unit, 3 + f4.lv)
                call Push(ydl_unit, getTargetDir(caster, ydl_unit), f2.lv * 5, 12, 5)
                call AbliDamage(caster, ydl_unit, abidmg_seed * 2.0 * (1 + 0.1 * f1.lv), SMALL_BLOOD)
            endif
        endloop
        if f5.lv > 0 then
            call Clap3000(caster, f5.lv)
            call TerrainDeformationRippleBJ( 1, false,loc, 500, 3000, 50, 1, 512 )
        endif
        call DestroyEffect( AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl", casterX, casterY) )
        set loc = null
        set itm = null
    endmethod
endstruct
//===========================================================================
// Trigger: SelectHero
//===========================================================================
//TESH.scrollpos=12
//TESH.alwaysfold=0
struct SelectHero extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A02D'
    endmethod
    
    method onChannel takes nothing returns nothing
        local unit u = targetUnit
        local player p = GetOwningPlayer(caster)
        local integer pi = GetPlayerId(p)
        local integer ut = GetUnitTypeId(u)
        local location l
        local integer i = 0
        local boolean f = true
        local unit hero
        if (ut == 'H00B' or ut == 'H00C') and heros[pi] == null then
            set herosType[pi] = ut
            call DisplayInfoAll(GetPlayerName(p) + " 閫夋嫨浜?" + GetUnitName(targetUnit))
            call RemoveUnit(caster)
            set picked_hero = picked_hero + 1
            if picked_hero < CurrentPlayerCount() then
                call DisplayInfo(p, "璇疯€愬績绛夊緟鍏朵粬浜?)
            else
                call StartStage1()
            endif
        endif
        set l = null
        set p = null
        set u = null
        set hero = null
    endmethod
    
endstruct
//===========================================================================
// Trigger: Reload
//
//                     if not EquipmentData[owner].heroData.reload then
//                         set EquipmentData[this.owner].heroData.shoot_energy = 0
//                         call SetPlayerState(GetOwningPlayer(owner),PLAYER_STATE_RESOURCE_FOOD_USED, 0)
//                         call UnitAddAbility(owner, 'Abun')
//                         set EquipmentData[owner].heroData.reload = true
//                     endif
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct Reload extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01V'
    endmethod
    
    method onEffect takes nothing returns nothing
        if not EquipmentData[caster].heroData.reload then
            call DisplayFloatText(GetUnitX(caster),GetUnitY(caster),"瑁呭脊锛?,1)
            set EquipmentData[caster].heroData.shoot_energy = 0
            call SetPlayerState(GetOwningPlayer(caster),PLAYER_STATE_RESOURCE_FOOD_USED, 0)
            call UnitAddAbility(caster, 'Abun')
            set EquipmentData[caster].heroData.reload = true
            set EquipmentData[caster].heroData.shoot_buffer = 0
            //if EquipmentData[caster].heroData.reloade != null then
                //call DestroyEffect(EquipmentData[caster].heroData.reloade)
            //endif
            //set EquipmentData[caster].heroData.reloade = AddSpecialEffectTarget("Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl",caster,"overhead")
        endif
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: ItemJump
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct ItemJump extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A00A'
    endmethod
    
    method onChannel takes nothing returns nothing
        local real facing = getFacing(caster)
        local item itm = GetItemByTypeId(caster, iJUMP)
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real d = f2.getValue()
        local real h = f1.getValue()
        local vector v = vector.create(d*Cos(facing),d*Sin(facing),h)
        call AddVelocity(caster, v)
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct
//===========================================================================
// Trigger: GunSpell
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Jump
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0
struct Jump extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A027'
    endmethod
    
    method onChannel takes nothing returns nothing
        local real facing = getDir(casterX, casterY, targetX, targetY)
        local real dis = RMinBJ(600, DistanceTwo(casterX, casterY, targetX, targetY))
        local real d = 24 * (dis/600)
        local real h = 35
        local unit u
        local vector v = vector.create(d*Cos(facing),d*Sin(facing),h)
        //call IssueImmediateOrder( caster, "stop" )
        if GetUnitState(caster, UNIT_STATE_MANA) >= 3 then
            call SetUnitState(caster, UNIT_STATE_MANA, GetUnitState(caster, UNIT_STATE_MANA) - 5)
            call DisplayManaCost(caster, 5)
        else
            call DisplayWarning(GetOwningPlayer(caster), "寮鸿璺宠穬锛岀敓鍛藉€?10")
            call SetUnitState(caster, UNIT_STATE_LIFE, RMaxBJ(1, GetUnitState(caster, UNIT_STATE_LIFE) - 10))
        endif
        set u = CreateUnit(GetOwningPlayer(caster), 'e00N', casterX, casterY, 0)
        call SetUnitFlyHeight(u, GetUnitFlyHeight(caster),0)
        call KillUnit(u)
        call AddVelocity(caster, v)
        set Material[caster].nohitwall = 99
        set u = null
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct
//===========================================================================
// Trigger: JumpFacingStore
//
// function Trig_fd________4_______uConditions takes nothing returns boolean
//     return ((GetIssuedOrderIdBJ() == String2OrderIdBJ("move")) and (GetUnitTypeId(GetTriggerUnit()) == 'hfoo'))
// endfunction
// function Trig_fd________4_______uActions takes nothing returns nothing
//     call CreateTextTagLocBJ( "TRIGSTR_1340", GetRectCenter(GetPlayableMapRect()), GetOrderPointX(), GetOrderPointY(), 100, 100, 100, 0 )
// endfunction
// IsHero(GetOrderTargetUnit()) and 
// //===========================================================================
// function InitTrig_fd________4_______u takes nothing returns nothing
//     set gg_trg_fd________4_______u = CreateTrigger()
// #ifdef DEBUG
//     call YDWESaveTriggerName(gg_trg_fd________4_______u, "fd 澶嶅埗 4 澶嶅埗")
// #endif
//     call TriggerRegisterAnyUnitEventBJ( gg_trg_fd________4_______u, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER )
//     call TriggerAddCondition(gg_trg_fd________4_______u, Condition(function Trig_fd________4_______uConditions))
//     call TriggerAddAction(gg_trg_fd________4_______u, function Trig_fd________4_______uActions)
// endfunction
//===========================================================================
//TESH.scrollpos=7
//TESH.alwaysfold=0
//===========================================================================
// Trigger: InjectionSpeedUp
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
struct InjectionSpeedUp extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A00C'
    endmethod
    
    method onChannel takes nothing returns nothing
        local item itm = GetItemByTypeId(caster, 'I003')
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local ItemFeature f3 = IndividualItemData[itm].featureData.f3 
        local real facing = getFacing(caster)
        local real speed = 3 + f1.lv
        call Push(caster, facing, speed, 0, 30)
        call BoundUnitEffectStruct.create(caster, 30, 'e001', GetUnitFacing(caster) - 90, "stand", 70).start()
        if f2.lv > 0 then
            call SetUnitAbilityLevel(caster, 'A00C', 1 + f2.lv)
        endif
        if f3.lv > 0 then
            call SpeedColBuffer.create(caster,4*50,f3.lv).start()
        endif
        set itm = null
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct
//===========================================================================
// Trigger: RegisterSpell
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: Darts
//
// SmallDartsFactory
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
struct Darts extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A00D'
    endmethod
    
    private method getSpeed takes nothing returns real
        return 60.0
    endmethod
    
    method onChannel takes nothing returns nothing
        local unit tu = GetNearestEnemy(caster, 1000)
        local real speed = getSpeed()
        local real dd
        local IShooter shooter = SingleShooter.create(caster, SmallDartsFactory.create())
        local vector dir
        if (tu == null) then
            set dd = getFacing(caster)
            set dir = vector.create(speed * Cos(dd), speed * Sin(dd), 0)
        else
            set dir = getDirVector(caster, tu, speed)
        endif
        call shooter.shoot(dir)
        set tu =null
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct
//===========================================================================
// Trigger: RetrunDarts
//===========================================================================
//TESH.scrollpos=1
//TESH.alwaysfold=0
struct ReturnDartsSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01L'
    endmethod
    
    private method getSpeed takes nothing returns real
        local real speed = 100
        return speed
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local ReturnDartsFactory factory = ReturnDartsFactory.create()
        local IShooter shooter = SingleShooter.create(caster, factory)
        local vector dir = vector.create(targetX - casterX, targetY - casterY, 0)
        call dir.setLength(getSpeed())
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: SmartDarts
//===========================================================================
//TESH.scrollpos=8
//TESH.alwaysfold=0
struct SmartDartsSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01O'
    endmethod
    
    private method getSpeed takes nothing returns real
        local real speed = 40
        return speed
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local SmartDartsFactory factory = SmartDartsFactory.create(targetUnit)
        local item itm = GetItemByTypeId(caster, 'I00Q')
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local ItemFeature f3 = IndividualItemData[itm].featureData.f3
        local real multilv = f2.lv
        local IShooter shooter
        local vector dir = vector.create(targetX - casterX, targetY - casterY, 0)
        if multilv == 1 then
            set shooter = TripleShooter.create(caster, factory)
        elseif multilv == 2 then
            set shooter = Multi5Shooter.create(caster, factory)
        else
            set shooter = SingleShooter.create(caster, factory)
        endif
        call dir.setLength(getSpeed())
        call shooter.shoot(dir)
        call PlaySoundOnUnitBJ( gg_snd_AxeMissileLaunch1, 100, caster )
        call shooter.destroy()
        if f3.lv > 0 then
            call SetPlayerAbilityAvailable( GetOwningPlayer(caster), 'A01O', false)
            call UnitAddAbility(caster, 'A01Z')
        endif
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: ExplodeSmartDarts
//===========================================================================
//TESH.scrollpos=2
//TESH.alwaysfold=0
struct ExplodeSmartDartsSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01Z'
    endmethod
    
    method onChannel takes nothing returns nothing
        local unit ydl_unit
        local group g = NewGroup()
        call GroupEnumUnitsOfPlayer(g, GetOwningPlayer(caster),null)
        loop
            set ydl_unit = FirstOfGroup(g)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(g, ydl_unit)
            if GetUnitTypeId(ydl_unit) == 'e003' then
                call Velocity[ydl_unit].missleStruct.destroy()
            endif
        endloop
        call ReleaseGroup(g)
        set g = null
        call IssueImmediateOrderById( caster, 851972 )
    endmethod
    
endstruct//===========================================================================
// Trigger: ShoulderCannon
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct ShoulderCannonSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01N'
    endmethod
    
    private method getSpeed takes nothing returns real
        local real speed = 45
        return speed
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local ShoulderCannonFactory factory = ShoulderCannonFactory.create()
        local IShooter shooter = ShoulderCannonShooter.create(caster, factory)
        //local IShooter shooter = SingleShooter.create(caster, factory)
        local vector dir = vector.create(targetX - casterX, targetY - casterY, 0)
        call dir.setLength(getSpeed())
        call shooter.shoot(dir)
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: ItemRetrunDarts
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct ItemReturnDartsSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A002'
    endmethod
    
    private method getSpeed takes nothing returns real
        local item itm = GetItemByTypeId(caster, iRETURN)
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        set itm = null
        return f1.getValue()
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local ReturnDartsFactory factory = ReturnDartsFactory.create()
        local IShooter shooter = SingleShooter.create(caster, factory)
        local vector dir = vector.create(targetX - casterX, targetY - casterY, 0)
        call dir.setLength(getSpeed())
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: LeaveDarts
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct LeaveDartsSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aLEAVE
    endmethod
    
    private method getSpeed takes nothing returns real
        return 80.0
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local LeaveDartsFactory factory = LeaveDartsFactory.create()
        local IShooter shooter = SingleShooter.create(caster, factory)
        local vector dir = vector.create(targetX - casterX, targetY - casterY, 0)
        call dir.setLength(getSpeed())
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: DartsStorm
//===========================================================================
//TESH.scrollpos=5
//TESH.alwaysfold=0
struct DartsStormSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A028'
    endmethod
    
    method onEffect takes nothing returns nothing
        local LeaveDartsFactory factory = LeaveDartsFactoryV2.create()
        //local SmallDartsFactory factory = SmallDartsFactory.create()
        local integer i = 0
        local IShooter shooter = SingleShooter.create(caster, factory)
        local vector dir = 0
        local real s = (2 * pi) / 20
        loop
            exitwhen i >= 20
            set dir = vector.create(1 * Cos(i*s), 1 * Sin(i * s), 0)
            call dir.setLength(80)
            call shooter.shoot(dir)
            set i = i + 1
        endloop
        call SetPlayerState(GetOwningPlayer(caster), PLAYER_STATE_RESOURCE_LUMBER, GetPlayerState(GetOwningPlayer(caster), PLAYER_STATE_RESOURCE_LUMBER) - 5)
        call shooter.destroy()
        call factory.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: GuardDarts
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct GuardDartsSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A029'
    endmethod
    
    method onEffect takes nothing returns nothing
        local integer i = 0
        local GuardDarts gd
        local real s = (2 * pi) / 3
        loop
            exitwhen i >= 3
            set gd = GuardDarts.create(caster, s * i)
            call gd.fireMissle(vector.create(1,1,1))
            set i = i + 1
        endloop
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: BackGrenade
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct BackGrenadeSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aBKGRENADE
    endmethod
    
    private method getSpeed takes nothing returns real
        local item itm = GetItemByTypeId(caster, iBKGRENADE)
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        set itm = null
        return f1.getValue()
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local BackGrenadeFactory factory = BackGrenadeFactory.create()
        local IShooter shooter = GrenadeThrower.create(caster, factory)
        local vector dir = GetGrenadeVector(casterX, casterY, targetX, targetY)
        local real v = GetGrenadeTrajectory(casterX, casterY, targetX, targetY)
        call dir.setLength(RMinBJ(v,speed))
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: Mine
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct MineSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aMINE
    endmethod
       
    method onChannel takes nothing returns nothing
        local MineFactory factory = MineFactory.create()
        local IShooter shooter = MineThrower.create(caster, factory)
        local vector dir = vector.create(0,0,0)
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: PushGrenade
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0
struct PushGrenadeSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aPSGRENADE
    endmethod
    
    private method getSpeed takes nothing returns real
        local item itm = GetItemByTypeId(caster, iPSGRENADE)
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        set itm = null
        return f1.getValue()
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local PushGrenadeFactory factory = PushGrenadeFactory.create()
        local IShooter shooter = GrenadeThrower.create(caster, factory)
        local vector dir = GetGrenadeVector(casterX, casterY, targetX, targetY)
        local real v = GetGrenadeTrajectory(casterX, casterY, targetX, targetY)
        call dir.setLength(RMinBJ(v,speed))
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: Blink
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct Blink extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aBLINK
    endmethod
    
    method onChannel takes nothing returns nothing
        local real dis = DistanceTwo(casterX,casterY,targetX,targetY)
        local real max = getf1value(caster,iBLINK)
        local real r = RMinBJ(max,dis)
        local real ang = getDir(casterX,casterY,targetX,targetY)
        local real tx = casterX + r * Cos(ang)
        local real ty = casterY + r * Sin(ang)
        call DestroyEffect( AddSpecialEffect(E_BLINK_CASTER, casterX, casterY) )
        call SetUnitX(caster, tx)
        call SetUnitY(caster, ty)
        call DestroyEffect( AddSpecialEffect(E_BLINK_TARGET, tx, ty) )
    endmethod
    
endstruct//===========================================================================
// Trigger: Transport
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct Transport extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aTRANSPORT
    endmethod
    
    method onFinish takes nothing returns nothing
        local real dis = DistanceTwo(casterX,casterY,targetX,targetY)
        local real max = getf1value(caster,iTRANSPORT)
        local real r = RMinBJ(max,dis)
        local real ang = getDir(casterX,casterY,targetX,targetY)
        local real tx = casterX + r * Cos(ang)
        local real ty = casterY + r * Sin(ang)
        call DestroyEffect( AddSpecialEffect(E_TRANSPORT_CASTER, casterX, casterY) )
        call SetUnitX(caster, tx)
        call SetUnitY(caster, ty)
        call DestroyEffect( AddSpecialEffect(E_TRANSPORT_TARGET, tx, ty) )
    endmethod
    
endstruct
//===========================================================================
// Trigger: ElectricWhip
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
struct ElectricWhipSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A00G'
    endmethod
    
    
    method onChannel takes nothing returns nothing
        local ElectricWhipFactory factory = ElectricWhipFactory.create()
        local IShooter shooter = SingleShooter.create(caster, factory)
        local real uz = getUnitHeight(caster)
        local real tz
        local vector dir
        if targetUnit == null then
            set tz = getTerrianHeight(targetX, targetY)
            set dir = vector.create(targetX - casterX, targetY - casterY, tz - uz)
        else
            set tz = getUnitHeight(targetUnit)
            set dir = vector.create(targetX - casterX, targetY - casterY, tz - uz)
        endif
        call dir.setLength(getf1value(caster, iELECTRIC))
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: AutoAim
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct AutoAim extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aAUTOAIM
    endmethod
    
    method onChannel takes nothing returns nothing
        local real time = getf1value(caster, iAUTOAIM)
        call AutoAimBuffer.create(caster,R2I(time*50)).start()
    endmethod
    
endstruct
//===========================================================================
// Trigger: ShootBack
//
//         local real facing = getFacing(caster) + pi
//         local item itm = GetItemByTypeId(caster, iREACT)
//         local ItemFeature f = IndividualItemData[itm].featureData.f1
//         local real speed = f.getValue()
//         call Push(caster, facing, speed, 0, 5)
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct ShootBack extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A00F'
    endmethod
    
    method onChannel takes nothing returns nothing
        local real facing = getFacing(caster) + pi
        local item itm = GetItemByTypeId(caster, iREACT)
        local ItemFeature f = IndividualItemData[itm].featureData.f1
        local real speed = f.getValue()
        set EquipmentData[caster].heroData.a_shoot_back = EquipmentData[caster].heroData.a_shoot_back + speed
        set EquipmentData[caster].heroData.a_shoot_back_log = speed
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct
// Trigger: TeckLock
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
function Trig_TeckLockActions takes nothing returns nothing
    local integer i = 10
    set gg_rct_lock[0] = gg_rct_lock_1
    set gg_rct_lock[1] = gg_rct_lock_2
    set gg_rct_lock[2] = gg_rct_lock_3
    loop
        exitwhen i >= PLAYER_COUNT
        call EnableAbiLock(i)
        set i = i + 1
    endloop
endfunction
//===========================================================================
function InitTrig_TeckLock takes nothing returns nothing
    set gg_trg_TeckLock = CreateTrigger()
    call TriggerAddAction(gg_trg_TeckLock, function Trig_TeckLockActions)
endfunction
//===========================================================================
// Trigger: Register
//===========================================================================
function Trig_RegisterConditions takes nothing returns boolean
    return ((GetUnitTypeId(GetTriggerUnit()) == 'H002'))
endfunction
function Trig_RegisterActions takes nothing returns nothing
    call RegisterDouble6Package(GetTriggerUnit())
    call AddRealMan(GetTriggerUnit())
    call UnitAddAbility( GetTriggerUnit(), 'A00B' )
    call UnitRemoveAbility( GetTriggerUnit(), 'A00B' )
endfunction
//===========================================================================
function InitTrig_Register takes nothing returns nothing
    set gg_trg_Register = CreateTrigger()
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_Register, GetPlayableMapRect() )
    call TriggerAddCondition(gg_trg_Register, Condition(function Trig_RegisterConditions))
    call TriggerAddAction(gg_trg_Register, function Trig_RegisterActions)
endfunction
//===========================================================================
// Trigger: RegisterFly
//===========================================================================
function Trig_RegisterFlyActions takes nothing returns nothing
    call YDWEFlyEnable( GetTriggerUnit() )
endfunction
//===========================================================================
function InitTrig_RegisterFly takes nothing returns nothing
    set gg_trg_RegisterFly = CreateTrigger()
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_RegisterFly, GetPlayableMapRect() )
    call TriggerAddAction(gg_trg_RegisterFly, function Trig_RegisterFlyActions)
endfunction
//===========================================================================
// Trigger: FireRegion
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: SpeedUp
//===========================================================================
//TESH.scrollpos=82
//TESH.alwaysfold=0
function Trig_SpeedUpActions takes nothing returns nothing
    if IsHero(GetTriggerUnit()) then
        if not EquipmentData[GetTriggerUnit()].heroData.speedup and GetUnitFlyHeight(GetTriggerUnit()) < 1 then
            call IssueImmediateOrder( GetTriggerUnit(), "stop" )
            call Push(GetTriggerUnit(), 180*bj_DEGTORAD, 5, 0, 30)
            call SpeedStateBuffer.create(GetTriggerUnit(), 30).start()
            call BoundUnitEffectStruct.create(GetTriggerUnit(), 30, 'e001', 90, "stand", 70).start()
        endif
    endif
endfunction
function SpeedDown takes nothing returns nothing
    if IsHero(GetTriggerUnit()) then
        if not EquipmentData[GetTriggerUnit()].heroData.speedup and GetUnitFlyHeight(GetTriggerUnit()) < 1 then
            call IssueImmediateOrder( GetTriggerUnit(), "stop" )
            call Push(GetTriggerUnit(), 270*bj_DEGTORAD, 5, 0, 30)
            call SpeedStateBuffer.create(GetTriggerUnit(), 30).start()
            call BoundUnitEffectStruct.create(GetTriggerUnit(), 30, 'e001', 180, "stand", 70).start()
        endif
    endif
endfunction
function SpeedUp takes nothing returns nothing
    if IsHero(GetTriggerUnit()) then
        if not EquipmentData[GetTriggerUnit()].heroData.speedup and GetUnitFlyHeight(GetTriggerUnit()) < 1 then
            call IssueImmediateOrder( GetTriggerUnit(), "stop" )
            call Push(GetTriggerUnit(), 90*bj_DEGTORAD, 5, 0, 30)
            call SpeedStateBuffer.create(GetTriggerUnit(), 30).start()
            call BoundUnitEffectStruct.create(GetTriggerUnit(), 30, 'e001', 0, "stand", 70).start()
        endif
    endif
endfunction
function SpeedRight takes nothing returns nothing
    if IsHero(GetTriggerUnit()) then
        if not EquipmentData[GetTriggerUnit()].heroData.speedup and GetUnitFlyHeight(GetTriggerUnit()) < 1 then
            call IssueImmediateOrder( GetTriggerUnit(), "stop" )
            call Push(GetTriggerUnit(), 0*bj_DEGTORAD, 5, 0, 30)
            call SpeedStateBuffer.create(GetTriggerUnit(), 30).start()
            call BoundUnitEffectStruct.create(GetTriggerUnit(), 30, 'e001', -90, "stand", 70).start()
        endif
    endif
endfunction
function Stage2Jump1 takes nothing returns nothing
    if IsHero(GetTriggerUnit()) then
        if not EquipmentData[GetTriggerUnit()].heroData.speedup and GetUnitFlyHeight(GetTriggerUnit()) < 1 then
            call IssueImmediateOrder( GetTriggerUnit(), "stop" )
            call Push(GetTriggerUnit(), 90*bj_DEGTORAD, 160, 70, 1)
            call SpeedStateBuffer.create(GetTriggerUnit(), 30).start()
            call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl", GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit())))
        endif
    endif
endfunction
function JumpRefresh takes nothing returns nothing
    if IsHero(GetTriggerUnit()) then
        if not EquipmentData[GetTriggerUnit()].heroData.jump_refresh then
            if refresh_tip[GetPlayerId(GetOwningPlayer(GetTriggerUnit()))] == false then
                call DisplayInfo(GetOwningPlayer(GetTriggerUnit()), "钃濊壊绗︽枃鍙互鍒锋柊璺宠穬鎶€鑳?)
                set refresh_tip[GetPlayerId(GetOwningPlayer(GetTriggerUnit()))] = true
            endif
            call UnitRemoveAbility(GetTriggerUnit(), 'A027')
            call UnitAddAbility(GetTriggerUnit(), 'A027')
            call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Undead\\ReplenishMana\\ReplenishManaCasterOverhead.mdl", GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit())))
            call JumpRefreshStateBuffer.create(GetTriggerUnit(), 100).start()
        endif
    endif
endfunction
//===========================================================================
function InitTrig_SpeedUp takes nothing returns nothing
    local trigger trg_stage2_jump1 = CreateTrigger()
    local trigger trg_jump_refresh = CreateTrigger()
    local trigger trg_speed_down = CreateTrigger()
    local trigger trg_speed_up = CreateTrigger()
    local trigger trg_speed_right = CreateTrigger()
    set gg_trg_SpeedUp = CreateTrigger()
    //left
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stag1_speed1 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stag1_speed2 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stag1_speed3 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stage2_speed3 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stage3_speedleft )
    call TriggerAddAction(gg_trg_SpeedUp, function Trig_SpeedUpActions)
    //up
    call YDWETriggerRegisterEnterRectSimpleNull( trg_speed_up, gg_rct_stage2_speed1 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stage3_speedup )
    call TriggerAddAction(trg_speed_up, function SpeedUp)
    //down
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stage3_speeddown )
    call TriggerAddAction(trg_speed_down, function SpeedDown)
    //right
    call YDWETriggerRegisterEnterRectSimpleNull( trg_speed_right, gg_rct_stage2_speed2 )
    call YDWETriggerRegisterEnterRectSimpleNull( trg_speed_right, gg_rct_stage2_speed4 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stage3_speedright )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stage3_sr1 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stage3_sr2 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stage3_sr3 )
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_SpeedUp, gg_rct_stage3_sr4 )
    call TriggerAddAction(trg_speed_right, function SpeedRight)
    //stage2
    call YDWETriggerRegisterEnterRectSimpleNull( trg_stage2_jump1, gg_rct_stage2_jump1 )
    call TriggerAddAction(trg_stage2_jump1, function Stage2Jump1)
    //jump refresh
    call YDWETriggerRegisterEnterRectSimpleNull( trg_jump_refresh, gg_rct_stage2_refresh1 )
    call YDWETriggerRegisterEnterRectSimpleNull( trg_jump_refresh, gg_rct_stage2_refresh2 )
    call YDWETriggerRegisterEnterRectSimpleNull( trg_jump_refresh, gg_rct_stage2_refresh3 )
    call YDWETriggerRegisterEnterRectSimpleNull( trg_jump_refresh, gg_rct_stage2_refresh4 )
    call YDWETriggerRegisterEnterRectSimpleNull( trg_jump_refresh, gg_rct_stage2_refresh5 )
    call YDWETriggerRegisterEnterRectSimpleNull( trg_jump_refresh, gg_rct_stage2_refresh6 )
    call YDWETriggerRegisterEnterRectSimpleNull( trg_jump_refresh, gg_rct_stage2_refresh7 )
    call YDWETriggerRegisterEnterRectSimpleNull( trg_jump_refresh, gg_rct_stage2_refresh8 )
    call YDWETriggerRegisterEnterRectSimpleNull( trg_jump_refresh, gg_rct_stage2_refresh9 )
    call TriggerAddAction(trg_jump_refresh, function JumpRefresh)
endfunction
//===========================================================================
// Trigger: SummonUtil
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Revive
//
// function Revive takes nothing returns nothing
//     local unit u
//     if GetSpellAbilityId() == revive then
//         set u=GetTriggerUnit()
//         call UnitRemoveAbility(u, 'Avul')
//         call UnitRemoveAbility(u, revive)
//         call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl", GetUnitX(u), GetUnitY(u)))
//         call RemoveLayDowmState(u)
//     endif
//     set u=null
// endfunction
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ManaChange
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_ManaChangeActions takes nothing returns nothing
    call UnitAddAbility(GetTriggerUnit(), 'Abun')
endfunction
//===========================================================================
function InitTrig_ManaChange takes nothing returns nothing
    set gg_trg_ManaChange = CreateTrigger()
    call TriggerAddAction(gg_trg_ManaChange, function Trig_ManaChangeActions)
endfunction
//===========================================================================
// Trigger: ManaGrow
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_ManaGrowActions takes nothing returns nothing
    call UnitRemoveAbility(GetTriggerUnit(), 'Abun')
endfunction
//===========================================================================
function InitTrig_ManaGrow takes nothing returns nothing
    set gg_trg_ManaGrow = CreateTrigger()
    call TriggerAddAction(gg_trg_ManaGrow, function Trig_ManaGrowActions)
endfunction
//===========================================================================
// Trigger: TechUnit
//===========================================================================
//TESH.scrollpos=6
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Effect
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: CameraAdjust
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_CameraAdjustConditions takes nothing returns boolean
    local integer i = GetPlayerId(GetTriggerPlayer())
    set camera[i] = ModuloInteger(camera[i] + 1, 5)
    call SetCameraFieldForPlayer(GetTriggerPlayer(), CAMERA_FIELD_TARGET_DISTANCE, 2000 + 250 * camera[i], 0.50)
    return false
endfunction
//===========================================================================
function InitTrig_CameraAdjust takes nothing returns nothing
    set gg_trg_CameraAdjust = CreateTrigger()
    call TriggerRegisterPlayerKeyEventBJ( gg_trg_CameraAdjust, Player(0), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP )
    call TriggerRegisterPlayerKeyEventBJ( gg_trg_CameraAdjust, Player(1), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP )
    call TriggerRegisterPlayerKeyEventBJ( gg_trg_CameraAdjust, Player(2), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP )
    call TriggerAddCondition(gg_trg_CameraAdjust, Condition(function Trig_CameraAdjustConditions))
endfunction
//===========================================================================
// Trigger: FogControl
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
// Trigger: CameraLock
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Movie
//===========================================================================
//TESH.scrollpos=53
//TESH.alwaysfold=0
//===========================================================================
// Trigger: GV
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: LearnAbility
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_LearnAbilityConditions takes nothing returns boolean
    if GetLearnedSkill() == 'A00O' then
        set Material[GetTriggerUnit()].kill_hp = Material[GetTriggerUnit()].kill_hp + 1
        set Material[GetTriggerUnit()].anti_horro = Material[GetTriggerUnit()].anti_horro + 0.1
    elseif GetLearnedSkill() == 'A00M' then
        set EquipmentData[GetTriggerUnit()].heroData.bullet_buf = EquipmentData[GetTriggerUnit()].heroData.bullet_buf + 0.1
        set EquipmentData[GetTriggerUnit()].heroData.shoot_energy_reg = EquipmentData[GetTriggerUnit()].heroData.shoot_energy_reg + 1
    elseif GetLearnedSkill() == 'A00P' then
        call SetPlayerState(GetOwningPlayer(GetTriggerUnit()), PLAYER_STATE_RESOURCE_LUMBER, GetPlayerState(GetOwningPlayer(GetTriggerUnit()), PLAYER_STATE_RESOURCE_LUMBER) + 2)
        set EquipmentData[GetTriggerUnit()].heroData.gamble_buf = EquipmentData[GetTriggerUnit()].heroData.gamble_buf + 0.1
    endif
    return false
endfunction
//===========================================================================
function InitTrig_LearnAbility takes nothing returns nothing
    set gg_trg_LearnAbility = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_LearnAbility, EVENT_PLAYER_HERO_SKILL )
    call TriggerAddCondition(gg_trg_LearnAbility, Condition(function Trig_LearnAbilityConditions))
endfunction
//===========================================================================
// Trigger: TriggerKillHpBuff
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TriggerKillHpBuffActions takes nothing returns nothing
    call SetUnitState( GetKillingUnitBJ(), UNIT_STATE_LIFE, GetUnitState(GetKillingUnitBJ(),UNIT_STATE_LIFE) + Material[GetKillingUnitBJ()].kill_hp )
endfunction
//===========================================================================
function InitTrig_TriggerKillHpBuff takes nothing returns nothing
    set gg_trg_TriggerKillHpBuff = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_TriggerKillHpBuff, EVENT_PLAYER_UNIT_DEATH )
    call TriggerAddAction(gg_trg_TriggerKillHpBuff, function Trig_TriggerKillHpBuffActions)
endfunction
//===========================================================================
// Trigger: TriggerHorro
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TriggerHorroConditions takes nothing returns boolean
    if false and GetEventDamage() > 2 and IsUnitEnemy(GetEventDamageSource(), GetOwningPlayer(GetTriggerUnit())) and GetRandomReal(0,1) <= RMaxBJ(Material[GetEventDamageSource()].horro_dmg - Material[GetTriggerUnit()].anti_horro, 0) then
        call ApplyHorro(GetEventDamageSource(), GetTriggerUnit(), 5)
    endif
    return false
endfunction
//===========================================================================
function InitTrig_TriggerHorro takes nothing returns nothing
    set gg_trg_TriggerHorro = CreateTrigger()
    call YDWESyStemAnyUnitDamagedRegistTrigger( gg_trg_TriggerHorro )
    call TriggerAddCondition(gg_trg_TriggerHorro, Condition(function Trig_TriggerHorroConditions))
endfunction
//===========================================================================
// Trigger: HorrorOrderFilter
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_HorrorOrderFilterConditions takes nothing returns boolean
    if Material[GetTriggerUnit()].horro and GetIssuedOrderId() != OI_MOVE then
        call HorrorMove(GetTriggerUnit())
    endif
    return false
endfunction
//===========================================================================
function InitTrig_HorrorOrderFilter takes nothing returns nothing
    set gg_trg_HorrorOrderFilter = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_HorrorOrderFilter, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER )
    call TriggerRegisterAnyUnitEventBJ( gg_trg_HorrorOrderFilter, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER )
    call TriggerRegisterAnyUnitEventBJ( gg_trg_HorrorOrderFilter, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER )
    call TriggerAddCondition(gg_trg_HorrorOrderFilter, Condition(function Trig_HorrorOrderFilterConditions))
endfunction
//===========================================================================
// Trigger: HorrorOrder
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: OrderId
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ShootSpeed
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Radiation
//
// UnitHasBuffBJ(GetTriggerUnit(), 'Bcor')
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ArrayList
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: TechLevelUp
//
// //! runtextmacro InitTechData("tKMANA", "閫€榄斿垉", "TT_MAGIC_HUNTER", "0","1","0")
// //! runtextmacro InitTechData("tSTRONG", "浣撹川澧炲己", "TT_GENERAL", "0","1","0")
// //! runtextmacro InitTechData("tDOGE", "闂伩", "TT_GENERAL", "0","1","0")
// //! runtextmacro InitTechData("tSPEED_SHOOT", "鎬ラ€熷皠鍑?, "TT_GENERAL", "0","1","0")
// //! runtextmacro InitTechData("tAIM_SHOOT", "绮惧噯灏勫嚮", "TT_GENERAL", "0","1","0")
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TechLevelUpConditions takes nothing returns boolean
    local integer ai = GetSpellAbilityId()
    local integer bp = 0
    local unit u
    local integer lv
    local integer p
    local player owner
    local integer pid
    if (ai >= 'A00Q' and ai <= 'A013') or ai == 'A004' then
        set owner = GetOwningPlayer(GetTriggerUnit())
        set pid = GetPlayerId(owner)
        set u = techs[pid]
        set lv = GetUnitAbilityLevel(u, ai)
        set bp = LoadInteger(tdht,ai,tdht_base_point)
        if lv >= 1 and lv <= 2 then
            set bp = bp + 1
        elseif lv >= 3 and lv <= 4 then
            set bp = bp + 2
        elseif lv >= 5 and lv <= 6 then
            set bp = bp + 3
        else
            return true
        endif
        set p = GetPlayerState(owner, PLAYER_STATE_RESOURCE_FOOD_USED)
        if p >= bp then
            call DisplayInfo(owner, "鎶€鑳藉崌绾ф垚鍔?)
            call SetPlayerStateBJ( owner, PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(owner, PLAYER_STATE_RESOURCE_FOOD_USED) - bp)
            call IncUnitAbilityLevel( techs[pid], ai )
            call DispatchTechLevelUp(ai, lv + 1, pid)
        else
            call DisplayInfo(owner, "绉戞妧鐐逛笉瓒筹紝闇€瑕?" + I2S(bp))
        endif
    endif
    set u = null
    return true
endfunction
//===========================================================================
function InitTrig_TechLevelUp takes nothing returns nothing
    set gg_trg_TechLevelUp = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_TechLevelUp, EVENT_PLAYER_UNIT_SPELL_EFFECT )
    call TriggerAddCondition(gg_trg_TechLevelUp, Condition(function Trig_TechLevelUpConditions))
endfunction
//===========================================================================
// Trigger: TechData
//
// struct TechTree
//     integer size
//     integer array ids[64]
//     
//     static method create takes nothing returns TechTree
//         local TechTree m=TechTree.allocate()
//         set m.size = 0
//         return m
//     endmethod
//     
//     method addTech takes integer id returns nothing
//         set ids[size] = id
//         set size = size + 1
//     endmethod
// endstruct
//===========================================================================
//TESH.scrollpos=22
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Transform
//
// //! textmacro QuickItemFeatureData takes ID, IDX, NAME, MAXLV, WOOD, DESC
//     call SaveStr(ifht$IDX$,$ID$ - 'I000',ifht_name,"$NAME$")
//     call SaveReal(ifht$IDX$,$ID$ - 'I000',ifht_origin,0)
//     call SaveReal(ifht$IDX$,$ID$ - 'I000',ifht_step,1)
//     call SaveInteger(ifht$IDX$,$ID$ - 'I000',ifht_lv,0)
//     call SaveInteger(ifht$IDX$,$ID$ - 'I000',ifht_max_lv,$MAXLV$)
//     call SaveInteger(ifht$IDX$,$ID$ - 'I000',ifht_gold,0)
//     call SaveInteger(ifht$IDX$,$ID$ - 'I000',ifht_wood,$WOOD$)
//     call SaveStr(ifht$IDX$,$ID$ - 'I000',ifht_desc,"$DESC$")
// //! endtextmacro
// //! runtextmacro InitItemFeatureData("iSPEED", "1", "鎺ㄨ繘鍔?, "3","1","0","5","100","0")
//===========================================================================
//TESH.scrollpos=41
//TESH.alwaysfold=0
//===========================================================================
// Trigger: DialogSystem
//
//             exitwhen id > 0 or i <= 0
//             set i = i - 1
//             set r = GetRandomInt(1, size)
//             
//             //rand tech tree choose
//             set j = 0
//             loop
//                 exitwhen EquipmentData[hero].heroData.tech_counter.cnt[j] >= r or j >= TT_COUNT
//                 set r = r - EquipmentData[hero].heroData.tech_counter.cnt[j]
//                 set j = j + 1
//             endloop
//     method button_clicked takes button b returns nothing
//         call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED) + 2)
//         call DisplayText(p, "鑾峰緱涓ょ偣绉戞妧鐐?)
//         set EquipmentData[heros[GetPlayerId(p)]].heroData.up_point = EquipmentData[heros[GetPlayerId(p)]].heroData.up_point - 1
//     endmethod
//     
//     method init takes nothing returns nothing
//         local button b
//         local string s
//         set s = "绉戞妧鐐?+ 2"
//         set b = DialogAddButton(d, s ,0)
//         set b = null
//     endmethod
// //! textmacro InitTechData takes ID, NAME, CAT, TECH_NEED, GAME_LV_NEED
//     call SaveStr(tdht,$ID$,tdht_name,"$NAME$")
//     call SaveInteger(tdht,$ID$,tdht_cat,$CAT$)
//     call SaveInteger(tdht,$ID$,tdht_tech_need,$TECH_NEED$)
//     call SaveInteger(tdht,$ID$,tdht_game_lv_need,$GAME_LV_NEED$)
//     call TECH_TREES[$CAT$].addItem($ID$)
//     set TECH_TREE_COUNT[$CAT$] = TECH_TREE_COUNT[$CAT$] + 1
//     set TECH_COUNT = TECH_COUNT + 1
// //! endtextmacro
// //! runtextmacro InitTechData("tKMANA", "閫€榄斿垉", "TT_BLADE", "0","1")
//         
//         set k = 0
//         loop
//             exitwhen k > TT_COUNT - 1
//             set s = s + I2S(randtree[k])
//             set k = k + 1
//         endloop
//         //call BJDebugMsg("rand tree " + s)
//     method display takes nothing returns nothing
//         call init()
//         call BJDebugMsg("ddd")
//         call DialogDisplay(p,d,true)
//     endmethod
//===========================================================================
//TESH.scrollpos=168
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Buffer
//===========================================================================
//TESH.scrollpos=143
//TESH.alwaysfold=0
//===========================================================================
// Trigger: TransportBuffer
//
// AddLightningEx( "CLPB", false, GetUnitX(source),GetUnitY(source),getUnitHeight(source), GetUnitX(u), GetUnitY(u),getUnitHeight(u) )
// MoveLightningEx( l, false,  GetUnitX(source),GetUnitY(source),getUnitHeight(source), GetUnitX(u), GetUnitY(u),getUnitHeight(u))
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: SpeedStateBuffer
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct SpeedStateBuffer extends DefaultBufferStruct
    method addBuffer takes nothing returns nothing
        set EquipmentData[u].heroData.speedup = true
    endmethod
    
    method removeBuffer takes nothing returns nothing
        set EquipmentData[u].heroData.speedup = false
    endmethod
    
endstruct
struct JumpRefreshStateBuffer extends DefaultBufferStruct
    method addBuffer takes nothing returns nothing
        set EquipmentData[u].heroData.jump_refresh = true
    endmethod
    
    method removeBuffer takes nothing returns nothing
        set EquipmentData[u].heroData.jump_refresh = false
    endmethod
    
endstruct
//===========================================================================
// Trigger: NetBuffer
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct NetBuffer extends DefaultBufferStruct
    method addBuffer takes nothing returns nothing
        call GroupAddUnit(netgroup, u)
    endmethod
    
    method removeBuffer takes nothing returns nothing
        call GroupRemoveUnit(netgroup, u)
    endmethod
    
endstruct
//===========================================================================
// Trigger: ShootBostBuffer
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
struct ShootBostBuffer extends DefaultBufferStruct
    
    private integer inc
    
    private effect e = null
    method addBuffer takes nothing returns nothing
        call SetUnitAbilityLevel(u, SHOOT_SPEED, GetUnitAbilityLevel(u, SHOOT_SPEED) + inc)
        call BJDebugMsg(I2S(GetUnitAbilityLevel(u, SHOOT_SPEED)))
        set e = AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\TrueshotAura\\TrueshotAura.mdl",this.u,"origin")
    endmethod
    
    method action takes nothing returns nothing
    endmethod
    
    method removeBuffer takes nothing returns nothing
        call SetUnitAbilityLevel(u, SHOOT_SPEED, GetUnitAbilityLevel(u, SHOOT_SPEED) - inc)
        //call BJDebugMsg(I2S(GetUnitAbilityLevel(u, SHOOT_SPEED)))
        call DestroyEffect(e)
        set e = null
    endmethod
    
    static method create takes unit u, integer count, integer inc returns ShootBostBuffer
        local ShootBostBuffer m = ShootBostBuffer.allocate(u, count)
        set m.inc = inc
        return m
    endmethod
    
endstruct
//===========================================================================
// Trigger: SpeedColBuffer
//===========================================================================
//TESH.scrollpos=5
//TESH.alwaysfold=0
struct SpeedColBuffer extends DefaultBufferStruct
    private effect e
    
    integer lv
    method addBuffer takes nothing returns nothing
        set Material[u].coldmg = Material[u].coldmg + 50 + (10*lv)
        set Material[u].colris = Material[u].colris + 1
        set Material[u].colf = 1
        //call BJDebugMsg("addBuffer coldmg " + R2S(Material[u].coldmg))
        //call BJDebugMsg("addBuffer colris " + R2S(Material[u].colris))
        //call BJDebugMsg("addBuffer colf " + R2S(Material[u].colf))
        //set e = AddSpecialEffectTarget("Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile.mdl",this.u,"origin")
    endmethod
    
    method action takes nothing returns nothing
    endmethod
    
    method removeBuffer takes nothing returns nothing
        set Material[u].coldmg = Material[u].coldmg - 50 - (10*lv)
        set Material[u].colris = Material[u].colris - 1
        set Material[u].colf = 0
        //call DestroyEffect(e)
        set e = null
        //call BJDebugMsg("addBuffer coldmg " +R2S(Material[u].coldmg))
        //call BJDebugMsg("removeBuffer colris " +R2S(Material[u].colris))
        //call BJDebugMsg("removeBuffer colf " +R2S(Material[u].colf))
    endmethod
    static method create takes unit u, integer count, integer lv returns SpeedColBuffer
        local SpeedColBuffer m = SpeedColBuffer.allocate(u, count)
        set m.lv = lv
        return m
    endmethod
endstruct//===========================================================================
// Trigger: BurnBuffer
//
// //! runtextmacro BuffType("Burn")
//     //! runtextmacro SetBuffName("鐕冪儳")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶅彈鍒扮伀鐒扮噧鐑х殑鎸佺画浼ゅ")
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNFire.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     
//     private real dam
//     
//     private unit source
//     
//     private method periodic takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         if ModuloInteger(Tick, 10) == 0 then
//             call FireDamage(this.source, this.unit, this.dam)
//         endif
//     endmethod
//     
//     implement T32x
//     
//     method setDamage takes real dam, unit source returns nothing
//         set this.dam = dam
//         set this.source = source
//     endmethod
//     
//     method onApply takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         set this.e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedDamage.mdl",this.unit,"origin")
//         set Material[this.unit].burnlv = burnlv + 1
//         call this.startPeriodic()
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         set Material[this.unit].burnlv = Material[this.unit].burnlv - 1
//         call this.stopPeriodic()
//         call DestroyEffect(this.e)
//         set e = null
//         set source = null
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=11
//TESH.alwaysfold=0
struct BurnBuffer extends DefaultBufferStruct
    
    private real dam
    
    private unit source
    
    private effect e
    method addBuffer takes nothing returns nothing
        local integer burnlv = Material[u].burnlv
        set Material[u].burnlv = burnlv + 1
        set e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedDamage.mdl",this.u,"origin")
    endmethod
    
    method action takes nothing returns nothing
        if ModuloInteger(count, 25) == 0 then
            call FireDamage(this.source, u, this.dam)
        endif
    endmethod
    
    method removeBuffer takes nothing returns nothing
        set Material[u].burnlv = Material[u].burnlv - 1
        set source = null
        call DestroyEffect(e)
        set e = null
    endmethod
    
    static method create takes unit u, integer count, unit source, real dam returns BurnBuffer
        local BurnBuffer m = BurnBuffer.allocate(u, count)
        set m.source = source
        set m.dam = dam
        return m
    endmethod
    
endstruct
//===========================================================================
// Trigger: HorroBuffer
//
// //! runtextmacro BuffType("Burn")
//     //! runtextmacro SetBuffName("鐕冪儳")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶅彈鍒扮伀鐒扮噧鐑х殑鎸佺画浼ゅ")
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNFire.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     
//     private real dam
//     
//     private unit source
//     
//     private method periodic takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         if ModuloInteger(Tick, 10) == 0 then
//             call FireDamage(this.source, this.unit, this.dam)
//         endif
//     endmethod
//     
//     implement T32x
//     
//     method setDamage takes real dam, unit source returns nothing
//         set this.dam = dam
//         set this.source = source
//     endmethod
//     
//     method onApply takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         set this.e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedDamage.mdl",this.unit,"origin")
//         set Material[this.unit].burnlv = burnlv + 1
//         call this.startPeriodic()
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         set Material[this.unit].burnlv = Material[this.unit].burnlv - 1
//         call this.stopPeriodic()
//         call DestroyEffect(this.e)
//         set e = null
//         set source = null
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct HorroBuffer extends DefaultBufferStruct
    
    private unit source
    
    private effect e
    method addBuffer takes nothing returns nothing
        set Material[u].horro = true
        set e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdl",this.u,"origin")
        call HorrorMove(this.u)
        call UnitAddAbility(u, aBAN_ATTACK)
        call DisableAllAbi(u)
    endmethod
    
    method action takes nothing returns nothing
        if ModuloInteger(count, 100) == 0 then
            call HorrorMove(this.u)
        endif
    endmethod
    
    method removeBuffer takes nothing returns nothing
        set Material[u].horro = false
        set source = null
        call DestroyEffect(e)
        call UnitRemoveAbility(u, aBAN_ATTACK)
        call EnableAllAbi(u)
        set e = null
    endmethod
    
    static method create takes unit u, unit source, integer count returns HorroBuffer
        local HorroBuffer m = HorroBuffer.allocate(u, count)
        set m.source = source
        return m
    endmethod
    
endstruct
//===========================================================================
// Trigger: FloatBuffer
//===========================================================================
//TESH.scrollpos=6
//TESH.alwaysfold=0
struct FloatBuffer extends DefaultBufferStruct
    
    private boolean f
    
    private effect e
    method addBuffer takes nothing returns nothing
    endmethod
    
    method action takes nothing returns nothing
        if not f and Velocity[u].v.z < 0 then
            set Material[u].g = 0
            set e = AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\FaerieFire\\FaerieFireTarget.mdl",this.u,"overhead")
            call UnitAddAbility(u, 'A01Z')
            set f = true
        endif
    endmethod
    
    method removeBuffer takes nothing returns nothing
        if f then
            set Material[u].g = -2
            call DestroyEffect(e)
            call UnitRemoveAbility(u, 'A01Z')
            set e = null
        endif
    endmethod
    
    static method create takes unit u, integer dur returns FloatBuffer
        local FloatBuffer m = FloatBuffer.allocate(u, dur)
        set m.f = false
        return m
    endmethod
    
endstruct//===========================================================================
// Trigger: BleedBuffer
//
// //! runtextmacro BuffType("Bleed")
//     //! runtextmacro SetBuffName("娴佽")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶅彈鍒版祦琛€鐨勬寔缁激瀹?)
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNGhoulFrenzy.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     
//     private real dam
//     
//     private unit source
//     
//     private method periodic takes nothing returns nothing
//         if ModuloInteger(Tick, 10) == 0 then
//             call NormalDamage(this.source, this.unit, this.dam)
//         endif
//     endmethod
//     
//     implement T32x
//     
//     method setDamage takes real dam, unit source returns nothing
//         set this.dam = dam
//         set this.source = source
//     endmethod
//     
//     method onApply takes nothing returns nothing
//         local integer bleedlv = Material[this.unit].bleedlv
//         set this.e = AddSpecialEffectTarget("Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl",this.unit,"chest")
//         set Material[this.unit].bleedlv = bleedlv + 1
//         call this.startPeriodic()
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         set Material[this.unit].bleedlv = Material[this.unit].bleedlv - 1
//         call this.stopPeriodic()
//         call DestroyEffect(this.e)
//         set e = null
//         set source = null
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=12
//TESH.alwaysfold=0
struct BleedBuffer extends DefaultBufferStruct
    
    private real dam
    
    private unit source
    
    private effect e
    method addBuffer takes nothing returns nothing
        local integer bleedlv = Material[u].bleedlv 
        set Material[u].bleedlv = bleedlv + 1
        set e = AddSpecialEffectTarget("Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl",this.u,"chest")
    endmethod
    
    method action takes nothing returns nothing
        if ModuloInteger(count, 25) == 0 then
            call NormalDamage(this.source, u, this.dam)
        endif
    endmethod
    
    method removeBuffer takes nothing returns nothing
        set Material[u].bleedlv = Material[u].bleedlv - 1
        set source = null
        call DestroyEffect(e)
        set e = null
    endmethod
    
    static method create takes unit u, integer count, unit source, real dam returns BleedBuffer
        local BleedBuffer m = BleedBuffer.allocate(u, count)
        set m.source = source
        set m.dam = dam
        return m
    endmethod
    
endstruct
//===========================================================================
// Trigger: IceSlowBuffer
//
// //! runtextmacro BuffType("IceSlow")
//     //! runtextmacro SetBuffName("瀵掑啺")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("鐩爣鐨勭Щ鍔ㄩ€熷害鍜屾敾鍑婚€熷害閮介檷浣庝簡")
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNFrost.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     method onApply takes nothing returns nothing
//         call Status[this.unit].addStun()
//         //set this.e=AddSpecialEffectTarget("Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl",this.unit,"body")
//     endmethod
//     method onRemove takes nothing returns nothing
//         call Status[this.unit].removeStun()
//         call DestroyEffect(this.e)
//     endmethod
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct IceSlowBuffer extends DefaultBufferStruct
    private effect e
    method addBuffer takes nothing returns nothing
        call Status[this.u].addStun()
        set e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl",this.u,"origin")
    endmethod
    
    method removeBuffer takes nothing returns nothing
        call Status[this.u].removeStun()
        call DestroyEffect(e)
        set e = null
    endmethod
endstruct//===========================================================================
// Trigger: AutoAimBuffer
//
// //! runtextmacro BuffType("AutoAimBuff")
//     //! runtextmacro SetBuffName("杈呭姪灏勫嚮")
//     //! runtextmacro SetBuffAlignment("POSITIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶈兘澶熻繘琛岀簿纭皠鍑?)
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNScout.blp")
// //! runtextmacro BuffStruct()
//     method onApply takes nothing returns nothing
//         local real r = EquipmentData[.unit].heroData.shoot_rist
//         set EquipmentData[.unit].heroData.shoot_rist = r + 1
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         local real r = EquipmentData[.unit].heroData.shoot_rist
//         set EquipmentData[.unit].heroData.shoot_rist = r - 1
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct AutoAimBuffer extends DefaultBufferStruct
    method addBuffer takes nothing returns nothing
        local real r = EquipmentData[.u].heroData.shoot_rist
        set EquipmentData[.u].heroData.shoot_rist = r + 1
        call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\TrueshotAura\\TrueshotAura.mdl",this.u,"origin"))
    endmethod
    
    method removeBuffer takes nothing returns nothing
        local real r = EquipmentData[.u].heroData.shoot_rist
        set EquipmentData[.u].heroData.shoot_rist = r - 1
    endmethod
endstruct//===========================================================================
// Trigger: Debuff
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: BufferFunction
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Constants
//===========================================================================
//TESH.scrollpos=2
//TESH.alwaysfold=0
//===========================================================================
// Trigger: PlayerHero
//
// function PlayerHeroCondition takes nothing returns nothing
//     local unit tu = GetTriggerUnit()
//     local player owner = GetOwningPlayer(tu)
//     local integer pid = GetPlayerId(owner)
//     call BJDebugMsg("HERO EnTER")
//     if GetUnitTypeId(tu) == HERO then
//         
//         set heros[pid] = tu
//     endif
//     set tu = null
//     set owner = null
// endfunction
// function InitPlayerHero takes nothing returns nothing
// local trigger playerhero_t=CreateTrigger()
// local integer i = 0
// loop
//     exitwhen i >=4
//     set heros[i] = null
// endloop
// call TriggerRegisterEnterRectSimple( playerhero_t, GetPlayableMapRect() )
// call TriggerAddCondition(playerhero_t,function PlayerHeroCondition)
// set playerhero_t=null
// endfunction
// endlibrary
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: FocuseHero
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_FocuseHeroConditions takes nothing returns boolean
    return ((GetUnitTypeId(GetTriggerUnit()) == 'H004'))
endfunction
function Trig_FocuseHeroActions takes nothing returns nothing
    local player p = GetTriggerPlayer()
    local integer id = GetPlayerId(p)
    local location l = Location(GetUnitX(heros[id]),GetUnitY(heros[id]))
    call PanCameraToTimedLocForPlayer( p, l, 1 )
    call RemoveLocation(l)
    set l = null
    set p = null
endfunction
//===========================================================================
function InitTrig_FocuseHero takes nothing returns nothing
    set gg_trg_FocuseHero = CreateTrigger()
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(0), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(1), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(2), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(3), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(4), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(5), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(6), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(7), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(8), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(9), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(10), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(11), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(12), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(13), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(14), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(15), true )
    call TriggerAddCondition(gg_trg_FocuseHero, Condition(function Trig_FocuseHeroConditions))
    call TriggerAddAction(gg_trg_FocuseHero, function Trig_FocuseHeroActions)
endfunction
//===========================================================================
// Trigger: ItemData
//
// |cFFFFFDC4鍙戝皠绂诲瓙鍥㈢殑楂樼鎶€姝﹀櫒锛屽▉鍔涘法澶с€倈r|n|n|cFFFFFF66鈫撳彲寮哄寲椤光啌|r|n|n|cFFFF6666浼ゅ澧炲箙|r|n|cFF0099cc姣忕骇澧炲姞10%绂诲瓙鍥激瀹炽€倈r|n|cFFFF6666澶嶆暟绂诲瓙鍥r|n|cFF0099cc姣忕骇澧炲姞棰濆涓ら绂诲瓙鍥€?
// |cFFFFFDC4鑳藉浣跨敤鎰忓康鎺у埗鐨勯纰燂紝杈圭紭寮傚父閿嬪埄銆倈r|n|n|cFFFFFF66鈫撳彲寮哄寲椤光啌|r|n|n|cFFFF6666浼ゅ澧炲箙|r|n|cFF0099cc姣忕骇澧炲姞10%鍒囧壊浼ゅ銆倈r|n|cFFFF6666澶嶆暟椋炵|r|n|cFF0099cc鍙戝皠澶氭灇椋炵鑰屼笉鏄竴鏋氾紝姣忕骇澧炲姞涓ゆ灇銆倈r|n|cFFFF6666鑷垎椋炵|r|n|cFF0099cc鎺у埗椋炶涓殑椋炵鑷垎锛岄€犳垚宸ㄥぇ浼ゅ銆傜垎鐐镐激瀹抽殢绛夌骇鎻愬崌銆倈r|n|cFFFF6666椋炶缁埅|r|n|cFF0099cc寤堕暱椋炵椋炶鏃堕棿锛屾瘡绾у闀?绉掋€?
// //! runtextmacro InitWeaponTypeData("'I00Y'", "鐏姏鍘嬪埗", "'A01T'", "0","0","0","AB2")
//===========================================================================
//TESH.scrollpos=215
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemEquip
//===========================================================================
//TESH.scrollpos=31
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemType
//
//     integer GUN=4
//     integer HAND=1
//     integer ARMOR=2
//     integer SHOE=3
//     integer OTHER=5
//     integer LONGTERM=7
//     integer STATIC=6
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: UnitId
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: FakeMan
//===========================================================================
//TESH.scrollpos=30
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterDead
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ShootTarget
//
//  and GetIssuedOrderId() == OI_JUST_MOVE and UnitHasBuffBJ(GetTriggerUnit(), 'B006')
//===========================================================================
//TESH.scrollpos=51
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterTypeData
//===========================================================================
//TESH.scrollpos=8
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterBonus
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterTargetGroup
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: DeathEffect
//
// Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodGhoul.mdl
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_DeathEffectActions takes nothing returns nothing
    //call DestroyEffect( AddSpecialEffect("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodFootman.mdl", GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit())) )
    call DestroyEffect( AddSpecialEffect("Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodGhoul.mdl", GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit())) )
endfunction
//===========================================================================
function InitTrig_DeathEffect takes nothing returns nothing
    set gg_trg_DeathEffect = CreateTrigger()
    call TriggerRegisterPlayerUnitEventSimple( gg_trg_DeathEffect, Player(11), EVENT_PLAYER_UNIT_DEATH )
    call TriggerAddAction(gg_trg_DeathEffect, function Trig_DeathEffectActions)
endfunction
//===========================================================================
// Trigger: Difficulty
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: EffectString
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: SkillLearn
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: DoublePacket
//===========================================================================
//TESH.scrollpos=93
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Missle
//
//             if HasLiveEnemyUnitInRange(owner, 300) then
//                 //set this.active = true
//                 call BJDebugMsg("active")
//             endif
// function rangeExplodeDamage takes unit source ,real x ,real y ,real radius, real damage returns nothing
//===========================================================================
//TESH.scrollpos=474
//TESH.alwaysfold=0
// Trigger: MissleFactory
//===========================================================================
//TESH.scrollpos=18
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Gun
//===========================================================================
//TESH.scrollpos=41
//TESH.alwaysfold=0
        
        
        //===========================================================================
// Trigger: WallDeath
//
// Doodads\LordaeronSummer\Terrain\Barricade\Barricade0.mdl
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_WallDeathConditions takes nothing returns boolean
    if IsWall(GetTriggerUnit()) then
        call RemoveUnit(GetTriggerUnit())
        call DestroyEffect(AddSpecialEffect("Doodads\\LordaeronSummer\\Terrain\\LoardaeronRockChunks\\LoardaeronRockChunks1.mdl", GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit())))
    elseif IsWall2(GetTriggerUnit()) then
        call RemoveUnit(GetTriggerUnit())
        call DestroyEffect(AddSpecialEffect("Doodads\\LordaeronSummer\\Terrain\\Barricade\\Barricade0.mdl", GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit())))
    endif
    return false
endfunction
//===========================================================================
function InitTrig_WallDeath takes nothing returns nothing
    set gg_trg_WallDeath = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_WallDeath, EVENT_PLAYER_UNIT_DEATH )
    call TriggerAddCondition(gg_trg_WallDeath, Condition(function Trig_WallDeathConditions))
endfunction
//===========================================================================
// Trigger: Shooter
//
//     method shoot takes vector dir returns nothing
//         local real ec = getEnergyConsume()
//         local vector vdir
//         local integer lst = EquipmentData[owner].heroData.last_shoot_tick
//         local integer i = 1
//         local integer interval = R2I(I2R(getModuleTick()) * (1 - EquipmentData[owner].heroData.shoot_speed_buff))
//         if  Tick - lst >= interval then
//             loop
//                 exitwhen i > shootCount()
//                 set i = i + 1
//                 set vdir = getShootVector()
//                 if not EquipmentData[owner].heroData.reload and EquipmentData[owner].heroData.shoot_energy >= ec then
//                     set EquipmentData[owner].heroData.last_shoot_tick = Tick
//                     call energyConsume()
//                     call backForce(getShootDir())
//                     call subshoot(vdir)
//                 else
//                     if not EquipmentData[owner].heroData.reload then
//                         set EquipmentData[owner].heroData.reload = true
//                     endif
//                     call DisplayFloatText(GetUnitX(owner),GetUnitY(owner),"!",0.1)
//                 endif
//             endloop
//         endif
//     endmethod
//===========================================================================
//TESH.scrollpos=275
//TESH.alwaysfold=0
//===========================================================================
// Trigger: HeroData
//===========================================================================
//TESH.scrollpos=47
//TESH.alwaysfold=0
        
        
        //===========================================================================
// Trigger: EquipmentData
//
// function Strike takes nothing returns nothing
//     local timer t=GetExpiredTimer()
//     local integer tdec=GetHandleId(t)
//     local integer count=LoadInteger(ht, tdec, kmc)
//     local unit u=LoadUnitHandle(ht, tdec, kmu)
//     local unit tu
//     local real ux
//     local real uy
//     local real x
//     local real y
//     local real dir
//     if count > 100 and GetUnitAbilityLevel(u, ranger) > 0 and IsUnitAliveBJ(u) and GetUnitAbilityLevel(u, revive) == 0 then
//         set tu=GetFirstEnemyInRange(u , 300)
//         if not ( tu == null ) then
//             set ux=GetUnitX(u)
//             set uy=GetUnitY(u)
//             set dir=Atan2(GetUnitY(tu) - uy, GetUnitX(tu) - ux)
//             set x=ux + 100 * Cos(dir)
//             set y=uy + 100 * Sin(dir)
//             call RangeJiTui(GetOwningPlayer(u) , x , y , 200 , 8)
//             call CreateUnit(GetOwningPlayer(u), mid, x, y, dir)
//             call BloodyChaosDamage(u , x , y , dir , 200 , 100 , "Objects\\Spawnmodels\\Human\\HumanBlood\\BloodElfSpellThiefBlood.mdl")
//             set count=0
//         endif
//     endif
//     set count=count + 1
//     call SaveInteger(ht, tdec, kmc, count)
//     set u=null
//     set t=null
// endfunction
//===========================================================================
//TESH.scrollpos=80
//TESH.alwaysfold=0
    
//===========================================================================
// Trigger: HeroStatus
//
// function Trig_HeroStatusActions takes nothing returns nothing
//     call SetHeroStr( GetAttacker(), ( GetHeroAgi(null, false) + 1 ), true )
// endfunction
// //===========================================================================
// function InitTrig_HeroStatus takes nothing returns nothing
//     set gg_trg_HeroStatus = CreateTrigger()
// #ifdef DEBUG
//     call YDWESaveTriggerName(gg_trg_HeroStatus, "HeroStatus")
// #endif
//     call TriggerRegisterUnitEvent( gg_trg_HeroStatus, null, EVENT_UNIT_HERO_SKILL )
//     call TriggerAddAction(gg_trg_HeroStatus, function Trig_HeroStatusActions)
// endfunction
//===========================================================================
//TESH.scrollpos=8
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Velocity
//===========================================================================
//TESH.scrollpos=237
//TESH.alwaysfold=0
    
//===========================================================================
// Trigger: Material
//
// //! textmacro RegisterMaterial takes ID,CLAZZ,HARDNESS,BOUNCE,VOLUME,WEIGHT,AIRK,FKL,GOUND_ACTION
// //! runtextmacro RegisterMaterial("'u006'","MC_UNIT","10","0.2","150","10000","0.75","LV_ACTIVE","GROUND_BOUNCE")
//===========================================================================
//TESH.scrollpos=126
//TESH.alwaysfold=0
    
//===========================================================================
// Trigger: PhysicsSystem
//===========================================================================
//TESH.scrollpos=11
//TESH.alwaysfold=0
    //===========================================================================
// Trigger: bordercontrol
//===========================================================================
function Trig_bordercontrolActions takes nothing returns nothing
    call RemoveUnit( GetTriggerUnit() )
endfunction
//===========================================================================
function InitTrig_bordercontrol takes nothing returns nothing
    set gg_trg_bordercontrol = CreateTrigger()
    call YDWETriggerRegisterLeaveRectSimpleNull( gg_trg_bordercontrol, GetPlayableMapRect() )
    call TriggerAddAction(gg_trg_bordercontrol, function Trig_bordercontrolActions)
endfunction
//===========================================================================
// Trigger: TargetFilter
//
// IsLiveEnemyUnitOrDestroyableWall
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemInfo
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_fConditions takes nothing returns boolean
    return ((GetItemType(GetManipulatedItem()) == ITEM_TYPE_PERMANENT))
endfunction
function Trig_fActions takes nothing returns nothing
    local item itm = GetManipulatedItem()
    local unit tu = GetTriggerUnit()
    local ItemFeatureData fd = IndividualItemData[itm].featureData
    local ItemTypeData data = getItemTypeData(GetItemTypeId(itm))
    local string msg = "|cFFFF9900鈮?+data.name+"鈮畖r" + "\n===================\n"
//textmacro instance: AddFeatureData("1")
        if fd.f1.maxlv > 0 then
            set msg = msg + "|cFFFFFFCC"+fd.f1.name + " 绛夌骇: " + I2S(fd.f1.lv) + "|r\n"
            set msg = msg + "    |cFFCC99CC- " + fd.f1.desc + "|r\n"
        endif
//end of: AddFeatureData("1")
//textmacro instance: AddFeatureData("2")
        if fd.f2.maxlv > 0 then
            set msg = msg + "|cFFFFFFCC"+fd.f2.name + " 绛夌骇: " + I2S(fd.f2.lv) + "|r\n"
            set msg = msg + "    |cFFCC99CC- " + fd.f2.desc + "|r\n"
        endif
//end of: AddFeatureData("2")
//textmacro instance: AddFeatureData("3")
        if fd.f3.maxlv > 0 then
            set msg = msg + "|cFFFFFFCC"+fd.f3.name + " 绛夌骇: " + I2S(fd.f3.lv) + "|r\n"
            set msg = msg + "    |cFFCC99CC- " + fd.f3.desc + "|r\n"
        endif
//end of: AddFeatureData("3")
//textmacro instance: AddFeatureData("4")
        if fd.f4.maxlv > 0 then
            set msg = msg + "|cFFFFFFCC"+fd.f4.name + " 绛夌骇: " + I2S(fd.f4.lv) + "|r\n"
            set msg = msg + "    |cFFCC99CC- " + fd.f4.desc + "|r\n"
        endif
//end of: AddFeatureData("4")
//textmacro instance: AddFeatureData("5")
        if fd.f5.maxlv > 0 then
            set msg = msg + "|cFFFFFFCC"+fd.f5.name + " 绛夌骇: " + I2S(fd.f5.lv) + "|r\n"
            set msg = msg + "    |cFFCC99CC- " + fd.f5.desc + "|r\n"
        endif
//end of: AddFeatureData("5")
    set msg = msg + "===================\n"
    call DisplayText(GetOwningPlayer(tu),msg)
    set itm = null
    set tu = null
    call data.destroy()
endfunction
//===========================================================================
function InitTrig_ItemInfo takes nothing returns nothing
    set gg_trg_ItemInfo = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_ItemInfo, EVENT_PLAYER_UNIT_USE_ITEM )
    call TriggerAddCondition(gg_trg_ItemInfo, Condition(function Trig_fConditions))
    call TriggerAddAction(gg_trg_ItemInfo, function Trig_fActions)
endfunction
//===========================================================================
// Trigger: AIAttack
//===========================================================================
//TESH.scrollpos=14
//TESH.alwaysfold=0
// Trigger: BOSS1
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: AIStrategy
//===========================================================================
//TESH.scrollpos=21
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIGroup
//
// method addUnit takes unit u returns nothing
//     local IAIGroup cg=AIData[u].currentAIGroup
//     if cg!=0 then
//         call cg.removeUnit(u)
//         call BJDebugMsg("group change")
//     endif
//     set AIData[u].currentAIGroup=this
//     call GroupAddUnit(g,u)
//     //call GroupAddUnit(tg,u)d >= 2000 and d < 6000
// endmethod
// method addpg takes unit u returns nothing
//     local IAIGroup cg=AIData[u].currentAIGroup
//     if cg!=0 then
//         call cg.removeUnit(u)
//     endif
//     set AIData[u].currentAIGroup=this
//     call GroupAddUnit(pg,u)
//     call GroupAddUnit(tg,u)
// endmethod
// method removeUnit takes unit u returns nothing
//     if AIData[u].currentAIGroup == this then
//         set AIData[u].currentAIGroup = 0
//     endif
//     call GroupRemoveUnit(g,u)
//     call GroupRemoveUnit(pg, u)
//     call GroupRefresh(g)
//     call GroupRefresh(pg)
// endmethod
//  d >= 2000 and d < 6000 and
//===========================================================================
//TESH.scrollpos=172
//TESH.alwaysfold=0
    
    
//===========================================================================
// Trigger: AIData
//
// set gDefaultAIGroup=DefaultAIGroup.create()
// call gBoss1AIStrategy.create()
//===========================================================================
//TESH.scrollpos=13
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIDriver
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: DummyCaster
//===========================================================================
//TESH.scrollpos=67
//TESH.alwaysfold=0
//
//      ___  _   _  __  __  __  __ __  __
//     |   \| | | |/  |/  |/  |/  |\ \/ /
//     | |) | |_| | / | / | / | / | \  /
//     |___/\____/_/|__/|_|/|__/|_|_|_|__
//         /  _/ /_\ / __\_   _|  __|  _ //        |  |_ / _ \\__ \ | | |  __|  _ /
//         \___\_/ \_\___/ |_| |____|_|\_\         By Jesus4Lyf
//
//      What is DummyCaster?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          DummyCaster is designed to be the perfect dummy caster for dummy abilities.
//          There has been a lot of thought put into this unit type, and dummy casting
//          has evolved over the years of WC3 mapping. These days, best practise is that
//          damage is triggered, and the effects of an ability such as slow or stun
//          are applied through a global dummy caster (which is owned by Neutral Hostile).
//
//          A lot of thought has been put into this unit. It has no mana, because if
//          it had mana then it could potentially run out and suddenly fail without
//          an apparent reason. It has no movement speed or casting time, allowing it
//          to instantly cast. Hence, this library only exposes one thing. A "DUMMY"
//          unit constant (global variable).
//
//          You may provide this unit with a model by having a model imported into the
//          path "Dummy.mdx". The purpose of this is allowing the same unit type
//          to be created dynamically for special effect attachment.
//
//          The rawcode of the "Dummy Caster" type is 'dumy'.
//
//          Upon issueing the order to cast a spell using the DUMMY global, as long as
//          the spell is instant, the casting will occur before the next line of
//          JASS code is executed, meaning you can cast in a loop or a ForGroup, etc
//          without bugging or dynamically creating (or recycling) dummies.
//
//          The initialiser is in a struct because struct onInit methods are called
//          before library "initializers". This allows abilities to be added on the
//          constant DUMMY unit on map initialisation.
//
//          Spells that this dummy casts should have no mana cost, no cooldown, no
//          cast time and infinite range. They also must be able to be cast from a
//          Neutral Hostile unit to your target, meaning they must be castable on
//          enemies (if you must, you can change the owner of the dummy for the cast,
//          and then change it back if you need to have it target allied units and such).
//
//          Be sure to add your spell to the dummy before trying to cast it! :)
//          Beware of permenantly adding spells with conflicting order ids/strings.
//
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Create a new trigger object called DummyCaster, go to 'Edit -> Convert to
//          Custom Text', and replace everything that's there with this script.
//
//          Save the map, close it, reopen it, and then delete the "!" from the
//          FAR left side of the next line (so "external" will line up with this line):
//          external ObjectMerger w3u ushd dumy unam "Dummy Caster" uabi Aloc ucbs 0 ucpt 0 umvs 0 ushu "" umvh 0 umdl "Dummy.mdl" umpi 100000 umpm 100000 umpr 1000 ufoo 0
//
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Viikuna for demonstrating how to make dummy casters cast instantaneously.
//
//===========================================================================
// Trigger: Status
//
// Default melee game initialization for all players
//===========================================================================
//TESH.scrollpos=821
//TESH.alwaysfold=0
//
//      ___ _____ _ _____ _   _ ___ 
//     / __|_   _/_\_   _| | | / __|
//     \__ \ | |/ _ \| | | |_| \__ \    By Jesus4Lyf.
//     |___/ |_/_/ \_\_| \____/|___/          v 1.2.8
//
//      What is Status?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Status allows you to apply stuns, silences, disable attacks and much
//          more. Status effects based off dummy casted spells are applied 0.0
//          seconds after the "add" method is called. Status aims to commoditise
//          unit effects in WC3.
//
//      Restrictions
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Disarming spell immune units is not possible. Some status effects will
//          not apply to invulnerable units, namely those which are dummy casted.
//
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Create a new trigger object called Status, go to 'Edit -> Convert to
//          Custom Text', and replace everything that's there with this script.
//
//          Save the map, close it, reopen it, and then delete the "!" from the
//          FAR left side of the next lines (so "runtextmacro" will line up with this line):
//          runtextmacro Status__CreateAbilities()
//
//          Go to the object editor, and select abilities. Go to Special > Heroes,
//          and select Disarm (Both). Change Data - Attacks Prevented to Melee, Ranged.
//          For Disarm (Melee), change Attacks Prevented to Melee. For Disarm (Range),
//          change Attacks Prevented to Ranged. Object merger has a bug that does not
//          allow setting this field automatically.
//
//      Methods:
//     藟藟藟藟藟藟藟藟藟藟
//          Statuses (short list):
//              - Disable (addDisable, removeDisable, isDisabled)
//              - Stun (addStun, removeStun, isStunned)
//              - Silence (addSilence, removeSilence, isSilenced)
//              - Doom (addDoom, removeDoom, isDoomed)
//              - DisarmMelee (addDisarmMelee, removeDisarmMelee, isDisarmedMelee)
//              - DisarmRange (addDisarmRange, removeDisarmRange, isDisarmedRange)
//              - Disarm (addDisarm, removeDisarm, isDisarmed) // this is both Melee AND Ranged.
//              - Immobolise (addImmobolise, removeImmobolise, isImmobolised)
//              - Invisible (addInvisible, removeInvisible, isInvisible)
//              - Ghost (addGhost, removeGhost, isGhost)
//              - Invulnerable (addInvulnerable, removeInvulnerable, isInvulnerable)
//              - Immunity (addImmunity, removeImmunity, isImmune)
//              - Pause (addPause, removePause, isPaused)
//              - Hide (addHide, removeHide, isHidden)
//              - Unpath (addUnpath, removeUnpath, isUnpathed)
//              - Hex (addHex, removeHex, isHexed)
//              - Locust (addLocust, removeLocust, isLocust) // does not remove correctly for flying units, use with caution.
//              - NeverMiss (addNeverMiss, removeNeverMiss, isNeverMiss)
//              - AlwaysMiss (addAlwaysMiss, removeAlwaysMiss, isAlwaysMiss)
//              - Untouchable (addUntouchable, removeUntouchable, isUntouchable) // 100% evasion
//              - Banish (addBanish, removeBanish, isBanished)
//              - Phase (addPhase, removePhase, isPhased) // clashes with windwalk, interrupts current order
//              - ResistantSkin (addResistantSkin, removeResistantSkin, isResistantSkin)
//              - ReflectPiercing (addReflectPiercing, removeReflectPiercing, isReflectPiercing)
//
//          Bonuses (short list):
//              - ArmorBonus (modArmorBonus, getArmorBonus)
//              - DamageBonus (modDamageBonus, getDamageBonus)
//              - StrBonus (modStrBonus, getStrBonus)
//              - AgiBonus (modAgiBonus, getAgiBonus)
//              - IntBonus (modIntBonus, getIntBonus)
//              - AttackSpeedBonus (modAttackSpeedBonus, getAttackSpeedBonus)
//              - Health (modHealthBonus, getHealthBonus)
//              - Mana (modManaBonus, getManaBonus)'
//              - HealthRegen (modHealthRegenBonus, getHealthRegenBonus)
//              - HealthRegenPercent (modHealthRegenPercentBonus, getHealthRegenPercentBonus) // percent of max
//              - ManaRegen (modManaRegenBonus, getManaRegenBonus)
//              - ManaRegenPercent (modManaRegenPercentBonus, getManaRegenPercentBonus) // percent of max
//              - MoveSpeed (modMoveSpeedBonus, getMoveSpeedBonus)
//              - MoveSpeedPercent (modMoveSpeedPercentBonus, getMoveSpeedPercentBonus) // percent of current move speed (after normal bonuses).
//
//      How to Use:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Statuses:
//              Status[unit].add?()
//                  - Adds the status effect to the unit.
//                  - This does not add any animation.
//              Status[unit].remove?()
//                  - Removes the status effect added with .add?().
//                  - Will not actually remove it until all added instances are removed.
//              Status[unit].is?() --> boolean
//                  - Checks to see whether or not a unit has a status effect applied.
//
//          Bonuses:
//              Status[unit].mod?(amount)
//                  - Modifies the bonus by the amount given.
//                  - Use a negative value to reverse a bonus.
//                  - Supports giving negative of a bonus.
//              Status[unit].get?()
//                  - Gets the curret total amount for a given bonus.
//
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Weep: for suggesting that making the ability an ultimate hero ability
//            would allow it to stun magic immune units, and suggesting a simpler
//            target allowance for the ability.
//
//===========================================================================
// Trigger: Heal
//===========================================================================
//TESH.scrollpos=101
//TESH.alwaysfold=0
//////////////////////////////////////////////////////////////
//
//      @@   @@   @@@@@@    @@@    @    
//      @@   @@   @@       @   @   @
//      @@@@@@@   @@@@@   @ @@@ @  @
//      @@   @@   @@      @     @  @
//      @@   @@   @@@@@@  @     @  @@@@@@@@
//
//                by kingking
//
//           This version : v1.0.6
//
//  This library is used to simulate heal events.
//  
//  Functions provided :
//  Heal_RegisterEvent(trig)

//  Heal_UnregisterEvent(trig)

//  Heal_Block(real)

//  Heal_BlockAll()

//  Heal_EnableEvent(boolean)

//  Heal_GetSource() -> unit

//  Heal_GetTarget() -> unit

//  Heal_GetAmount() -> real

//  Heal_GetType() -> HealType

//  HealUnit(healer, target, amount, healtype)

//  
//  Default heal type :

//
//  Heal type creation :

//
//  Requires :


/////////////////////////////////////////////////////////////
// Trigger: ABC
//===========================================================================
//TESH.scrollpos=105
//TESH.alwaysfold=0
//==============================================================================
//  ABC -- STRUCT ATTACHMENT SYSTEM BY COHADAR -- v6.1
//==============================================================================
//==============================================================================
//  Quick function index:
//==============================================================================
//
//    ----------------------------------------------------------------------
//      Set Functions - these functions attach struct to a handle
//    ----------------------------------------------------------------------
//    SetTimerStructA(timer, struct)
//    SetTimerStructB(timer, struct)
//    SetTimerStructC(timer, struct)
//
//    SetTriggerStructA(trigger, struct)
//    SetTriggerStructB(trigger, struct)
//    SetTriggerStructC(trigger, struct)
//
//    SetDialogStructA(dialog, struct)
//    SetDialogStructB(dialog, struct)
//    SetDialogStructC(dialog, struct)
//
//    SetRegionStructA(region, struct)
//    SetRegionStructB(region, struct)
//    SetRegionStructC(region, struct)
//
//    ----------------------------------------------------------------------
//      Get Functions - these functions retrieve attached structs
//    ----------------------------------------------------------------------
//    GetTimerStructA(timer) -> struct
//    GetTimerStructB(timer) -> struct
//    GetTimerStructC(timer) -> struct
//
//    GetTriggerStructA(trigger) -> struct
//    GetTriggerStructB(trigger) -> struct
//    GetTriggerStructC(trigger) -> struct
//
//    GetDialogStructA(dialog) -> struct
//    GetDialogStructB(dialog) -> struct
//    GetDialogStructC(dialog) -> struct
//
//    GetRegionStructA(region) -> struct
//    GetRegionStructB(region) -> struct
//    GetRegionStructC(region) -> struct
//
//    ----------------------------------------------------------------------
//      Clear Functions - these functions clear and return attached value
//    ----------------------------------------------------------------------
//    ClearTimerStructA(timer) -> struct
//    ClearTimerStructB(timer) -> struct
//    ClearTimerStructC(timer) -> struct
//
//    ClearTriggerStructA(trigger) -> struct
//    ClearTriggerStructB(trigger) -> struct
//    ClearTriggerStructC(trigger) -> struct
//
//    ClearDialogStructA(dialog) -> struct
//    ClearDialogStructB(dialog) -> struct
//    ClearDialogStructC(dialog) -> struct
//
//    ClearRegionStructA(region) -> struct
//    ClearRegionStructB(region) -> struct
//    ClearRegionStructC(region) -> struct
//
//==============================================================================
//==============================================================================
//  DOCUMENTATION:
//==============================================================================
//
//  PURPOUSE OF ABC:
//       * Type safe handle attaching.
//      
//       * Currently supported handle types are timer, trigger, dialog and region
//
//  PROS: 
//       * ABC is faster than gamecache based systems.
//
//       * You can attach up to 3 structs on the same handle
//         
//       * System reports collision, and clearing of non-existent value.
//
//       * This system will work even if your map leaks
//         and will NOT slow down because of it.
//
//  CONS:
//       * you must manually clear the stored value - REMEMBER THIS RULE!!!
//         Don't forget to use Clear functions
//
//  DETAILS:
//       * You can use Get to check if struct is attached to handle
//         It will return 0 if it is not.
//
//       * ABC will not interfere with other attachment systems
//         You can freely use any other system alongside ABC
//
//       * For unit attaching I recommend using PUI
//
//  SPECIAL THANKS TO: 
//       * NagelBagel - for finding errors in versions 4.3 and 4.4
//       * Here-b-Trollz - for testing ABC and for making cool spells with it.
//       * Toadcop - for being pain in the ass and for pushing me to improve ABC.
//       * emjlr3 - for pointing out the need for non-generic trigger attachments
//       * PandaMine - I found a bug in ABC by examining his HSAS vs ABC test
//       * All those people out there who use and support my systems
//         Thank you guys.
//
//  HOW TO IMPORT:
//       * Just create a trigger named ABC
//       * convert it to text and replace the whole trigger text with this one
//
//==============================================================================
//==============================================================================
//  Macro function cores
//==============================================================================
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//==============================================================================
//==============================================================================
//  END OF ABC STRUCT ATTACHMENT SYSTEM
//==============================================================================//===========================================================================
// Trigger: AII
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
// Trigger: Table
//===========================================================================
//TESH.scrollpos=159
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Height
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AddEffectZ
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
// Trigger: Move
//===========================================================================
//TESH.scrollpos=22
//TESH.alwaysfold=0
// Trigger: Vector
//===========================================================================
//TESH.scrollpos=57
//TESH.alwaysfold=0
// Trigger: FloatText
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Text
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Direction
//===========================================================================
//TESH.scrollpos=6
//TESH.alwaysfold=0
//===========================================================================
// Trigger: SpellStruck
//===========================================================================
//TESH.scrollpos=52
//TESH.alwaysfold=0
//
//
//      Spell Struct
//          By Jesus4Lyf.
//       Version 1.0.7.
//
//      What is SpellStruct?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          SpellStruct is a system designed for the sake of rapid spell development.
//          It grants features which can be entirely encapsulated in a struct type per
//          ability. It handles event response creation, timer attachment, trigger
//          attachment, area of effect (AoE) enumeration, unit attachment, and all
//          spells made using it should be automatically MUI/leakless and rather efficient.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Simply create a new trigger object called SpellStruct, go to 'Edit -> Convert
//          to Custom Text', and replace everything that's there with this script.
//
//    _______________________
//    ||                   ||
//    || SpellStruct Usage ||
//    ||                   ||
//    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//      Writing a Simple SpellStruct:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - To use SpellStruct, write SpellStructs. These are structs which extend
//            SpellStruct, and implement SpellStruct.
//
//          - Everything is optional to implement/use, except setting thistype.abil='Axxx'
//            in static method onInit.
//
//          - Example:
//

//      Event Responses:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - The following is a list of event responses that come with SpellStructs.
//
//          - Event responses are stored on your struct as members.

//          - The above event response list may be used anywhere in your SpellStruct,
//            and at any time.
//
//          - You may implement methods which are called when the normal Warcraft III
//            spell events would fire. Some of the Warcraft III event responses are
//            broken for certain events, sometimes intermittently, but these are fixed
//            when using SpellStruct.
//            Also, usually in Warcraft III, these are implemented in a way that cycles
//            through all triggered abilities to see if the spell cast is the spell the
//            trigger is for. In SpellStruct, this is changed so that Warcraft III will
//            jump straight to the method for the spell that was cast.
//
//          - These methods, which are called when events fire, are non-static. This means
//            any members you add in your SpellStruct can be accessed from within the method.
//            This is achieved with unit attachment (internally).
//
//          - Example:
//

//      Disabling Auto-Destruction:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - SpellStructs are created just before the .onChannel event method is
//            called.
//
//          - By default, SpellStructs are automatically destroyed, and this occurs
//            just after the method .onStopCast is called.
//
//          - You may extend this lifetime in two ways. If you wish to manually
//            manage the lifetime of a SpellStruct, you may do either of the following:

//          - Setting thistype.autoDestroyDefault to false causes .autoDestroy to
//            be set to false just before onCreate is called, for all new instances.
//
//          - Setting this.autoDestroy to false stops just the current instance
//            from auto destruction. Setting it back to true will cause the struct
//            to be destroyed if it usually would have been by then, else continue
//            to monitor it for auto destruction.
//
//      Locking:
//     藟藟藟藟藟藟藟藟藟藟
//          - You may also add locks to an instance. This is done using this.addLock(),
//            and this.removeLock(). Calling this.addLock increments a counter, and
//            calling this.removeLock() decrements it. While it is greater than 0,
//            a SpellStruct will not be autodestroyed. Decrementing it back to 0
//            after the .onStopCast method has fired while .autoDestroy is true will
//            destroy the struct automatically. This is a garbage collection mechanism.
//
//          - You may check if a struct has no locks on it by using .isNotLocked.
//
//          - Example:
//

//      Timers:
//     藟藟藟藟藟藟藟藟藟
//          - If you have TimerUtils in your map, SpellStruct will operate using
//            TimerUtils data attachment for timers.
//          - If you don't have TimerUtils, but have Recycle, SpellStruct will
//            attach to Recycled timers using GetHandleId and a hashtable.
//          - If you have neither, SpellStruct will create timers dynamically,
//            and pause and destroy them when they are done with. Attachment
//            will be done with GetHandleId and a hashtable.
//
//          - .startTimer(method, period) will start a timer for the given method,
//            for the current spell instance. This means all spell event responses
//            will be available from within the callback. This timer will keep
//            firing until you stop it using .stopTimer(method).
//
//          - Starting a timer in this way automatically adds a lock to the struct,
//            and stopping a timer removes a lock. This is to guarantee that when
//            a timer method fires, all data is available and valid (while a struct
//            has locks, it will not be auto destroyed).
//
//          - Manually calling .destroy on a spell struct will stop all timers for
//            that struct automatically.
//
//          - Because it attaches both the method to call and the struct instance
//            to the timer, and then fires the method with .execute(), it is
//            recommended that you use this only for timers that are reasonably
//            infrequent. Using T32x with SpellStruct is recommended for high
//            frequency (low period) timers.
//
//          - Example:
//

//      Triggers:
//     藟藟藟藟藟藟藟藟藟藟藟
//          - Trigger attaching works using GetHandleId and a hashtable.
//
//          - .createTrigger(method) will create a trigger with the method as it's
//            action. Do not use DestroyTrigger to remove this trigger, you must
//            use .destroyTrigger(method) to destroy it instead. This saves having
//            to store the trigger in any sort of variable, generally. Destroying
//            a trigger using SpellStruct has protection against the double free
//            bug in Warcraft III, even if you use TriggerSleepAction.
//
//          - Creating a trigger in this way automatically adds a lock to the struct,
//            and destroying it removes this lock. This is to guarantee that when
//            a timer method fires, all data is available and valid (while a struct
//            has locks, it will not be auto destroyed).
//
//          - Manually calling .destroy on a spell struct will destroy all triggers
//            for that struct automatically.
//
//          - Example:
//

//      AoE (Area of Effect) enumeration:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - You may set the AoE of a spell instance using set this.aoe = x, or you
//            may set the default value for the aoe of a spell using set
//            thistype.defaultAoE = x. This will set the value of .aoe to the value
//            specified before onCreate is called.
//
//          - You may enumerate the units in AoE of the target point, the current
//            position of the targetted object, or the caster. This requires a unit
//            filter to be applied.
//
//          - This enum does not clear the group before hand, like native enums.
//            Actually, it should even be safe to use with dynamic groups.
//

//          - You may also skip groups altogether and do actions for all units within
//            aoe of the target point/target/caster.
//

//          - You may also check, for a single unit, to see if it is within the AoE
//            of the target point, target or caster, using the following:
//            - this.isUnitInAoE(myUnit) // within aoe of target point.
//            - this.isUnitInAoETarget(myUnit) // within aoe of target.
//            - this.isUnitInAoECaster(myUnit) // within aoe of caster.
//          - The above return booleans.
//
//          - All AoE functionality takes into account the collision size of the
//            enumerated units. This matches better with Warcraft III AoE detection,
//            which highlights units the spell will hit in green for AoE abilities.
//
//      Miscellaneous:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - call this.forGroup(g, callback method takes unit)
//            Example:
//

//          - real this.getDistanceToTargetWidget() // The distance between the caster and the target widget.
//          - real this.getDistanceToTargetPoint()  // The distance between the caster and the original point targetted.
//          - real this.getAngleToTargetWidget()    // The angle from the caster to the target object (in radians).
//          - real this.getAngleToTargetPoint()    // The angle from the caster to the target location (in radians).
//
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for helping me with the interface hint to make the methods
//            optional.
//
//===========================================================================
// Trigger: Timer Utils
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: HashKeyManager
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: T32
//===========================================================================
//TESH.scrollpos=48
//TESH.alwaysfold=0
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ Timer32 ~~ By Jesus4Lyf ~~ Version 1.06 ~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  What is Timer32?
//         - Timer32 implements a fully optimised timer loop for a struct.
//         - Instances can be added to the loop, which will call .periodic every
//           PERIOD until .stopPeriodic() is called.
//
//    =Pros=
//         - Efficient.
//         - Simple.
//
//    =Cons=
//         - Only allows one period.
//         - The called method must be named ".periodic".
//
//    Methods:
//         - struct.startPeriodic()
//         - struct.stopPeriodic()
//
//         - private method periodic takes nothing returns nothing
//
//           This must be defined in structs that implement Periodic Module.
//           It will be executed by the module every PERIOD until .stopPeriodic() is called.
//           Put "implement T32x" BELOW this method.
//
//    Modules:
//         - T32x
//           Has no safety on .stopPeriodic or .startPeriodic (except debug messages
//           to warn).
//
//         - T32xs
//           Has safety on .stopPeriodic and .startPeriodic so if they are called
//           multiple times, or while otherwise are already stopped/started respectively,
//           no error will occur, the call will be ignored.
//
//         - T32
//           The original, old version of the T32 module. This remains for backwards
//           compatability, and is deprecated. The periodic method must return a boolean,
//           false to continue running or true to stop.
//
//  Details:
//         - Uses one timer.
//
//         - Do not, within a .periodic method, follow a .stopPeriodic call with a
//           .startPeriodic call.
//
//  How to import:
//         - Create a trigger named T32.
//         - Convert it to custom text and replace the whole trigger text with this.
//
//  Thanks:
//         - Infinitegde for finding a bug in the debug message that actually altered
//           system operation (when in debug mode).
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Trigger: HashTable
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Distance
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIDS
//
// Default melee game initialization for all players
//===========================================================================
//TESH.scrollpos=48
//TESH.alwaysfold=0
//  
//        _   ___ ___  ___    _______________________________________________
//       /_\ |_ _|   \/ __|   ||     A D V A N C E D   I N D E X I N G     ||
//      / _ \ | || |) \__ \   ||                  A N D                    ||
//     /_/ \_\___|___/|___/   ||         D A T A   S T O R A G E           ||
//            By Jesus4Lyf    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//                                                                    v 1.1.0
//      What is AIDS?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          AIDS assigns unique integers between 1 and 8191 to units which enter
//          the map. These can be used for arrays and data attaching.
//          
//          AIDS also allows you to define structs which are created automatically
//          when units enter the map, and filtering which units should be indexed
//          as well as for which units these structs should be created.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Simply create a new trigger object called AIDS, go to 'Edit -> Convert
//          to Custom Text', and replace everything that's there with this script.
//
//          Save the map, close it, reopen it, and then delete the "!" from the
//          FAR left side of the next lines (so "external" will line up with this line):
//          external ObjectMerger w3a Adef AIDS anam "State Detection" ansf "(AIDS)" aart "" arac 0
//
//          At the top of the script, there is a 'UnitIndexingFilter' constant
//          function. If the function returns true for the unit, then that unit
//          will be automatically indexed. Setting this to true will automatically
//          index all units. Setting it to false will disable automatic indexing.
//
//      Functions:
//     藟藟藟藟藟藟藟藟藟藟藟藟
//          function GetUnitId takes unit u returns integer
//              - This returns the index of an indexed unit. This will return 0
//                if the unit has not been indexed.
//              - This function inlines. It does not check if the unit needs an
//                index. This function is for the speed freaks.
//              - Always use this if 'UnitIndexingFilter' simply returns true.
//
//          function GetUnitIndex takes unit u returns integer
//              - This will return the index of a unit if it has one, or assign
//                an index if the unit doesn't have one (and return the new index).
//              - Use this if 'UnitIndexingFilter' doesn't return true.
//
//          function GetIndexUnit takes integer index returns unit
//              - This returns the unit which has been assigned the 'index'.
//
//      AIDS Structs:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - Insert: //! runtextmacro AIDS() at the top of a struct to make it
//            an AIDS struct.
//          - AIDS structs cannot be created or destroyed manually. Instead, they
//            are automatically created when an appropriate unit enters the map.
//          - You cannot give members default values in their declaration.
//            (eg: private integer i=5 is not allowed)
//          - You cannot use array members.
//          - AIDS structs must "extend array". This will remove some unused
//            functions and enforce the above so there will be no mistakes.
//          - There are four optional methods you can use in AIDS structs:
//              - AIDS_onCreate takes nothing returns nothing
//                  - This is called when the struct is 'created' for the unit.
//                  - In here you can assign members their default values, which
//                    you would usually assign in their declarations.
//                    (eg: set this.i=5)
//              - AIDS_onDestroy takes nothing returns nothing
//                  - This is called when the struct is 'destroyed' for the unit.
//                  - This is your substitute to the normal onDestroy method.
//              - AIDS_filter takes unit u returns boolean
//                  - This is similar to the constant filter in the main system.
//                  - Each unit that enters the map will be tested by each AIDS
//                    struct filter. If it returns true for that unit, that unit
//                    will be indexed if it was not already, the AIDS struct will
//                    have its AIDS_onCreate method called, and later have its
//                    AIDS_onDestroy method called when the index is recycled.
//                  - Not declaring this will use the default AIDS filter instead.
//              - AIDS_onInit takes nothing returns nothing
//                  - This is because I stole your onInit function with my textmacro.
//          - You can use '.unit' from any AIDS struct to get the unit for which
//            the struct is for.
//          - The structs id will be the units index, so getting the struct for
//            a unit inlines to a single native call, and you can typecast between
//            different AIDS structs. This is the premise of AIDS.
//          - Never create or destroy AIDS structs directly.
//          - You can call .AIDS_addLock() and AIDS_removeLock() to increase or
//            decrease the lock level on the struct. If a struct's lock level is
//            not 0, it will not be destroyed until it is reduced to 0. Locks just
//            put off AIDS struct destruction in case you wish to attach to a timer
//            or something which must expire before the struct data disappears.
//            Hence, not freeing all locks will leak the struct (and index).
//
//      PUI and AutoIndex:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - AIDS includes the PUI textmacros and the AutoIndex module, because
//            these systems are not compatible with AIDS but have valid and distinct
//            uses.
//          - The PUI textmacros are better to use for spells than AIDS structs,
//            because they are not created for all units, just those targetted by
//            the spell (or whatever else is necessary).
//          - The AutoData module is good for very simple array syntax for data
//            attachment (although I don't recommend that people actually use it,
//            it's here mostly for compatability). Note that unlike the PUI textmacros,
//            units must pass the AIDS filter in order for this module to work with
//            them. This is exactly as the same as in AutoIndex itself (AutoIndex
//            has a filter too).
//          
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for writing 90% of this user documentation, challenging my
//            interface, doing some testing, suggesting improvements and inspiring
//            me to re-do my code to include GetUnitIndex as non-inlining.
//          - grim001, for writing the AutoData module, and AutoIndex. I used the
//            on-enter-map method that he used. Full credits for the AutoData module.
//          - Cohadar, for writing his PUI textmacros. Full credits to him for these,
//            except for my slight optimisations for this system.
//            Also, I have used an optimised version of his PeriodicRecycler from
//            PUI in this system to avoid needing a RemoveUnitEx function.
//          - Vexorian, for helping Cohadar on the PUI textmacro.
//          - Larcenist, for suggesting the AIDS acronym. Originally he suggested
//            'Alternative Index Detection System', but obviously I came up with
//            something better. In fact, I'd say it looks like the acronym was
//            an accident. Kinda neat, don't you think? :P
//
//      Final Notes:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - With most systems, I wouldn't usually add substitutes for alternative
//            systems. However, UnitData systems are an exception, because they
//            are incompatible with eachother. Since using this system forbids
//            people from using the real PUI or AutoIndex, and a lot of resources
//            use either of these, it made sense not to break them all.
//
//          - If this documentation confused you as to how to use the system, just
//            leave everything as default and use GetUnitId everywhere.
//
//          - To use this like PUI (if you don't like spamming indices) simply
//            make the AIDS filter return false, and use GetUnitIndex.
//
// Trigger: AIDSCleaner
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_AIDSCleanerActions takes nothing returns nothing
    local unit tu = GetTriggerUnit()
    call EquipmentData[tu].stopPeriodic()
endfunction
//===========================================================================
function InitTrig_AIDSCleaner takes nothing returns nothing
    set gg_trg_AIDSCleaner = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_AIDSCleaner, EVENT_PLAYER_UNIT_DEATH )
    call YDWETriggerRegisterLeaveRectSimpleNull( gg_trg_AIDSCleaner, GetPlayableMapRect() )
    call TriggerAddCondition(gg_trg_AIDSCleaner, function Trig_AIDSCleanerActions)
endfunction
//===========================================================================
// Trigger: Event
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  ~~    Event     ~~    By Jesus4Lyf    ~~    Version 1.04    ~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  What is Event?
//         - Event simulates Warcraft III events. They can be created,
//           registered for, fired and also destroyed.
//         - Event, therefore, can also be used like a trigger "group".
//         - This was created when there was an influx of event style systems 
//           emerging that could really benefit from a standardised custom
//           events snippet. Many users were trying to achieve the same thing
//           and making the same kind of errors. This snippet aims to solve that.
//
//  Functions:
//         - Event.create()       --> Creates a new Event.
//         - .destroy()           --> Destroys an Event.
//         - .fire()              --> Fires all triggers which have been
//                                    registered on this Event.
//         - .register(trigger)   --> Registers another trigger on this Event.
//         - .unregister(trigger) --> Unregisters a trigger from this Event.
//
//  Details:
//         - Event is extremely efficient and lightweight.
//         - It is safe to use with dynamic triggers.
//         - Internally, it is just a linked list. Very simple.
//
//  How to import:
//         - Create a trigger named Event.
//         - Convert it to custom text and replace the whole trigger text with this.
//
//  Thanks:
//         - Builder Bob for the trigger destroy detection method.
//         - Azlier for inspiring this by ripping off my dodgier code.
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Trigger: Damage
//===========================================================================
//TESH.scrollpos=51
//TESH.alwaysfold=0
//  
//      ___   _     __  __   _   ___  ____    _______________________________
//     |   \ /_\   /  |/  | /_\ /  _\|  __|   ||      D E A L   I T ,      ||
//     | |) / _ \ / / | / |/ _ \| |/||  __|   ||    D E T E C T   I T ,    ||
//     |___/_/ \_/_/|__/|_|_/ \_\___/|____|   ||     B L O C K   I T .     ||
//                            By Jesus4Lyf    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//                                                                    v 1.0.1
//      What is Damage?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Damage is a damage dealing, detection and blocking system. It implements
//          all such functionality. It also provides a means to detect what type
//          of damage was dealt, so long as all damage in your map is dealt using
//          this system's deal damage functions (except for basic attacks).
//
//          It is completely recursively defined, meaning if you deal damage on
//          taking damage, the type detection and other features like blocking
//          will not malfunction.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Create a new trigger object called Damage, go to 'Edit -> Convert to
//          Custom Text', and replace everything that's there with this script.
//
//          At the top of the script, there is a '//! external ObjectMerger' line.
//          Save your map, close your map, reopen your map, and then comment out this
//          line. Damage is now implemented. This line creates a dummy ability used
//          in the system in some circumstances with damage blocking.
//
//      Functions:
//     藟藟藟藟藟藟藟藟藟藟藟藟
//          function Damage_RegisterEvent takes trigger whichTrigger returns nothing
//              - This registers a special "any unit takes damage" event.
//              - This event supports dynamic trigger use.
//              - Only triggers registered on this event may block damage.
//
//          function Damage_GetType takes nothing returns damagetype
//              - This will get the type of damage dealt, like an event response,
//                for when using a unit takes damage event (or the special event above).
//
//          function Damage_Block takes real amount returns nothing
//          function Damage_BlockAll takes nothing returns nothing
//              - For use only with Damage_RegisterEvent.
//              - Blocks 'amount' of the damage dealt.
//              - Multiple blocks at once work correctly.
//              - Blocking more than 100% of the damage will block 100% instead.
//              - Damage_BlockAll blocks 100% of the damage being dealt.
//
//          function Damage_EnableEvent takes boolean enable returns nothing
//              - For disabling and re-enabling the special event.
//              - Use it to deal damage which you do not want to be detected by
//                the special event.
//
//          function UnitDamageTargetEx takes lots of things returns boolean
//              - Replaces UnitDamageTarget in your map, with the same arguments.
//
//          function Damage_Physical takes unit source, unit target, real amount,
//            attacktype whichType, boolean attack, boolean ranged returns boolean
//              - A clean wrapper for physical damage.
//              - 'attack' determines if this is to be treated as a real physical
//                attack or just physical type damage.
//              - 'ranged' determines if this is to be treated as a ranged or melee
//                attack.
//
//          function Damage_Spell takes unit source, unit target, real amount returns boolean
//              - A clean wrapper for spell damage.
//
//          function Damage_Pure takes unit source, unit target, real amount returns boolean
//              - A clean wrapper for pure type damage (universal type, 100% damage).
//          
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for helping me find a better way to think about damage blocking.
//
//===========================================================================
// Trigger: CustomDamage
//
//     local real colris1 = Material[u1].colris
//     local real colris2 = Material[u2].colris
//     local real coldmg1 = Material[u1].coldmg
//     local real coldmg2 = Material[u2].coldmg
//     //local real colf1 = Material[u1].colf
//     //local real colf2 = Material[u2].colf
// (1 - colris2) * (pvd * (1 + coldmg1))
// "Objects\\Spawnmodels\\Human\\HumanBlood\\BloodElfSpellThiefBlood.mdl"
//===========================================================================
//TESH.scrollpos=87
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Custom Congregation
//===========================================================================
//TESH.scrollpos=10
//TESH.alwaysfold=0
// Trigger: List Module
//===========================================================================
//TESH.scrollpos=42
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Group Utils
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: ItmTest
//===========================================================================
//TESH.scrollpos=17
//TESH.alwaysfold=0
//===========================================================================
// Trigger: CreateItem
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_CreateItemActions takes nothing returns nothing
    local integer i = 0
    call YDWEPolledWaitNull(1.00)
    //call CreateItemEx('I003',0,0)
    //call CreateItemEx('I002',0,0)
    //call CreateItemEx(iRETURN,0,0)
    //call CreateItemEx(iREACT,0,0)
    //call CreateItemEx(iELECTRIC,0,0)
    //call CreateItemEx(iBLINK,0,0)
    //call CreateItemEx(iTRANSPORT,0,0)
    //call CreateItemEx(iAUTOAIM,0,0)
    //call CreateItemEx(iLEAVE,0,0)
    //call CreateItemEx(iBKGRENADE,0,0)
    //call CreateItemEx(iPSGRENADE,0,0)
    //call CreateItemEx(iMINE,0,0)
    //call CreateItemEx('I00Z',0,0)
    //call CreateItemEx('I00Q',0,0)
    //call CreateItemEx('I00P',0,0)
    //call CreateItemEx('I00S',0,0)
    //call CreateItemEx('I00R',0,0)
    loop
        exitwhen i > 0
        //call CreateItemEx(i100G,-300,0)
        set i = i + 1
    endloop
    set i = 0
    loop
        exitwhen i > 0
        //call CreateItemEx(iFREEUP,-300,-100)
        set i = i + 1
    endloop
    set i =0
    loop
        exitwhen i > 0
        //call CreateItemEx(iEXP,-300,-200)
        set i = i + 1
    endloop
endfunction
//===========================================================================
function InitTrig_CreateItem takes nothing returns nothing
    set gg_trg_CreateItem = CreateTrigger()
    call TriggerAddAction(gg_trg_CreateItem, function Trig_CreateItemActions)
endfunction
//===========================================================================
// Trigger: cantmove
//===========================================================================
function Trig_cantmoveConditions takes nothing returns boolean
    return (((GetIssuedOrderIdBJ() == String2OrderIdBJ("smart")) or (GetIssuedOrderIdBJ() == String2OrderIdBJ("move")) or (GetIssuedOrderIdBJ() == String2OrderIdBJ("patrol"))) and (GetUnitAbilityLevel(GetTriggerUnit(), 'A02H') >= 1))
endfunction
function Trig_cantmoveActions takes nothing returns nothing
    call IssueImmediateOrderById( GetTriggerUnit(), 851972 )
    call PauseUnit( GetTriggerUnit(), true )
    call PauseUnit( GetTriggerUnit(), false )
endfunction
//===========================================================================
function InitTrig_cantmove takes nothing returns nothing
    set gg_trg_cantmove = CreateTrigger()
    call TriggerAddCondition(gg_trg_cantmove, Condition(function Trig_cantmoveConditions))
    call TriggerAddAction(gg_trg_cantmove, function Trig_cantmoveActions)
endfunction
//===========================================================================
// Trigger: InitFloatText
//===========================================================================
function Trig_InitFloatTextActions takes nothing returns nothing
    call CreateTextTagLocBJ( "TRIGSTR_1680", Location(5609.00, 6151.00), 0, 10, 100, 100, 100, 0 )
    call CreateTextTagLocBJ( "TRIGSTR_1681", Location(6142.00, 6151.00), 0, 10, 100, 100, 100, 0 )
endfunction
//===========================================================================
function InitTrig_InitFloatText takes nothing returns nothing
    set gg_trg_InitFloatText = CreateTrigger()
    call TriggerAddAction(gg_trg_InitFloatText, function Trig_InitFloatTextActions)
endfunction
//===========================================================================
// Trigger: 3
//===========================================================================
function Trig_3Conditions takes nothing returns boolean
    return ((IsUnitInvisible(GetTriggerUnit(), Player(0)) == true))
endfunction
function Trig_3Actions takes nothing returns nothing
endfunction
//===========================================================================
function InitTrig_3 takes nothing returns nothing
    set gg_trg_3 = CreateTrigger()
    call TriggerAddCondition(gg_trg_3, Condition(function Trig_3Conditions))
    call TriggerAddAction(gg_trg_3, function Trig_3Actions)
endfunction
//===========================================================================
// Trigger: camera
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_cameraActions takes nothing returns nothing
    call SetCameraFieldForPlayer( Player(0), CAMERA_FIELD_TARGET_DISTANCE, 2500.00, 0.50 )
endfunction
//===========================================================================
function InitTrig_camera takes nothing returns nothing
    set gg_trg_camera = CreateTrigger()
    call TriggerAddAction(gg_trg_camera, function Trig_cameraActions)
endfunction
//===========================================================================
// Trigger: inittest
//
//     call CreateUnit( Player(11), 'u000', 970, 1378, bj_UNIT_FACING )
//     call CreateUnit( Player(11), 'u000', 960, 1378, bj_UNIT_FACING )
//     call CreateUnit( Player(11), 'u000', 950, 1378, bj_UNIT_FACING )
//     call CreateUnit( Player(11), 'u000', 950, 1350, bj_UNIT_FACING )
//     call CreateUnit( Player(11), 'u000', 950, 1340, bj_UNIT_FACING )
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_inittestActions takes nothing returns nothing
    local unit u
    local unit hero
    local unit ally
    local real x = GetRandomReal(GetRectMinX(gg_rct_start), GetRectMaxX(gg_rct_start))
    local real y = GetRandomReal(GetRectMinY(gg_rct_start), GetRectMaxY(gg_rct_start))
    local integer i = 0
    local IDialog d
    
    //call CreateFogModifierRectBJ( true, Player(0), FOG_OF_WAR_VISIBLE, GetPlayableMapRect() )
    call CreateFogModifierRectBJ( true, Player(11), FOG_OF_WAR_VISIBLE, GetPlayableMapRect() )
    //set hero = CreateHero(0,x, y )
    //set hero = CreateHero(0,0, 0 )
    //call UnitAddItem(hero, CreateItemEx('I001',0,0))
    //set g_camera_lock = true
    set g_fog = false
    //set boss1 = gg_unit_u002_0161
    //call LockAgain()
    //set ally = CreateUnit(Player(11),'h003',0,-700,0)
    //set ally = CreateUnit(Player(0),EVIL_MARIN,0,-100,0)
    //set ally = CreateUnit(Player(0),'ewsp',0,-500,0)
    //set ally = CreateUnit(Player(0),'ewsp',0,-600,0)
    //set ally = CreateUnit(Player(0),'ewsp',0,-700,0)
    //call SetUnitLifeBJ( ally, 1000.00 )
    set bj_forLoopAIndex = 1
    set bj_forLoopAIndexEnd = 0
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call CreateUnit( Player(11), 'u000', GetRandomReal(-3000.00, 5000.00), GetRandomReal(-6000.00, 2500.00), bj_UNIT_FACING )
        //call CreateUnit( Player(11), 'z000', GetRandomReal(-3000.00, 5000.00), GetRandomReal(-6000.00, 2500.00), bj_UNIT_FACING )
        set bj_forLoopAIndex = bj_forLoopAIndex + 1
    endloop
    //set boss1 = CreateUnit(Player(11), 'u002', 2300, -40,0)
    set u = null
    set hero = null
    //call CreateUnit( Player(11), 'u005', -700, 750, bj_UNIT_FACING )
    //call CreateUnit( Player(11), 'z001', -700, 800, bj_UNIT_FACING )
    //call CreateUnit( Player(11), 'z001', -700, 900, bj_UNIT_FACING )
    //call CreateUnit( Player(11), 'u005', -1500, 700, bj_UNIT_FACING )
    loop
        exitwhen i >= 3
        if heros[i] != null then
            //call SetCameraTargetControllerNoZForPlayer( Player(i), heros[i], 0, 0, false )
        endif
        set i = i + 1
    endloop
    //call TriggerSleepAction(2)
    //call SelectDifficultyDialog.create("璇烽€夋嫨娓告垙闅惧害", Player(0)).display()
    call SetPlayerHandicapXP( Player(0), 0.10 )
    call SetPlayerHandicapXP( Player(1), 0.10 )
    call SetPlayerHandicapXP( Player(2), 0.10 )
    //call GamePlay_StartRoom()
    //call StartItmTest()
    call InitStage1()
    call InitDisplayDamageSystem()
    call InitReviveSystem()
endfunction
//===========================================================================
function InitTrig_inittest takes nothing returns nothing
    set gg_trg_inittest = CreateTrigger()
    call TriggerAddAction(gg_trg_inittest, function Trig_inittestActions)
endfunction
//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_Stage2Gate( )
    call InitTrig_Stage1( )
    call InitTrig_Stage1T( )
    call InitTrig_Resources( )
    call InitTrig_InitJobData( )
    call InitTrig_Strong( )
    call InitTrig_TransportEnergy( )
    call InitTrig_HolyLight( )
    call InitTrig_ReviveSpell( )
    call InitTrig_DawnHammer( )
    call InitTrig_NetGun( )
    call InitTrig_ShootBost( )
    call InitTrig_PowerPunch( )
    call InitTrig_SelectHero( )
    call InitTrig_Reload( )
    call InitTrig_ItemJump( )
    call InitTrig_GunSpell( )
    call InitTrig_Jump( )
    call InitTrig_JumpFacingStore( )
    call InitTrig_InjectionSpeedUp( )
    call InitTrig_RegisterSpell( )
    call InitTrig_Darts( )
    call InitTrig_RetrunDarts( )
    call InitTrig_SmartDarts( )
    call InitTrig_ExplodeSmartDarts( )
    call InitTrig_ShoulderCannon( )
    call InitTrig_ItemRetrunDarts( )
    call InitTrig_LeaveDarts( )
    call InitTrig_DartsStorm( )
    call InitTrig_GuardDarts( )
    call InitTrig_BackGrenade( )
    call InitTrig_Mine( )
    call InitTrig_PushGrenade( )
    call InitTrig_Blink( )
    call InitTrig_Transport( )
    call InitTrig_ElectricWhip( )
    call InitTrig_AutoAim( )
    call InitTrig_ShootBack( )
    call InitTrig_TeckLock( )
    call InitTrig_Register( )
    call InitTrig_RegisterFly( )
    call InitTrig_FireRegion( )
    call InitTrig_SpeedUp( )
    call InitTrig_SummonUtil( )
    call InitTrig_Revive( )
    call InitTrig_ManaChange( )
    call InitTrig_ManaGrow( )
    call InitTrig_TechUnit( )
    call InitTrig_Effect( )
    call InitTrig_CameraAdjust( )
    call InitTrig_FogControl( )
    call InitTrig_CameraLock( )
    call InitTrig_Movie( )
    call InitTrig_GV( )
    call InitTrig_LearnAbility( )
    call InitTrig_TriggerKillHpBuff( )
    call InitTrig_TriggerHorro( )
    call InitTrig_HorrorOrderFilter( )
    call InitTrig_HorrorOrder( )
    call InitTrig_OrderId( )
    call InitTrig_ShootSpeed( )
    call InitTrig_Radiation( )
    call InitTrig_ArrayList( )
    call InitTrig_TechLevelUp( )
    call InitTrig_TechData( )
    call InitTrig_Transform( )
    call InitTrig_DialogSystem( )
    call InitTrig_Buffer( )
    call InitTrig_TransportBuffer( )
    call InitTrig_SpeedStateBuffer( )
    call InitTrig_NetBuffer( )
    call InitTrig_ShootBostBuffer( )
    call InitTrig_SpeedColBuffer( )
    call InitTrig_BurnBuffer( )
    call InitTrig_HorroBuffer( )
    call InitTrig_FloatBuffer( )
    call InitTrig_BleedBuffer( )
    call InitTrig_IceSlowBuffer( )
    call InitTrig_AutoAimBuffer( )
    call InitTrig_Debuff( )
    call InitTrig_BufferFunction( )
    call InitTrig_Constants( )
    call InitTrig_PlayerHero( )
    call InitTrig_FocuseHero( )
    call InitTrig_ItemData( )
    call InitTrig_ItemEquip( )
    call InitTrig_ItemType( )
    call InitTrig_UnitId( )
    call InitTrig_FakeMan( )
    call InitTrig_MonsterDead( )
    call InitTrig_ShootTarget( )
    call InitTrig_MonsterTypeData( )
    call InitTrig_MonsterBonus( )
    call InitTrig_MonsterTargetGroup( )
    call InitTrig_DeathEffect( )
    call InitTrig_Difficulty( )
    call InitTrig_EffectString( )
    call InitTrig_SkillLearn( )
    call InitTrig_DoublePacket( )
    call InitTrig_Missle( )
    call InitTrig_MissleFactory( )
    call InitTrig_Gun( )
    call InitTrig_WallDeath( )
    call InitTrig_Shooter( )
    call InitTrig_HeroData( )
    call InitTrig_EquipmentData( )
    call InitTrig_HeroStatus( )
    call InitTrig_Velocity( )
    call InitTrig_Material( )
    call InitTrig_PhysicsSystem( )
    call InitTrig_bordercontrol( )
    call InitTrig_TargetFilter( )
    call InitTrig_ItemInfo( )
    call InitTrig_AIAttack( )
    call InitTrig_BOSS1( )
    call InitTrig_AIStrategy( )
    call InitTrig_AIGroup( )
    call InitTrig_AIData( )
    call InitTrig_AIDriver( )
    call InitTrig_DummyCaster( )
    call InitTrig_Status( )
    call InitTrig_Heal( )
    call InitTrig_ABC( )
    call InitTrig_AII( )
    call InitTrig_Table( )
    call InitTrig_Height( )
    call InitTrig_AddEffectZ( )
    call InitTrig_Move( )
    call InitTrig_Vector( )
    call InitTrig_FloatText( )
    call InitTrig_Text( )
    call InitTrig_Direction( )
    call InitTrig_SpellStruck( )
    call InitTrig_Timer_Utils( )
    call InitTrig_HashKeyManager( )
    call InitTrig_T32( )
    call InitTrig_HashTable( )
    call InitTrig_Distance( )
    call InitTrig_AIDS( )
    call InitTrig_AIDSCleaner( )
    call InitTrig_Event( )
    call InitTrig_Damage( )
    call InitTrig_CustomDamage( )
    call InitTrig_Custom_Congregation( )
    call InitTrig_List_Module( )
    call InitTrig_Group_Utils( )
    call InitTrig_ItmTest( )
    call InitTrig_CreateItem( )
    call InitTrig_cantmove( )
    call InitTrig_InitFloatText( )
    call InitTrig_3( )
    call InitTrig_camera( )
    call InitTrig_inittest( )
endfunction
//===========================================================================
function RunInitializationTriggers takes nothing returns nothing
    call ConditionalTriggerExecute( gg_trg_TeckLock )
    call ConditionalTriggerExecute( gg_trg_Status )
    call ConditionalTriggerExecute( gg_trg_ABC )
    call ConditionalTriggerExecute( gg_trg_CreateItem )
    call ConditionalTriggerExecute( gg_trg_InitFloatText )
    call ConditionalTriggerExecute( gg_trg_camera )
    call ConditionalTriggerExecute( gg_trg_inittest )
endfunction
//***************************************************************************
//*
//*  Players
//*
//***************************************************************************
function InitCustomPlayerSlots takes nothing returns nothing
    // Player 0
    call SetPlayerStartLocation( Player(0), 0 )
    call ForcePlayerStartLocation( Player(0), 0 )
    call SetPlayerColor( Player(0), ConvertPlayerColor(0) )
    call SetPlayerRacePreference( Player(0), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(0), true )
    call SetPlayerController( Player(0), MAP_CONTROL_USER )
    // Player 1
    call SetPlayerStartLocation( Player(1), 1 )
    call ForcePlayerStartLocation( Player(1), 1 )
    call SetPlayerColor( Player(1), ConvertPlayerColor(1) )
    call SetPlayerRacePreference( Player(1), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(1), true )
    call SetPlayerController( Player(1), MAP_CONTROL_USER )
    // Player 2
    call SetPlayerStartLocation( Player(2), 2 )
    call ForcePlayerStartLocation( Player(2), 2 )
    call SetPlayerColor( Player(2), ConvertPlayerColor(2) )
    call SetPlayerRacePreference( Player(2), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(2), true )
    call SetPlayerController( Player(2), MAP_CONTROL_USER )
    // Player 11
    call SetPlayerStartLocation( Player(11), 3 )
    call ForcePlayerStartLocation( Player(11), 3 )
    call SetPlayerColor( Player(11), ConvertPlayerColor(11) )
    call SetPlayerRacePreference( Player(11), RACE_PREF_UNDEAD )
    call SetPlayerRaceSelectable( Player(11), true )
    call SetPlayerController( Player(11), MAP_CONTROL_COMPUTER )
endfunction
function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_002
    call SetPlayerTeam( Player(0), 0 )
    call SetPlayerTeam( Player(1), 0 )
    call SetPlayerTeam( Player(2), 0 )
    //   Allied
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(1), true )
    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(1), true )
    // Force: TRIGSTR_149
    call SetPlayerTeam( Player(11), 1 )
endfunction
function InitAllyPriorities takes nothing returns nothing
    call SetStartLocPrioCount( 0, 2 )
    call SetStartLocPrio( 0, 0, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrioCount( 1, 2 )
    call SetStartLocPrio( 1, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrioCount( 2, 2 )
    call SetStartLocPrio( 2, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 1, 1, MAP_LOC_PRIO_HIGH )
endfunction
//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************
//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds( -29952.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -9728.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 9472.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 29696.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -29952.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 29696.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 9472.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -9728.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) )
    call SetDayNightModels( "Environment\\DNC\\DNCDalaran\\DNCDalaranTerrain\\DNCDalaranTerrain.mdl", "Environment\\DNC\\DNCDalaran\\DNCDalaranUnit\\DNCDalaranUnit.mdl" )
    call SetTerrainFogEx( 0, 0.0, 10000.0, 0.100, 0.000, 0.000, 0.000 )
    call NewSoundEnvironment( "Default" )
    call SetAmbientDaySound( "DalaranDay" )
    call SetAmbientNightSound( "DalaranNight" )
    call SetMapMusic( "Music", true, 0 )
    call InitSounds( )
    call CreateRegions( )
    call CreateCameras( )
    call CreateAllDestructables( )
    call CreateAllItems( )
    call CreateAllUnits( )
    call InitBlizzard( )

//! initstructs
call ExecuteFunc("ABC__Init")
call ExecuteFunc("AIDS__InitAIDS")
call ExecuteFunc("InitHashTable")
call ExecuteFunc("InitHeroStatus")
call ExecuteFunc("InitMonsterDead")
call ExecuteFunc("InitMonsterTypeData")
call ExecuteFunc("InitRegisterSpell")
call ExecuteFunc("InitResources")
call ExecuteFunc("ShootBackInitializer")
call ExecuteFunc("InitSkillLearn")
call ExecuteFunc("T32__OnInit")
call ExecuteFunc("InitTechData")
call ExecuteFunc("InitTechUnit")
call ExecuteFunc("Init")
call ExecuteFunc("YDTriggerSaveLoadSystem__Init")
call ExecuteFunc("InitializeYD")
call ExecuteFunc("InitConstants")
call ExecuteFunc("Damage__OnInit")
call ExecuteFunc("InitDoublePacket")
call ExecuteFunc("Heal__Init")
call ExecuteFunc("InitItemData")
call ExecuteFunc("InitJumpFacingStore")
call ExecuteFunc("InitMonsterBonus")
call ExecuteFunc("InitMove")
call ExecuteFunc("YDWETimerSystem__Init")
call ExecuteFunc("CameraLockInit")
call ExecuteFunc("FakeManInit")
call ExecuteFunc("FogControlInit")
call ExecuteFunc("InitItemEquip")
call ExecuteFunc("InitNetBuffer")
call ExecuteFunc("InitShootTarget")
call ExecuteFunc("InitStrong")
call ExecuteFunc("InitAIGroup")
call ExecuteFunc("InitAIStrategy")
call ExecuteFunc("InitMonsterTargetGroup")
call ExecuteFunc("InitTransform")
call ExecuteFunc("BufferStructInit")
call ExecuteFunc("InitRadiation")
call ExecuteFunc("SetupStage1")
call ExecuteFunc("InitAIAttack")
call ExecuteFunc("MissleInit")

//! initdatastructs
    call InitGlobals( )
    call InitCustomTriggers( )
    call RunInitializationTriggers( )
endfunction
//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************
function config takes nothing returns nothing
    call SetMapName( "TRIGSTR_138" )
    call SetMapDescription( "TRIGSTR_140" )
    call SetPlayers( 4 )
    call SetTeams( 4 )
    call SetGamePlacement( MAP_PLACEMENT_TEAMS_TOGETHER )
    call DefineStartLocation( 0, 5824.0, 6144.0 )
    call DefineStartLocation( 1, 5824.0, 6144.0 )
    call DefineStartLocation( 2, 5824.0, 6144.0 )
    call DefineStartLocation( 3, 5888.0, 7552.0 )
    // Player setup
    call InitCustomPlayerSlots( )
    call InitCustomTeams( )
    call InitAllyPriorities( ):

endfunction
//===========================================================================  
//===========================================================================  
//自定义事件 
//===========================================================================
//===========================================================================   

//===========================================================================
//系统-TimerSystem
//===========================================================================

000
010
101
011
000
111
010
101
110
001
111
100
010
101
011
000
a11
, 70.0
