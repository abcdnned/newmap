globals
//globals from AIDS:
constant boolean LIBRARY_AIDS=true
constant real AIDS___PERIOD= 0.03125
        // The unit stored at an index.
unit array AIDS___IndexUnit
integer array AIDS___LockLevel
        // Recycle stack
integer array AIDS___RecycledIndex
integer AIDS___MaxRecycledIndex= 0
        
        // Previous highest index
integer AIDS___MaxIndex= 0
integer array AIDS___DecayingIndex
integer AIDS___MaxDecayingIndex=0
integer AIDS___DecayChecker=0
        // The Add/Remove stack (or assign/recycle stack).
        // 
        // Indexing can become recusive since units can be created on index
        // assignment or deallocation.
        // To support this, a stack is used to store the event response results.
integer AIDS___ARStackLevel=0
integer array AIDS___ARStackIndex
unit array AIDS___ARStackUnit
        
        // A later discovery revealed that the Add/Remove stack did not need to be
        // used for deallocation. The alternative used works fine...
        // For structs and such which need to do things on unit index assignment.
trigger AIDS___OnEnter=CreateTrigger()
        // The same, but for when units pass the initial filter anyway.
trigger AIDS___OnEnterAllocated=CreateTrigger()
        // For structs and such which need to do things on unit index deallocation.
trigger AIDS___OnDeallocate=CreateTrigger()
integer AIDS___getindex
//endglobals from AIDS
//globals from AnyUnitSpellEffectTrg:
constant boolean LIBRARY_AnyUnitSpellEffectTrg=true
trigger gausetrg
trigger gausctrg
//endglobals from AnyUnitSpellEffectTrg
//globals from Concurrent:
constant boolean LIBRARY_Concurrent=true
//endglobals from Concurrent
//globals from Event:
constant boolean LIBRARY_Event=true
//endglobals from Event
//globals from Guns:
constant boolean LIBRARY_Guns=true
integer gunsdq='A00J'
integer gunsdqid='e004'
            
integer gunhlb='A00L'
integer gunhlbid='e005'
//endglobals from Guns
//globals from HashKeyManager:
constant boolean LIBRARY_HashKeyManager=true
//endglobals from HashKeyManager
//globals from MonsterType:
constant boolean LIBRARY_MonsterType=true
integer mbpz='u000'
integer mshs='n000'
integer mqfz='z001'
//endglobals from MonsterType
//globals from TargetFliter:
constant boolean LIBRARY_TargetFliter=true
//endglobals from TargetFliter
//globals from UnitList:
constant boolean LIBRARY_UnitList=true
//endglobals from UnitList
//globals from Vector:
constant boolean LIBRARY_Vector=true
//endglobals from Vector
//globals from VectorManager:
constant boolean LIBRARY_VectorManager=true
//endglobals from VectorManager
//globals from YDWEBase:
constant boolean LIBRARY_YDWEBase=true
//全局哈希表 
hashtable YDHT= null
string bj_AllString=".................................!.#$%&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................"
//鍏ㄥ眬绯荤粺鍙橀噺
unit bj_lastAbilityCastingUnit=null
unit bj_lastAbilityTargetUnit=null
unit bj_lastPoolAbstractedUnit=null
unitpool bj_lastCreatedUnitPool=null
item bj_lastPoolAbstractedItem=null
itempool bj_lastCreatedItemPool=null
attacktype bj_lastSetAttackType= ATTACK_TYPE_NORMAL
damagetype bj_lastSetDamageType= DAMAGE_TYPE_NORMAL
weapontype bj_lastSetWeaponType= WEAPON_TYPE_WHOKNOWS
real yd_MapMaxX= 0
real yd_MapMinX= 0
real yd_MapMaxY= 0
real yd_MapMinY= 0
string array YDWEBase___yd_PlayerColor
trigger array YDWEBase___AbilityCastingOverEventQueue
integer array YDWEBase___AbilityCastingOverEventType
integer YDWEBase___AbilityCastingOverEventNumber= 0
//endglobals from YDWEBase
//globals from YDWETriggerEvent:
constant boolean LIBRARY_YDWETriggerEvent=true
trigger yd_DamageEventTrigger= null
trigger array YDWETriggerEvent___DamageEventQueue
integer YDWETriggerEvent___DamageEventNumber= 0
	
item bj_lastMovedItemInItemSlot= null
	
trigger YDWETriggerEvent___MoveItemEventTrigger= null
trigger array YDWETriggerEvent___MoveItemEventQueue
integer YDWETriggerEvent___MoveItemEventNumber= 0
//endglobals from YDWETriggerEvent
//globals from YDWETriggerRegisterEnterRectSimpleNull:
constant boolean LIBRARY_YDWETriggerRegisterEnterRectSimpleNull=true
region yd_NullTempRegion
//endglobals from YDWETriggerRegisterEnterRectSimpleNull
//globals from YDWETriggerRegisterLeaveRectSimpleNull:
constant boolean LIBRARY_YDWETriggerRegisterLeaveRectSimpleNull=true
//endglobals from YDWETriggerRegisterLeaveRectSimpleNull
//globals from Attract:
constant boolean LIBRARY_Attract=true
integer katt
integer array att2dths
integer att2dthsn
integer ktrc
integer array trc2dths
integer trc2dthsn
//endglobals from Attract
//globals from AutoIndex:
constant boolean LIBRARY_AutoIndex=true
//endglobals from AutoIndex
//globals from Damage:
constant boolean LIBRARY_Damage=true
constant integer Damage___LIFE_BONUS_ABIL='dprv'
integer Damage___OnDamageEvent
integer Damage___OnZeroDamageEvent
boolean Damage___EventEnabled=true
integer Damage___TypeStackLevel=0
damagetype array Damage___TypeStackValue
boolean array Damage___TypeStackAttack
real array Damage___ToBlock
integer Damage___BlockNum=0
unit array Damage___BlockUnit
real array Damage___BlockUnitLife
real array Damage___BlockRedamage
unit array Damage___BlockDamageSource
        
timer Damage___BlockTimer=CreateTimer()
unit array Damage___RemoveBoosted
integer Damage___RemoveBoostedMax=0
        
timer Damage___RemoveBoostedTimer=CreateTimer()
real Damage___BoostedLifeTemp
unit Damage___BoostedLifeUnit
unit Damage___ForUnit
real Damage___NextHealth
//endglobals from Damage
//globals from PUI:
constant boolean LIBRARY_PUI=true
//endglobals from PUI
//globals from RegisterM:
constant boolean LIBRARY_RegisterM=true
integer km
//endglobals from RegisterM
//globals from VectorLib:
constant boolean LIBRARY_VectorLib=true
//endglobals from VectorLib
//globals from YDWEJumpTimer:
constant boolean LIBRARY_YDWEJumpTimer=true
//跳跃系统优先级
integer MoveMoreLevel_JumpTimer=3
//endglobals from YDWEJumpTimer
//globals from Velocity:
constant boolean LIBRARY_Velocity=true
integer kvel
integer kctype
integer keff
integer kcrange
integer kkb
integer kfly
integer klife
integer kbrange
integer array balls
integer ballNum=0
real vmax=200
real vf=0.02
integer CTYPE_THROUGH=0
integer CTYPE_BLOOM=1
integer CTYPE_NONE=2
real period=0.03
boolean ballLock=true
//endglobals from Velocity
//globals from Bullet:
constant boolean LIBRARY_Bullet=true
//endglobals from Bullet
//globals from Shooter:
constant boolean LIBRARY_Shooter=true
integer array shooters
integer shooternum
integer ksspot
//endglobals from Shooter
    // User-defined
boolean array udg_camera
unit array udg_hero
unit array udg_techlive
rect array udg_orirct
integer array udg_oriseq
integer udg_oriid= 0
unit array udg_portrait
integer udg_mtu= 0
integer udg_maxm= 0
integer udg_mti= 0
    // Generated
rect gg_rct_techunit= null
rect gg_rct_origin1= null
rect gg_rct_origin3= null
rect gg_rct_origin2= null
rect gg_rct_origin0= null
trigger gg_trg_initialize= null
trigger gg_trg_camera= null
trigger gg_trg_AnyUnitSpellEffectTrg= null
trigger gg_trg_bordercontrol= null
trigger gg_trg_EnemyBugSystem= null
trigger gg_trg_EnemyBugSystem2= null
trigger gg_trg_cantmove= null
trigger gg_trg_DeathEffect= null
trigger gg_trg_EnemyAbilityDisplay= null
trigger gg_trg_UpDialog= null
trigger gg_trg_Lose= null
trigger gg_trg_Win= null
trigger gg_trg_Leave= null
trigger gg_trg_Vector= null
trigger gg_trg_Velocity= null
trigger gg_trg_HashKeyManager= null
trigger gg_trg_TargetFliter= null
trigger gg_trg_RegisterM= null
trigger gg_trg_Damage= null
trigger gg_trg_VectorManager= null
trigger gg_trg_UnitList= null
trigger gg_trg_Bullet= null
trigger gg_trg_Shooter= null
trigger gg_trg_MonsterType= null
trigger gg_trg_Guns= null
trigger gg_trg_Attract= null
trigger gg_trg_Concurrent= null
trigger gg_trg_AIDS= null
trigger gg_trg_Event= null
trigger gg_trg_BulletSpell= null
trigger gg_trg_GravityClash= null
trigger gg_trg_leap= null
trigger gg_trg_energy= null
trigger gg_trg____________________003= null
trigger gg_trg____________________001= null
integer gk=- 1
hashtable ht= null
integer kbuldir
integer kbullif
integer kbuldam
integer kbuldamran
integer kbulraneff
integer kbulspe
integer kbulsou
integer kbulsiz
integer kbulgro
integer kbulris
integer kbullet
integer ranger='A00A'
integer meeler='A00B'
integer ktrgcon
real offrad=0.7854
real minrad=0.3927
integer kshoottrg
integer kst
integer kshootu
integer kstand
integer kshootdir
integer kshootnum
integer krecris
integer kautonum
integer kfirrat
integer krecoil
integer kmagsiz
integer krembul
integer krecover
integer kweapon
integer array guns
integer gunscount
integer kleapx
integer kleapy
trigger leaptrg
integer itemcount
integer itemid
integer ddrop
integer kdiid
integer kdinum
integer kdirec
integer droene
integer kdimax
integer nade='A005'
integer knadeu
integer nadeu='e001'
rect turec=gg_rct_techunit
integer kegycsu
trigger egytrg
group egygro
integer ninelife='A007'
group revgro
trigger revtrg
integer revive='A008'
integer laydown='A00I'
integer laydown2='B002'
integer kll
trigger lltrg
group llgro
trigger lifelowtrg
trigger eltrg
integer elability
integer elability2
integer elbuff
real gjsdf=0.2
integer kjsdu
integer kjsdv
integer kjsddir
integer kmt
integer kmu
integer kmc
integer kmris
integer mid='e003'
real minx
real maxx
real miny
real maxy
trigger aitrg
timer appt
timer attt
group appgro
group attgro
trigger astrg
trigger saitrg
integer poibuff1='A00D'
integer poibuff2='B001'
integer kpoisec
integer kpoidam
integer kpoit
integer kpoiu
trigger poitrg
integer speed='R005'
integer stamina='R001'
integer energy='R002'
dialog array td
button array upenergy
button array upstamina
button array upspeed
button array cancel
trigger uptrg
string egylbl="鑳介噺鍗囩骇+20 "
string stmlbl="鑰愪箙鍗囩骇+30 "
string spelbl="鏈哄姩澧炲己+8  "
string food="杩涘寲鐐?
string failmsg="|cffff0000娌℃湁瓒冲鐨勮繘鍖栫偣鏁帮紒|r"
trigger exptrg
integer kexp
integer sgc='A00K'
real sgc_dam=5
real sgc_idam=2.5
real sgc_kb=300
real sgc_ikb=150
string sgc_eff="Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"

trigger l__library_init

//JASSHelper struct globals:
constant integer si__AIDS_DEFAULT=1
constant integer si__EventReg=2
integer si__EventReg_F=0
integer si__EventReg_I=0
integer array si__EventReg_V
integer array s__EventReg_data
constant integer si__Event=3
integer si__Event_F=0
integer si__Event_I=0
integer array si__Event_V
trigger array s__Event_trig
integer array s__Event_next
integer s__Event_current
trigger s__Event_t
constant integer si__unitList=4
integer si__unitList_F=0
integer si__unitList_I=0
integer array si__unitList_V
unit array s___unitList_a
constant integer s___unitList_a_size=5
integer array s__unitList_a
integer array s__unitList_n
constant integer si__vector=6
integer si__vector_F=0
integer si__vector_I=0
integer array si__vector_V
real array s__vector_x
real array s__vector_y
constant integer si__att2dth=7
integer si__att2dth_F=0
integer si__att2dth_I=0
integer array si__att2dth_V
unit array s__att2dth_s
unit array s__att2dth_u
real array s__att2dth_str
timer array s__att2dth_t
integer array s__att2dth_spot
constant integer si__trc2dth=8
integer si__trc2dth_F=0
integer si__trc2dth_I=0
integer array si__trc2dth_V
unit array s__trc2dth_s
unit array s__trc2dth_u
real array s__trc2dth_str
timer array s__trc2dth_t
integer array s__trc2dth_spot
real array s__trc2dth_tstr
real array s__trc2dth_tdir
real array s__trc2dth_trange
constant integer si__Damage___Detector=9
integer s__Damage___Detector_AIDS_DELEGATE=0
boolean array s__Damage___Detector_AIDS_instanciated
conditionfunc s__Damage___Detector_ACTIONS_COND
trigger array s__Damage___Detector_t
constant integer si__Damage___InitStruct=10
constant integer si__ball=11
integer si__ball_F=0
integer si__ball_I=0
integer array si__ball_V
integer array s__ball_v
integer array s__ball_ctype
real array s__ball_m
string array s__ball_eff
real array s__ball_crange
real array s__ball_dam
real array s__ball_brange
real array s__ball_kb
boolean array s__ball_fly
integer array s__ball_life
integer array s__ball_l
unit array s__ball_u
integer array s__ball_spot
constant integer si__shooter=12
integer si__shooter_F=0
integer si__shooter_I=0
integer array si__shooter_V
integer array s__shooter_spot
unit array s__shooter_hero
integer array s__shooter_bid
real array s__shooter_speed
real array s__shooter_dam
real array s__shooter_sr
integer array s__shooter_total
integer array s__shooter_sn
real array s__shooter_rdir
real array s__shooter_dir
timer array s__shooter_t
trigger st__unitList_onDestroy
trigger st__vector_setLength
trigger st__att2dth_move
trigger st__att2dth_onDestroy
trigger st__att2dth_destroy
trigger st__trc2dth_move
trigger st__trc2dth_onDestroy
trigger st__trc2dth_destroy
trigger st__Damage___Detector_AIDS_onCreate
trigger st__Damage___Detector_AIDS_onDestroy
trigger st__Damage___Detector_AIDS_onInit
trigger st__ball_move
trigger st__ball_create
trigger st__ball_onDestroy
trigger st__ball_destroy
trigger st__shooter_shoot
trigger st__shooter_create
trigger st__shooter_onDestroy
trigger st__shooter_destroy
real f__arg_real1
real f__arg_real2
real f__arg_real3
real f__arg_real4
real f__arg_real5
unit f__arg_unit1
integer f__arg_integer1
integer f__arg_integer2
integer f__arg_integer3
integer f__arg_this
integer f__result_integer

endglobals


//Generated method caller for shooter.shoot
function sc__shooter_shoot takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__shooter_shoot)
endfunction

//Generated method caller for shooter.create
function sc__shooter_create takes unit hero,integer bid,real speed,real dam,real sr,integer sn,integer total,real rdir,real dir returns integer
    set f__arg_unit1=hero
    set f__arg_integer1=bid
    set f__arg_real1=speed
    set f__arg_real2=dam
    set f__arg_real3=sr
    set f__arg_integer2=sn
    set f__arg_integer3=total
    set f__arg_real4=rdir
    set f__arg_real5=dir
    call TriggerEvaluate(st__shooter_create)
 return f__result_integer
endfunction

//Generated method caller for shooter.onDestroy
function sc__shooter_onDestroy takes integer this returns nothing
            set s__shooter_hero[this]=null
            call RemoveSavedInteger(ht, GetHandleId(s__shooter_t[this]), ksspot)
            call DestroyTimer(s__shooter_t[this])
            set shooternum=shooternum - 1
            set shooters[s__shooter_spot[this]]=shooters[shooternum]
            set s__shooter_spot[shooters[shooternum]]=s__shooter_spot[this]
            set s__shooter_t[this]=null
endfunction

//Generated allocator of shooter
function s__shooter__allocate takes nothing returns integer
 local integer this=si__shooter_F
    if (this!=0) then
        set si__shooter_F=si__shooter_V[this]
    else
        set si__shooter_I=si__shooter_I+1
        set this=si__shooter_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__shooter_V[this]=-1
 return this
endfunction

//Generated destructor of shooter
function sc__shooter_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__shooter_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__shooter_onDestroy)
    set si__shooter_V[this]=si__shooter_F
    set si__shooter_F=this
endfunction

//Generated method caller for ball.move
function sc__ball_move takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ball_move)
endfunction

//Generated method caller for ball.create
function sc__ball_create takes unit u,real dam,real dir,real speed returns integer
    set f__arg_unit1=u
    set f__arg_real1=dam
    set f__arg_real2=dir
    set f__arg_real3=speed
    call TriggerEvaluate(st__ball_create)
 return f__result_integer
endfunction

//Generated method caller for ball.onDestroy
function sc__ball_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__ball_onDestroy)
endfunction

//Generated allocator of ball
function s__ball__allocate takes nothing returns integer
 local integer this=si__ball_F
    if (this!=0) then
        set si__ball_F=si__ball_V[this]
    else
        set si__ball_I=si__ball_I+1
        set this=si__ball_I
    endif
    if (this>8190) then
        return 0
    endif

   set s__ball_ctype[this]=CTYPE_NONE
   set s__ball_m[this]=5
   set s__ball_eff[this]=""
   set s__ball_crange[this]=75
   set s__ball_dam[this]=0
   set s__ball_brange[this]=150
   set s__ball_kb[this]=10
   set s__ball_fly[this]=false
   set s__ball_life[this]=99999
    set si__ball_V[this]=-1
 return this
endfunction

//Generated destructor of ball
function sc__ball_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ball_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__ball_onDestroy)
    set si__ball_V[this]=si__ball_F
    set si__ball_F=this
endfunction

//Generated method caller for Damage___Detector.AIDS_onCreate
function sc__Damage___Detector_AIDS_onCreate takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Damage___Detector_AIDS_onCreate)
endfunction

//Generated method caller for Damage___Detector.AIDS_onDestroy
function sc__Damage___Detector_AIDS_onDestroy takes integer this returns nothing
            call DestroyTrigger(s__Damage___Detector_t[this])
endfunction

//Generated method caller for Damage___Detector.AIDS_onInit
function sc__Damage___Detector_AIDS_onInit takes nothing returns nothing
    call TriggerEvaluate(st__Damage___Detector_AIDS_onInit)
endfunction

//Generated method caller for trc2dth.move
function sc__trc2dth_move takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__trc2dth_move)
endfunction

//Generated method caller for trc2dth.onDestroy
function sc__trc2dth_onDestroy takes integer this returns nothing
            set trc2dthsn=trc2dthsn - 1
            set trc2dths[s__trc2dth_spot[this]]=trc2dths[trc2dthsn]
            set s__trc2dth_spot[trc2dths[trc2dthsn]]=s__trc2dth_spot[this]
            call RemoveSavedInteger(ht, GetHandleId(s__trc2dth_t[this]), katt)
            call DestroyTimer(s__trc2dth_t[this])
            set s__trc2dth_t[this]=null
            set s__trc2dth_u[this]=null
            set s__trc2dth_s[this]=null
            call BJDebugMsg("trc2dthsn " + I2S(trc2dthsn))
endfunction

//Generated allocator of trc2dth
function s__trc2dth__allocate takes nothing returns integer
 local integer this=si__trc2dth_F
    if (this!=0) then
        set si__trc2dth_F=si__trc2dth_V[this]
    else
        set si__trc2dth_I=si__trc2dth_I+1
        set this=si__trc2dth_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__trc2dth_V[this]=-1
 return this
endfunction

//Generated destructor of trc2dth
function sc__trc2dth_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__trc2dth_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__trc2dth_onDestroy)
    set si__trc2dth_V[this]=si__trc2dth_F
    set si__trc2dth_F=this
endfunction

//Generated method caller for att2dth.move
function sc__att2dth_move takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__att2dth_move)
endfunction

//Generated method caller for att2dth.onDestroy
function sc__att2dth_onDestroy takes integer this returns nothing
            set att2dthsn=att2dthsn - 1
            set att2dths[s__att2dth_spot[this]]=att2dths[att2dthsn]
            set s__att2dth_spot[att2dths[att2dthsn]]=s__att2dth_spot[this]
            call RemoveSavedInteger(ht, GetHandleId(s__att2dth_t[this]), katt)
            call DestroyTimer(s__att2dth_t[this])
            set s__att2dth_t[this]=null
            set s__att2dth_u[this]=null
            set s__att2dth_s[this]=null
            call BJDebugMsg("att2dthsn " + I2S(att2dthsn))
endfunction

//Generated allocator of att2dth
function s__att2dth__allocate takes nothing returns integer
 local integer this=si__att2dth_F
    if (this!=0) then
        set si__att2dth_F=si__att2dth_V[this]
    else
        set si__att2dth_I=si__att2dth_I+1
        set this=si__att2dth_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__att2dth_V[this]=-1
 return this
endfunction

//Generated destructor of att2dth
function sc__att2dth_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__att2dth_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__att2dth_onDestroy)
    set si__att2dth_V[this]=si__att2dth_F
    set si__att2dth_F=this
endfunction

//Generated method caller for vector.setLength
function sc__vector_setLength takes integer this,real length returns nothing
            local real l= SquareRoot(s__vector_x[this] * s__vector_x[this] + s__vector_y[this] * s__vector_y[this])
            if l == 0.0 then
                return
            endif
            set l=length / l
            set s__vector_x[this]=s__vector_x[this] * l
            set s__vector_y[this]=s__vector_y[this] * l
endfunction

//Generated allocator of vector
function s__vector__allocate takes nothing returns integer
 local integer this=si__vector_F
    if (this!=0) then
        set si__vector_F=si__vector_V[this]
    else
        set si__vector_I=si__vector_I+1
        set this=si__vector_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__vector_V[this]=-1
 return this
endfunction

//Generated destructor of vector
function s__vector_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__vector_V[this]!=-1) then
        return
    endif
    set si__vector_V[this]=si__vector_F
    set si__vector_F=this
endfunction

//Generated method caller for unitList.onDestroy
function sc__unitList_onDestroy takes integer this returns nothing
            local integer i=0
            loop
                exitwhen i >= s__unitList_n[this]
                set s___unitList_a[s__unitList_a[this]+i]=null
                set i=i + 1
            endloop
endfunction

//Generated allocator of unitList
function s__unitList__allocate takes nothing returns integer
 local integer this=si__unitList_F
    if (this!=0) then
        set si__unitList_F=si__unitList_V[this]
    else
        set si__unitList_I=si__unitList_I+1
        set this=si__unitList_I
    endif
    if (this>1637) then
        return 0
    endif
    set s__unitList_a[this]=(this-1)*5
   set s__unitList_n[this]=0
    set si__unitList_V[this]=-1
 return this
endfunction

//Generated destructor of unitList
function sc__unitList_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__unitList_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__unitList_onDestroy)
    set si__unitList_V[this]=si__unitList_F
    set si__unitList_F=this
endfunction

//Generated allocator of Event
function s__Event__allocate takes nothing returns integer
 local integer this=si__Event_F
    if (this!=0) then
        set si__Event_F=si__Event_V[this]
    else
        set si__Event_I=si__Event_I+1
        set this=si__Event_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Event_V[this]=-1
 return this
endfunction

//Generated destructor of Event
function s__Event_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Event_V[this]!=-1) then
        return
    endif
    set si__Event_V[this]=si__Event_F
    set si__Event_F=this
endfunction

//Generated allocator of EventReg
function s__EventReg__allocate takes nothing returns integer
 local integer this=si__EventReg_F
    if (this!=0) then
        set si__EventReg_F=si__EventReg_V[this]
    else
        set si__EventReg_I=si__EventReg_I+1
        set this=si__EventReg_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__EventReg_V[this]=-1
 return this
endfunction

//Generated destructor of EventReg
function s__EventReg_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__EventReg_V[this]!=-1) then
        return
    endif
    set si__EventReg_V[this]=si__EventReg_F
    set si__EventReg_F=this
endfunction

//library AIDS:
    //==============================================================================
    // Configurables
    //

    constant function AIDS___UnitIndexingFilter takes unit u returns boolean
        return true
    endfunction
    
    //==============================================================================
    // System code
    //
    
    //==============================================================================
    
    //==============================================================================
    
    //==============================================================================
    
    constant function AIDS_GetEnteringIndexUnit takes nothing returns unit
        return AIDS___ARStackUnit[AIDS___ARStackLevel]
    endfunction
    
    function AIDS_GetIndexOfEnteringUnit takes nothing returns integer
        // Called in AIDS structs when units do not pass the initial AIDS filter.
        
        if AIDS___ARStackIndex[AIDS___ARStackLevel] == 0 then
            // Get new index, from recycler first, else new.
            // Store the current index on the (new) top level of the AR stack.
            if AIDS___MaxRecycledIndex == 0 then // Get new.
set AIDS___MaxIndex=AIDS___MaxIndex + 1
                set AIDS___ARStackIndex[AIDS___ARStackLevel]=AIDS___MaxIndex
            else // Get from recycle stack.
set AIDS___ARStackIndex[AIDS___ARStackLevel]=AIDS___RecycledIndex[AIDS___MaxRecycledIndex]
                set AIDS___MaxRecycledIndex=AIDS___MaxRecycledIndex - 1
            endif
            
            // Store index on unit.
            call SetUnitUserData(AIDS___ARStackUnit[AIDS___ARStackLevel], AIDS___ARStackIndex[AIDS___ARStackLevel])
            set AIDS___IndexUnit[AIDS___ARStackIndex[AIDS___ARStackLevel]]=AIDS___ARStackUnit[AIDS___ARStackLevel]
            
            // Add index to recycle list.
            set AIDS___MaxDecayingIndex=AIDS___MaxDecayingIndex + 1
            set AIDS___DecayingIndex[AIDS___MaxDecayingIndex]=AIDS___ARStackIndex[AIDS___ARStackLevel]
        endif
        
        return AIDS___ARStackIndex[AIDS___ARStackLevel]
    endfunction
    
    constant function AIDS_GetIndexOfEnteringUnitAllocated takes nothing returns integer
        // Called in AIDS structs when units have passed the initial AIDS filter.
        return AIDS___ARStackIndex[AIDS___ARStackLevel]
    endfunction
    constant function AIDS_GetDecayingIndex takes nothing returns integer
        return AIDS___DecayingIndex[AIDS___DecayChecker]
    endfunction
    
    //==============================================================================
    
    function AIDS_RegisterOnEnter takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS___OnEnter, b)
    endfunction
    function AIDS_RegisterOnEnterAllocated takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS___OnEnterAllocated, b)
    endfunction
    function AIDS_RegisterOnDeallocate takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS___OnDeallocate, b)
    endfunction
    
    //==============================================================================
    function GetIndexUnit takes integer index returns unit
        
        return AIDS___IndexUnit[index]
    endfunction
    
    function GetUnitId takes unit u returns integer
        
        return GetUnitUserData(u)
    endfunction
    
    function GetUnitIndex takes unit u returns integer
set AIDS___getindex=GetUnitId(u)
        
        if AIDS___getindex == 0 then
            // Get new index, from recycler first, else new.
            // Store the current index in getindex.
            if AIDS___MaxRecycledIndex == 0 then // Get new.
set AIDS___MaxIndex=AIDS___MaxIndex + 1
                set AIDS___getindex=AIDS___MaxIndex
            else // Get from recycle stack.
set AIDS___getindex=AIDS___RecycledIndex[AIDS___MaxRecycledIndex]
                set AIDS___MaxRecycledIndex=AIDS___MaxRecycledIndex - 1
            endif
            
            // Store index on unit.
            call SetUnitUserData(u, AIDS___getindex)
            set AIDS___IndexUnit[AIDS___getindex]=u
            
            // Add index to recycle list.
            set AIDS___MaxDecayingIndex=AIDS___MaxDecayingIndex + 1
            set AIDS___DecayingIndex[AIDS___MaxDecayingIndex]=AIDS___getindex
            
            // Do not fire things here. No AIDS structs will be made at this point.
        endif
        
        return AIDS___getindex
    endfunction
    
    //==============================================================================
    function AIDS_AddLock takes integer index returns nothing
        set AIDS___LockLevel[index]=AIDS___LockLevel[index] + 1
    endfunction
    function AIDS_RemoveLock takes integer index returns nothing
        set AIDS___LockLevel[index]=AIDS___LockLevel[index] - 1
    endfunction
    
    //==============================================================================
    function AIDS___PeriodicRecycler takes nothing returns nothing
        if AIDS___MaxDecayingIndex > 0 then
            set AIDS___DecayChecker=AIDS___DecayChecker + 1
            if AIDS___DecayChecker > AIDS___MaxDecayingIndex then
                set AIDS___DecayChecker=1
            endif
            if GetUnitUserData(AIDS___IndexUnit[AIDS___DecayingIndex[AIDS___DecayChecker]]) == 0 then
            if AIDS___LockLevel[AIDS___DecayingIndex[AIDS___DecayChecker]] == 0 then
                
                // Fire things.
                call TriggerEvaluate(AIDS___OnDeallocate)
                
                // Add the index to the recycler stack.
                set AIDS___MaxRecycledIndex=AIDS___MaxRecycledIndex + 1
                set AIDS___RecycledIndex[AIDS___MaxRecycledIndex]=AIDS___DecayingIndex[AIDS___DecayChecker]
                
                // Null the unit.
                set AIDS___IndexUnit[AIDS___DecayingIndex[AIDS___DecayChecker]]=null
                
                // Remove index from decay list.
                set AIDS___DecayingIndex[AIDS___DecayChecker]=AIDS___DecayingIndex[AIDS___MaxDecayingIndex]
                set AIDS___MaxDecayingIndex=AIDS___MaxDecayingIndex - 1
                
            endif
            endif
        endif
    endfunction
    
    //==============================================================================
    function AIDS_IndexEnum takes nothing returns boolean
// Start by adding another level on the AR stack (for recursion's sake).
set AIDS___ARStackLevel=AIDS___ARStackLevel + 1
        
        // Store the current unit on the (new) top level of the AR stack.
        set AIDS___ARStackUnit[AIDS___ARStackLevel]=GetFilterUnit()
        
        if AIDS___UnitIndexingFilter(AIDS___ARStackUnit[AIDS___ARStackLevel]) then
            
            // Get new index, from recycler first, else new.
            // Store the current index on the (new) top level of the AR stack.
            if AIDS___MaxRecycledIndex == 0 then // Get new.
set AIDS___MaxIndex=AIDS___MaxIndex + 1
                set AIDS___ARStackIndex[AIDS___ARStackLevel]=AIDS___MaxIndex
            else // Get from recycle stack.
set AIDS___ARStackIndex[AIDS___ARStackLevel]=AIDS___RecycledIndex[AIDS___MaxRecycledIndex]
                set AIDS___MaxRecycledIndex=AIDS___MaxRecycledIndex - 1
            endif
            
            // Store index on unit.
            call SetUnitUserData(AIDS___ARStackUnit[AIDS___ARStackLevel], AIDS___ARStackIndex[AIDS___ARStackLevel])
            set AIDS___IndexUnit[AIDS___ARStackIndex[AIDS___ARStackLevel]]=AIDS___ARStackUnit[AIDS___ARStackLevel]
            
            // Add index to recycle list.
            set AIDS___MaxDecayingIndex=AIDS___MaxDecayingIndex + 1
            set AIDS___DecayingIndex[AIDS___MaxDecayingIndex]=AIDS___ARStackIndex[AIDS___ARStackLevel]
            
            // Fire things.
            call TriggerEvaluate(AIDS___OnEnter)
            
        else
            
            // The unit did not pass the filters, so does not need to be auto indexed.
            // However, for certain AIDS structs, it may still require indexing.
            // These structs may index the unit on their creation.
            // We flag that an index must be assigned by setting the current index to 0.
            set AIDS___ARStackIndex[AIDS___ARStackLevel]=0
            
            // Fire things.
            call TriggerEvaluate(AIDS___OnEnter)
            
        endif
        
        // Decrement the stack.
        set AIDS___ARStackLevel=AIDS___ARStackLevel - 1
        
        return false
    endfunction
    
    //==============================================================================
    function AIDS___InitAIDS takes nothing returns nothing
        local region r=CreateRegion()
        
        local group g=CreateGroup()
        local integer n=15
        
        // This must be done first, due to recursion. :)
        call RegionAddRect(r, bj_mapInitialPlayableArea)
        call TriggerRegisterEnterRegion(CreateTrigger(), r, Condition(function AIDS_IndexEnum))
        set r=null
        
        loop
            call GroupEnumUnitsOfPlayer(g, Player(n), Condition(function AIDS_IndexEnum))
            //Enum every non-filtered unit on the map during initialization and assign it a unique
            //index. By using GroupEnumUnitsOfPlayer, even units with Locust can be detected.
            exitwhen n == 0
            set n=n - 1
        endloop
        call DestroyGroup(g)
        set g=null
        
        call TimerStart(CreateTimer(), AIDS___PERIOD, true, function AIDS___PeriodicRecycler)
    endfunction
    
    //==============================================================================
        function s__AIDS_DEFAULT_AIDS_onCreate takes integer this returns nothing
        endfunction
        function s__AIDS_DEFAULT_AIDS_onDestroy takes integer this returns nothing
        endfunction
        
        function s__AIDS_DEFAULT_AIDS_filter takes unit u returns boolean
            return AIDS___UnitIndexingFilter(u)
        endfunction
        
        function s__AIDS_DEFAULT_AIDS_onInit takes nothing returns nothing
        endfunction
    
    //===========================================================================
    //  Never create or destroy AIDS structs directly.
    //  Also, do not initialise members except by using the AIDS_onCreate method.
    //===========================================================================

//library AIDS ends
//library AnyUnitSpellEffectTrg:
        
    function AnyUnitSpellEffectTrgInit takes nothing returns nothing
        set gausetrg=CreateTrigger()
        call TriggerRegisterAnyUnitEventBJ(gausetrg, EVENT_PLAYER_UNIT_SPELL_EFFECT)
        set gausctrg=CreateTrigger()
        call TriggerRegisterAnyUnitEventBJ(gausctrg, EVENT_PLAYER_UNIT_SPELL_CHANNEL)
    endfunction
    
    

//library AnyUnitSpellEffectTrg ends
//library Concurrent:
    function AskLock takes boolean lock returns boolean
        local integer i=0
        loop
            exitwhen lock
            set i=i + 1
            if i > 1000000 then
                return false
            endif
        endloop
        return true
    endfunction
    function Lock takes boolean lock returns boolean
        set lock=false
        return lock
    endfunction
    function UnLock takes boolean lock returns boolean
        set lock=true
        return lock
    endfunction

//library Concurrent ends
//library Event:
    ///////////////
    // EventRegs //
    ////////////////////////////////////////////////////////////////////////////
    // For reading this far, you can learn one thing more.
    // Unlike normal Warcraft III events, you can attach to Event registries.
    // 
    // Event Registries are registrations of one trigger on one event.
    // These cannot be created or destroyed, just attached to.
    //
    // It is VERY efficient for loading and saving data.
    // 
    //  Functions:
    //         - set eventReg.data = someStruct --> Store data.
    //         - eventReg.data                  --> Retreive data.
    //         - Event.getTriggeringEventReg()  --> Get the triggering EventReg.
    // 
        function s__EventReg_clear takes integer this returns nothing
            set s__EventReg_data[this]=0
        endfunction
    
        function s__Event_create takes nothing returns integer
            local integer this=s__Event__allocate()
            set s__Event_next[this]=0
            return this
        endfunction
        function s__Event_getTriggeringEventReg takes nothing returns integer
            return s__Event_current
        endfunction
        function s__Event_fire takes integer this returns nothing
            // this = last.
            loop
                set s__Event_current=s__Event_next[this]
                exitwhen s__Event_current == 0
                set s__Event_t=s__Event_trig[s__Event_current]
                if IsTriggerEnabled(s__Event_t) then
                    if TriggerEvaluate(s__Event_t) then
                        call TriggerExecute(s__Event_t)
                    endif
                    set this=s__Event_current
                else
                    call EnableTrigger(s__Event_t) // Was trigger destroyed?
if IsTriggerEnabled(s__Event_t) then
                        call DisableTrigger(s__Event_t)
                        set this=s__Event_current
                    else // If trigger destroyed...
set s__Event_trig[s__Event_current]=null
                        set s__Event_next[this]=s__Event_next[s__Event_current]
                        call s__Event_deallocate(s__Event_current)
                    endif
                endif
            endloop
        endfunction
        function s__Event_register takes integer this,trigger t returns integer
            local integer new=s__Event__allocate()
            set s__Event_next[new]=s__Event_next[this]
            set s__Event_trig[new]=t
            set s__Event_next[this]=new
            call s__EventReg_clear((new))
            return new
        endfunction
        function s__Event_chainDestroy takes integer this returns nothing
            loop
                call s__Event_deallocate(this)
                set this=s__Event_next[this]
                exitwhen this == 0
                set s__Event_trig[this]=null
            endloop
        endfunction
    
    /////////////////////////////////////////////////////
    // Demonstration Functions & Alternative Interface //
    ////////////////////////////////////////////////////////////////////////////
    // What this would look like in normal WC3 style JASS (should all inline).
    // 
    function CreateEvent takes nothing returns integer
        return s__Event_create()
    endfunction
    function DestroyEvent takes integer whichEvent returns nothing
        call s__Event_chainDestroy(whichEvent)
    endfunction
    function FireEvent takes integer whichEvent returns nothing
        call s__Event_fire(whichEvent)
    endfunction
    function TriggerRegisterEvent takes trigger whichTrigger,integer whichEvent returns integer
        return s__Event_register(whichEvent,whichTrigger)
    endfunction
    
    // And for EventRegs...
    function SetEventRegData takes integer whichEventReg,integer data returns nothing
        set s__EventReg_data[whichEventReg]=data
    endfunction
    function GetEventRegData takes integer whichEventReg returns integer
        return s__EventReg_data[whichEventReg]
    endfunction
    function GetTriggeringEventReg takes nothing returns integer
        return s__Event_getTriggeringEventReg()
    endfunction

//library Event ends
//library Guns:

//library Guns ends
//library HashKeyManager:
    function GetNewKey takes nothing returns integer
        set gk=gk + 1
        return gk - 1
    endfunction

//library HashKeyManager ends
//library MonsterType:

//library MonsterType ends
//library TargetFliter:
    function IsLiveEnemy takes unit s,unit u returns boolean
        return IsUnitAliveBJ(u) and IsUnitEnemy(s, GetOwningPlayer(u))
    endfunction
    
    function HasLiveEnemyInRange takes unit s,real r returns boolean
        local group ydl_group
        local unit ydl_unit
        local boolean result=false
        set ydl_group=CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r, null)
        loop
            set ydl_unit=FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null or result
            call GroupRemoveUnit(ydl_group, ydl_unit)
            if IsLiveEnemy(s , ydl_unit) then
                set result=true
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group=null
        set ydl_unit=null
        return result
    endfunction
    

//library TargetFliter ends
//library UnitList:
        
        function s__unitList_addUnit takes integer this,unit u returns nothing
                set s___unitList_a[s__unitList_a[this]+s__unitList_n[this]]=u
                set s__unitList_n[this]=s__unitList_n[this] + 1
            call BJDebugMsg("unit list num " + I2S(s__unitList_n[this]))
        endfunction
        
        function s__unitList_hasUnit takes integer this,unit u returns boolean
            local integer i=0
            loop
                exitwhen i >= s__unitList_n[this]
                if s___unitList_a[s__unitList_a[this]+i] == u then
                    return true
                endif
                set i=i + 1
            endloop
            return false
        endfunction
        
        function s__unitList_removeUnit takes integer this,unit u returns nothing
            local integer i=0
            loop
                exitwhen i >= s__unitList_n[this]
                if s___unitList_a[s__unitList_a[this]+i] == u then
                    set s__unitList_n[this]=s__unitList_n[this] - 1
                    set s___unitList_a[s__unitList_a[this]+i]=s___unitList_a[s__unitList_a[this]+s__unitList_n[this]]
                    set i=s__unitList_n[this]
                endif
                set i=i + 1
            endloop
            call BJDebugMsg("unit list num " + I2S(s__unitList_n[this]))
        endfunction
        
        function s__unitList_create takes nothing returns integer
            local integer l=s__unitList__allocate()
            set s__unitList_n[l]=0
            return l
        endfunction
        
        function s__unitList_onDestroy takes integer this returns nothing
            local integer i=0
            loop
                exitwhen i >= s__unitList_n[this]
                set s___unitList_a[s__unitList_a[this]+i]=null
                set i=i + 1
            endloop
        endfunction

//Generated destructor of unitList
function s__unitList_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__unitList_V[this]!=-1) then
        return
    endif
    call s__unitList_onDestroy(this)
    set si__unitList_V[this]=si__unitList_F
    set si__unitList_F=this
endfunction
        

//library UnitList ends
//library Vector:
//*****************************************************************
//*  VECTOR LIBRARY
//*
//*  written by: Anitarf
//*
//*  The library contains a struct named vector, which represents a
//*  point in 3D space. As such, it has three real members, one for
//*  each coordinate: x, y, z. It also has the following methods:
//*
//*        static method create takes real x, real y, real z returns vector
//*  Creates a new vector with the given coordinates.
//*
//*        method getLength takes nothing returns real
//*  Returns the length of the vector it is called on.
//*
//*        static method sum takes vector augend, vector addend returns vector
//*  Returns the sum of two vectors as a new vector.
//*
//*        method add takes vector addend returns nothing
//*  Similar to sum, except that it doesn't create a new vector for the result,
//*  but changes the vector it is called on by adding the "added" to it.
//*
//*        static method difference takes vector minuend, vector subtrahend returns vector
//*  Returns the difference between two vectors as a new vector.
//*
//*        method subtract takes vector subtrahend returns nothing
//*  Similar to difference, except that it doesn't create a new vector for the result,
//*  but changes the vector it is called on by subtracting the "subtrahend" from it.
//*
//*        method scale takes real factor returns nothing
//*  Scales the vector it is called on by the given factor.
//*
//*        method setLength takes real length returns nothing
//*  Sets the length of the vector it is called on to the given value, maintaining it's orientation.
//*
//*        static method dotProduct takes vector a, vector b returns real
//*  Calculates the dot product (also called scalar product) of two vectors.
//*
//*        static method crossProduct takes vector a, vector b returns vector
//*  Calculates the cross product (also called vector product) of two vectors
//*  and returns it as a new vector.
//*
//*        static method tripleProductScalar takes vector a, vector b, vector c returns real
//*  Calculates the triple scalar product of three vectors.
//*
//*        static method tripleProductVector takes vector a, vector b, vector c returns vector
//*  Calculates the triple vector product of three vectors and returns it as a new vector.
//*
//*
//*        static method projectionVector takes vector projected, vector direction returns vector
//*  Calculates the projection of the vector "projected" onto the vector "direction"
//*  and returns it as a new vector.
//*  Returns null if the vector direction has a length of 0.
//*
//*        method projectVector takes vector direction returns nothing
//*  Projects the vector it is called on onto the vector "direction".
//*  Does nothing if the vector "direction" has a length of 0.
//*
//*        static method projectionPlane takes vector projected, vector normal returns vector
//*  Calculates the projection of the vector projected onto a plane defined by
//*  it's normal vector and returns it as a new vector.
//*  Returns null if the vector "normal" has a length of 0.
//*
//*        method projectPlane takes vector normal returns nothing
//*  Projects the vector it is called on onto a plane defined by it's normal vector.
//*  Does nothing if the vector "normal" has a length of 0.
//*
//*        static method getAngle takes vector a, vector b returns real
//*  Returns the angle between two vectors, in radians, returns a value between 0 and pi.
//*  Returns 0.0 if any of the vectors are 0 units long.
//*
//*        method rotate takes vector axis, real angle returns nothing
//*  Rotates the vector it is called on around the axis defined by the vector "axis"
//*  by the given angle, which should be input in radians.
//*  Does nothing if axis is 0 units long.
//*
//*
//*        static method createTerrainPoint takes real x, real y returns vector
//*  Creates a vector to the given terrain coordinate, taking it's z height into account.
//*
//*        method getTerrainPoint takes real x, real y returns nothing
//*  Sets the vector it is called on to the given terrain coordinate, taking it's z height into account.
//*
//*        static method createTerrainNormal takes real x, real y, real sampleRadius returns vector
//*  Creates the normal vector of the terrain at given coordinates. "sampleRadius" defines
//*  how far apart the reference points will be, if they are further apart, the result will
//*  be an impression of smoother terrain; normaly the value should be between 0 and 128.
//*
//*        method getTerrainNormal takes real x, real y, real sampleRadius returns nothing
//*  Sets the vector it is called on to the normal of the terrain at given coordinates.
//*
//*
//*        method isInCylinder takes vector cylinderOrigin, vector cylinderHeight, real cylinderRadius returns boolean
//*  Determines if a point is within a given cylinder. The cylinder's origin vector points
//*  to the center of one of the two paralel circular sides, and the height vector points
//*  from the origin point to the center of the other of the two paralel circular sides.
//*  Returns false if the point is not in the cylinder or if the vector cylinderHeight is 0 units long.
//*
//*        method isInCone takes vector coneOrigin, vector coneHeight, real coneRadius returns boolean
//*  Determines if a point is within a given cone. The cone's origin vector points to the
//*  center of the circular side, and the height vector points from the origin point to
//*  the tip of the cone.
//*  Returns false if the point is not in the cylinder or if the vector coneHeight is 0 units long.
//*
//*        method isInSphere takes vector sphereOrigin, real sphereRadius returns boolean
//*  Determines if a point is within a give sphere. The sphere's origin vector points to the
//*  center of the sphere.
//*  Returns false if the point is not in the sphere.
//*****************************************************************
        
        function s__vector_create takes real x,real y returns integer
            local integer v= s__vector__allocate()
            set s__vector_x[v]=x
            set s__vector_y[v]=y
            return v
        endfunction
        
        function s__vector_getLength takes integer this returns real
          return SquareRoot(s__vector_x[this] * s__vector_x[this] + s__vector_y[this] * s__vector_y[this])
        endfunction
        
        function s__vector_sum takes integer augend,integer addend returns integer
            local integer v= s__vector__allocate()
            set s__vector_x[v]=s__vector_x[augend] + s__vector_x[addend]
            set s__vector_y[v]=s__vector_y[augend] + s__vector_y[addend]
            return v
        endfunction
        function s__vector_add takes integer this,integer addend returns nothing
            set s__vector_x[this]=s__vector_x[this] + s__vector_x[addend]
            set s__vector_y[this]=s__vector_y[this] + s__vector_y[addend]
        endfunction
        
        function s__vector_difference takes integer minuend,integer subtrahend returns integer
            local integer v= s__vector__allocate()
            set s__vector_x[v]=s__vector_x[minuend] - s__vector_x[subtrahend]
            set s__vector_y[v]=s__vector_y[minuend] - s__vector_y[subtrahend]
            return v
        endfunction
        function s__vector_subtract takes integer this,integer subtrahend returns nothing
            set s__vector_x[this]=s__vector_x[this] - s__vector_x[subtrahend]
            set s__vector_y[this]=s__vector_y[this] - s__vector_y[subtrahend]
        endfunction
        
        function s__vector_scale takes integer this,real factor returns nothing
            set s__vector_x[this]=s__vector_x[this] * factor
            set s__vector_y[this]=s__vector_y[this] * factor
        endfunction
        
        function s__vector_subtractLength takes integer this,real length returns nothing
            call sc__vector_setLength(this,s__vector_getLength(this) - length)
        endfunction
        
        function s__vector_setLength takes integer this,real length returns nothing
            local real l= SquareRoot(s__vector_x[this] * s__vector_x[this] + s__vector_y[this] * s__vector_y[this])
            if l == 0.0 then
                return
            endif
            set l=length / l
            set s__vector_x[this]=s__vector_x[this] * l
            set s__vector_y[this]=s__vector_y[this] * l
        endfunction
        
        function s__vector_dotProduct takes integer a,integer b returns real
            return ( s__vector_x[a] * s__vector_x[b] + s__vector_y[a] * s__vector_y[b] )
        endfunction
        
// ================================================================
        function s__vector_projectionVector takes integer projected,integer direction returns integer
            local integer v= s__vector__allocate()
            local real l= s__vector_x[direction] * s__vector_x[direction] + s__vector_y[direction] * s__vector_y[direction]
            if l == 0.0 then
                call s__vector_deallocate(v)
                return null
            endif
            set l=( s__vector_x[projected] * s__vector_x[direction] + s__vector_y[projected] * s__vector_y[direction] ) / l
            set s__vector_x[v]=s__vector_x[direction] * l
            set s__vector_y[v]=s__vector_y[direction] * l
            return v
        endfunction
        function s__vector_projectVector takes integer this,integer direction returns nothing
            local real l= s__vector_x[direction] * s__vector_x[direction] + s__vector_y[direction] * s__vector_y[direction]
            if l == 0.0 then
                return
            endif
            set l=( s__vector_x[this] * s__vector_x[direction] + s__vector_y[this] * s__vector_y[direction] ) / l
            set s__vector_x[this]=s__vector_x[direction] * l
            set s__vector_y[this]=s__vector_y[direction] * l
        endfunction
        function s__vector_getAngle takes integer a,integer b returns real
            local real l= SquareRoot(s__vector_x[a] * s__vector_x[a] + s__vector_y[a] * s__vector_y[a]) * SquareRoot(s__vector_x[b] * s__vector_x[b] + s__vector_y[b] * s__vector_y[b])
            if l == 0 then
                return 0.0
            endif
            return Acos(( s__vector_x[a] * s__vector_x[b] + s__vector_y[a] * s__vector_y[b] ) / l) //angle is returned in radians
endfunction
        
        
        
 
// ================================================================
        function s__vector_isInSphere takes integer this,integer sphereOrigin,real sphereRadius returns boolean
            if sphereRadius * sphereRadius < ( ( s__vector_x[this] - s__vector_x[sphereOrigin] ) * ( s__vector_x[this] - s__vector_x[sphereOrigin] ) + ( s__vector_y[this] - s__vector_y[sphereOrigin] ) * ( s__vector_y[this] - s__vector_y[sphereOrigin] ) ) then
                return false
            endif
            return true
        endfunction
        

//library Vector ends
//library VectorManager:
    function AddVector takes unit u,real dir,real speed returns nothing
        local integer dec=GetHandleId(u)
        local integer i
        if HaveSavedInteger(ht, dec, kvel) then
            set i=LoadInteger(ht, dec, kvel)
            call s__vector_add(s__ball_v[balls[i]],s__vector_create(speed * Cos(dir) , speed * Sin(dir)))
        else
            call sc__ball_create(u , 0 , dir , speed)
        endif
    endfunction

//library VectorManager ends
//library YDWEBase:
//===========================================================================
//HashTable
//===========================================================================
//===========================================================================
//Return bug
//===========================================================================
function YDWEH2I takes handle h returns integer
    return GetHandleId(h)
endfunction
//清空
function YDWEFlushAllData takes nothing returns nothing
    call FlushParentHashtable(YDHT)
endfunction
function YDWEFlushMissionByInteger takes integer i returns nothing
    call FlushChildHashtable(YDHT, i)
endfunction
function YDWEFlushMissionByString takes string s returns nothing
    call FlushChildHashtable(YDHT, StringHash(s))
endfunction
function YDWEFlushStoredIntegerByInteger takes integer i,integer j returns nothing
    call RemoveSavedInteger(YDHT, i, j)
endfunction
function YDWEFlushStoredIntegerByString takes string s1,string s2 returns nothing
    call RemoveSavedInteger(YDHT, StringHash(s1), StringHash(s2))
endfunction
function YDWEHaveSavedIntegerByInteger takes integer i,integer j returns boolean
    return HaveSavedInteger(YDHT, i, j)
endfunction
function YDWEHaveSavedIntegerByString takes string s1,string s2 returns boolean
    return HaveSavedInteger(YDHT, StringHash(s1), StringHash(s2))
endfunction
//store and get integer
function YDWESaveIntegerByInteger takes integer pTable,integer pKey,integer i returns nothing
    call SaveInteger(YDHT, pTable, pKey, i)
endfunction
function YDWESaveIntegerByString takes string pTable,string pKey,integer i returns nothing
    call SaveInteger(YDHT, StringHash(pTable), StringHash(pKey), i)
endfunction
function YDWEGetIntegerByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT, pTable, pKey)
endfunction
function YDWEGetIntegerByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//store and get real
function YDWESaveRealByInteger takes integer pTable,integer pKey,real r returns nothing
    call SaveReal(YDHT, pTable, pKey, r)
endfunction
function YDWESaveRealByString takes string pTable,string pKey,real r returns nothing
    call SaveReal(YDHT, StringHash(pTable), StringHash(pKey), r)
endfunction
function YDWEGetRealByInteger takes integer pTable,integer pKey returns real
    return LoadReal(YDHT, pTable, pKey)
endfunction
function YDWEGetRealByString takes string pTable,string pKey returns real
    return LoadReal(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//store and get string
function YDWESaveStringByInteger takes integer pTable,integer pKey,string s returns nothing
    call SaveStr(YDHT, pTable, pKey, s)
endfunction
function YDWESaveStringByString takes string pTable,string pKey,string s returns nothing
    call SaveStr(YDHT, StringHash(pTable), StringHash(pKey), s)
endfunction
function YDWEGetStringByInteger takes integer pTable,integer pKey returns string
    return LoadStr(YDHT, pTable, pKey)
endfunction
function YDWEGetStringByString takes string pTable,string pKey returns string
    return LoadStr(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//store and get boolean
function YDWESaveBooleanByInteger takes integer pTable,integer pKey,boolean b returns nothing
    call SaveBoolean(YDHT, pTable, pKey, b)
endfunction
function YDWESaveBooleanByString takes string pTable,string pKey,boolean b returns nothing
    call SaveBoolean(YDHT, StringHash(pTable), StringHash(pKey), b)
endfunction
function YDWEGetBooleanByInteger takes integer pTable,integer pKey returns boolean
    return LoadBoolean(YDHT, pTable, pKey)
endfunction
function YDWEGetBooleanByString takes string pTable,string pKey returns boolean
    return LoadBoolean(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Unit
function YDWESaveUnitByInteger takes integer pTable,integer pKey,unit u returns nothing
    call SaveUnitHandle(YDHT, pTable, pKey, u)
endfunction
function YDWESaveUnitByString takes string pTable,string pKey,unit u returns nothing
    call SaveUnitHandle(YDHT, StringHash(pTable), StringHash(pKey), u)
endfunction
function YDWEGetUnitByInteger takes integer pTable,integer pKey returns unit
    return LoadUnitHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetUnitByString takes string pTable,string pKey returns unit
    return LoadUnitHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert UnitID
function YDWESaveUnitIDByInteger takes integer pTable,integer pKey,integer uid returns nothing
    call SaveInteger(YDHT, pTable, pKey, uid)
endfunction
function YDWESaveUnitIDByString takes string pTable,string pKey,integer uid returns nothing
    call SaveInteger(YDHT, StringHash(pTable), StringHash(pKey), uid)
endfunction
function YDWEGetUnitIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT, pTable, pKey)
endfunction
function YDWEGetUnitIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert AbilityID
function YDWESaveAbilityIDByInteger takes integer pTable,integer pKey,integer abid returns nothing
    call SaveInteger(YDHT, pTable, pKey, abid)
endfunction
function YDWESaveAbilityIDByString takes string pTable,string pKey,integer abid returns nothing
    call SaveInteger(YDHT, StringHash(pTable), StringHash(pKey), abid)
endfunction
function YDWEGetAbilityIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT, pTable, pKey)
endfunction
function YDWEGetAbilityIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Player
function YDWESavePlayerByInteger takes integer pTable,integer pKey,player p returns nothing
    call SavePlayerHandle(YDHT, pTable, pKey, p)
endfunction
function YDWESavePlayerByString takes string pTable,string pKey,player p returns nothing
    call SavePlayerHandle(YDHT, StringHash(pTable), StringHash(pKey), p)
endfunction
function YDWEGetPlayerByInteger takes integer pTable,integer pKey returns player
    return LoadPlayerHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetPlayerByString takes string pTable,string pKey returns player
    return LoadPlayerHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Item
function YDWESaveItemByInteger takes integer pTable,integer pKey,item it returns nothing
    call SaveItemHandle(YDHT, pTable, pKey, it)
endfunction
function YDWESaveItemByString takes string pTable,string pKey,item it returns nothing
    call SaveItemHandle(YDHT, StringHash(pTable), StringHash(pKey), it)
endfunction
function YDWEGetItemByInteger takes integer pTable,integer pKey returns item
    return LoadItemHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetItemByString takes string pTable,string pKey returns item
    return LoadItemHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert ItemID
function YDWESaveItemIDByInteger takes integer pTable,integer pKey,integer itid returns nothing
    call SaveInteger(YDHT, pTable, pKey, itid)
endfunction
function YDWESaveItemIDByString takes string pTable,string pKey,integer itid returns nothing
    call SaveInteger(YDHT, StringHash(pTable), StringHash(pKey), itid)
endfunction
function YDWEGetItemIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT, pTable, pKey)
endfunction
function YDWEGetItemIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Timer
function YDWESaveTimerByInteger takes integer pTable,integer pKey,timer t returns nothing
    call SaveTimerHandle(YDHT, pTable, pKey, t)
endfunction
function YDWESaveTimerByString takes string pTable,string pKey,timer t returns nothing
    call SaveTimerHandle(YDHT, StringHash(pTable), StringHash(pKey), t)
endfunction
function YDWEGetTimerByInteger takes integer pTable,integer pKey returns timer
    return LoadTimerHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTimerByString takes string pTable,string pKey returns timer
    return LoadTimerHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Trigger
function YDWESaveTriggerByInteger takes integer pTable,integer pKey,trigger trg returns nothing
    call SaveTriggerHandle(YDHT, pTable, pKey, trg)
endfunction
function YDWESaveTriggerByString takes string pTable,string pKey,trigger trg returns nothing
    call SaveTriggerHandle(YDHT, StringHash(pTable), StringHash(pKey), trg)
endfunction
function YDWEGetTriggerByInteger takes integer pTable,integer pKey returns trigger
    return LoadTriggerHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTriggerByString takes string pTable,string pKey returns trigger
    return LoadTriggerHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Location
function YDWESaveLocationByInteger takes integer pTable,integer pKey,location pt returns nothing
    call SaveLocationHandle(YDHT, pTable, pKey, pt)
endfunction
function YDWESaveLocationByString takes string pTable,string pKey,location pt returns nothing
    call SaveLocationHandle(YDHT, StringHash(pTable), StringHash(pKey), pt)
endfunction
function YDWEGetLocationByInteger takes integer pTable,integer pKey returns location
    return LoadLocationHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetLocationByString takes string pTable,string pKey returns location
    return LoadLocationHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Group
function YDWESaveGroupByInteger takes integer pTable,integer pKey,group g returns nothing
    call SaveGroupHandle(YDHT, pTable, pKey, g)
endfunction
function YDWESaveGroupByString takes string pTable,string pKey,group g returns nothing
    call SaveGroupHandle(YDHT, StringHash(pTable), StringHash(pKey), g)
endfunction
function YDWEGetGroupByInteger takes integer pTable,integer pKey returns group
    return LoadGroupHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetGroupByString takes string pTable,string pKey returns group
    return LoadGroupHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Multiboard
function YDWESaveMultiboardByInteger takes integer pTable,integer pKey,multiboard m returns nothing
    call SaveMultiboardHandle(YDHT, pTable, pKey, m)
endfunction
function YDWESaveMultiboardByString takes string pTable,string pKey,multiboard m returns nothing
    call SaveMultiboardHandle(YDHT, StringHash(pTable), StringHash(pKey), m)
endfunction
function YDWEGetMultiboardByInteger takes integer pTable,integer pKey returns multiboard
    return LoadMultiboardHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetMultiboardByString takes string pTable,string pKey returns multiboard
    return LoadMultiboardHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert MultiboardItem
function YDWESaveMultiboardItemByInteger takes integer pTable,integer pKey,multiboarditem mt returns nothing
    call SaveMultiboardItemHandle(YDHT, pTable, pKey, mt)
endfunction
function YDWESaveMultiboardItemByString takes string pTable,string pKey,multiboarditem mt returns nothing
    call SaveMultiboardItemHandle(YDHT, StringHash(pTable), StringHash(pKey), mt)
endfunction
function YDWEGetMultiboardItemByInteger takes integer pTable,integer pKey returns multiboarditem
    return LoadMultiboardItemHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetMultiboardItemByString takes string pTable,string pKey returns multiboarditem
    return LoadMultiboardItemHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert TextTag
function YDWESaveTextTagByInteger takes integer pTable,integer pKey,texttag tt returns nothing
    call SaveTextTagHandle(YDHT, pTable, pKey, tt)
endfunction
function YDWESaveTextTagByString takes string pTable,string pKey,texttag tt returns nothing
    call SaveTextTagHandle(YDHT, StringHash(pTable), StringHash(pKey), tt)
endfunction
function YDWEGetTextTagByInteger takes integer pTable,integer pKey returns texttag
    return LoadTextTagHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTextTagByString takes string pTable,string pKey returns texttag
    return LoadTextTagHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Lightning
function YDWESaveLightningByInteger takes integer pTable,integer pKey,lightning ln returns nothing
    call SaveLightningHandle(YDHT, pTable, pKey, ln)
endfunction
function YDWESaveLightningByString takes string pTable,string pKey,lightning ln returns nothing
    call SaveLightningHandle(YDHT, StringHash(pTable), StringHash(pKey), ln)
endfunction
function YDWEGetLightningByInteger takes integer pTable,integer pKey returns lightning
    return LoadLightningHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetLightningByString takes string pTable,string pKey returns lightning
    return LoadLightningHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Region
function YDWESaveRegionByInteger takes integer pTable,integer pKey,region rn returns nothing
    call SaveRegionHandle(YDHT, pTable, pKey, rn)
endfunction
function YDWESaveRegionByString takes string pTable,string pKey,region rt returns nothing
    call SaveRegionHandle(YDHT, StringHash(pTable), StringHash(pKey), rt)
endfunction
function YDWEGetRegionByInteger takes integer pTable,integer pKey returns region
    return LoadRegionHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetRegionByString takes string pTable,string pKey returns region
    return LoadRegionHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Rect
function YDWESaveRectByInteger takes integer pTable,integer pKey,rect rn returns nothing
    call SaveRectHandle(YDHT, pTable, pKey, rn)
endfunction
function YDWESaveRectByString takes string pTable,string pKey,rect rt returns nothing
    call SaveRectHandle(YDHT, StringHash(pTable), StringHash(pKey), rt)
endfunction
function YDWEGetRectByInteger takes integer pTable,integer pKey returns rect
    return LoadRectHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetRectByString takes string pTable,string pKey returns rect
    return LoadRectHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Leaderboard
function YDWESaveLeaderboardByInteger takes integer pTable,integer pKey,leaderboard lb returns nothing
    call SaveLeaderboardHandle(YDHT, pTable, pKey, lb)
endfunction
function YDWESaveLeaderboardByString takes string pTable,string pKey,leaderboard lb returns nothing
    call SaveLeaderboardHandle(YDHT, StringHash(pTable), StringHash(pKey), lb)
endfunction
function YDWEGetLeaderboardByInteger takes integer pTable,integer pKey returns leaderboard
    return LoadLeaderboardHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetLeaderboardByString takes string pTable,string pKey returns leaderboard
    return LoadLeaderboardHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Effect
function YDWESaveEffectByInteger takes integer pTable,integer pKey,effect e returns nothing
    call SaveEffectHandle(YDHT, pTable, pKey, e)
endfunction
function YDWESaveEffectByString takes string pTable,string pKey,effect e returns nothing
    call SaveEffectHandle(YDHT, StringHash(pTable), StringHash(pKey), e)
endfunction
function YDWEGetEffectByInteger takes integer pTable,integer pKey returns effect
    return LoadEffectHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetEffectByString takes string pTable,string pKey returns effect
    return LoadEffectHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Destructable
function YDWESaveDestructableByInteger takes integer pTable,integer pKey,destructable da returns nothing
    call SaveDestructableHandle(YDHT, pTable, pKey, da)
endfunction
function YDWESaveDestructableByString takes string pTable,string pKey,destructable da returns nothing
    call SaveDestructableHandle(YDHT, StringHash(pTable), StringHash(pKey), da)
endfunction
function YDWEGetDestructableByInteger takes integer pTable,integer pKey returns destructable
    return LoadDestructableHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetDestructableByString takes string pTable,string pKey returns destructable
    return LoadDestructableHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert triggercondition
function YDWESaveTriggerConditionByInteger takes integer pTable,integer pKey,triggercondition tc returns nothing
    call SaveTriggerConditionHandle(YDHT, pTable, pKey, tc)
endfunction
function YDWESaveTriggerConditionByString takes string pTable,string pKey,triggercondition tc returns nothing
    call SaveTriggerConditionHandle(YDHT, StringHash(pTable), StringHash(pKey), tc)
endfunction
function YDWEGetTriggerConditionByInteger takes integer pTable,integer pKey returns triggercondition
    return LoadTriggerConditionHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTriggerConditionByString takes string pTable,string pKey returns triggercondition
    return LoadTriggerConditionHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert triggeraction
function YDWESaveTriggerActionByInteger takes integer pTable,integer pKey,triggeraction ta returns nothing
    call SaveTriggerActionHandle(YDHT, pTable, pKey, ta)
endfunction
function YDWESaveTriggerActionByString takes string pTable,string pKey,triggeraction ta returns nothing
    call SaveTriggerActionHandle(YDHT, StringHash(pTable), StringHash(pKey), ta)
endfunction
function YDWEGetTriggerActionByInteger takes integer pTable,integer pKey returns triggeraction
    return LoadTriggerActionHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTriggerActionByString takes string pTable,string pKey returns triggeraction
    return LoadTriggerActionHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert event
function YDWESaveTriggerEventByInteger takes integer pTable,integer pKey,event et returns nothing
    call SaveTriggerEventHandle(YDHT, pTable, pKey, et)
endfunction
function YDWESaveTriggerEventByString takes string pTable,string pKey,event et returns nothing
    call SaveTriggerEventHandle(YDHT, StringHash(pTable), StringHash(pKey), et)
endfunction
function YDWEGetTriggerEventByInteger takes integer pTable,integer pKey returns event
    return LoadTriggerEventHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTriggerEventByString takes string pTable,string pKey returns event
    return LoadTriggerEventHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert force
function YDWESaveForceByInteger takes integer pTable,integer pKey,force fc returns nothing
    call SaveForceHandle(YDHT, pTable, pKey, fc)
endfunction
function YDWESaveForceByString takes string pTable,string pKey,force fc returns nothing
    call SaveForceHandle(YDHT, StringHash(pTable), StringHash(pKey), fc)
endfunction
function YDWEGetForceByInteger takes integer pTable,integer pKey returns force
    return LoadForceHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetForceByString takes string pTable,string pKey returns force
    return LoadForceHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert boolexpr
function YDWESaveBoolexprByInteger takes integer pTable,integer pKey,boolexpr be returns nothing
    call SaveBooleanExprHandle(YDHT, pTable, pKey, be)
endfunction
function YDWESaveBoolexprByString takes string pTable,string pKey,boolexpr be returns nothing
    call SaveBooleanExprHandle(YDHT, StringHash(pTable), StringHash(pKey), be)
endfunction
function YDWEGetBoolexprByInteger takes integer pTable,integer pKey returns boolexpr
    return LoadBooleanExprHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetBoolexprByString takes string pTable,string pKey returns boolexpr
    return LoadBooleanExprHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert sound
function YDWESaveSoundByInteger takes integer pTable,integer pKey,sound sd returns nothing
    call SaveSoundHandle(YDHT, pTable, pKey, sd)
endfunction
function YDWESaveSoundByString takes string pTable,string pKey,sound sd returns nothing
    call SaveSoundHandle(YDHT, StringHash(pTable), StringHash(pKey), sd)
endfunction
function YDWEGetSoundByInteger takes integer pTable,integer pKey returns sound
    return LoadSoundHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetSoundByString takes string pTable,string pKey returns sound
    return LoadSoundHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert timerdialog
function YDWESaveTimerDialogByInteger takes integer pTable,integer pKey,timerdialog td returns nothing
    call SaveTimerDialogHandle(YDHT, pTable, pKey, td)
endfunction
function YDWESaveTimerDialogByString takes string pTable,string pKey,timerdialog td returns nothing
    call SaveTimerDialogHandle(YDHT, StringHash(pTable), StringHash(pKey), td)
endfunction
function YDWEGetTimerDialogByInteger takes integer pTable,integer pKey returns timerdialog
    return LoadTimerDialogHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTimerDialogByString takes string pTable,string pKey returns timerdialog
    return LoadTimerDialogHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert trackable
function YDWESaveTrackableByInteger takes integer pTable,integer pKey,trackable ta returns nothing
    call SaveTrackableHandle(YDHT, pTable, pKey, ta)
endfunction
function YDWESaveTrackableByString takes string pTable,string pKey,trackable ta returns nothing
    call SaveTrackableHandle(YDHT, StringHash(pTable), StringHash(pKey), ta)
endfunction
function YDWEGetTrackableByInteger takes integer pTable,integer pKey returns trackable
    return LoadTrackableHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTrackableByString takes string pTable,string pKey returns trackable
    return LoadTrackableHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert dialog
function YDWESaveDialogByInteger takes integer pTable,integer pKey,dialog d returns nothing
    call SaveDialogHandle(YDHT, pTable, pKey, d)
endfunction
function YDWESaveDialogByString takes string pTable,string pKey,dialog d returns nothing
    call SaveDialogHandle(YDHT, StringHash(pTable), StringHash(pKey), d)
endfunction
function YDWEGetDialogByInteger takes integer pTable,integer pKey returns dialog
    return LoadDialogHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetDialogByString takes string pTable,string pKey returns dialog
    return LoadDialogHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert button
function YDWESaveButtonByInteger takes integer pTable,integer pKey,button bt returns nothing
    call SaveButtonHandle(YDHT, pTable, pKey, bt)
endfunction
function YDWESaveButtonByString takes string pTable,string pKey,button bt returns nothing
    call SaveButtonHandle(YDHT, StringHash(pTable), StringHash(pKey), bt)
endfunction
function YDWEGetButtonByInteger takes integer pTable,integer pKey returns button
    return LoadButtonHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetButtonByString takes string pTable,string pKey returns button
    return LoadButtonHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert quest
function YDWESaveQuestByInteger takes integer pTable,integer pKey,quest qt returns nothing
    call SaveQuestHandle(YDHT, pTable, pKey, qt)
endfunction
function YDWESaveQuestByString takes string pTable,string pKey,quest qt returns nothing
    call SaveQuestHandle(YDHT, StringHash(pTable), StringHash(pKey), qt)
endfunction
function YDWEGetQuestByInteger takes integer pTable,integer pKey returns quest
    return LoadQuestHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetQuestByString takes string pTable,string pKey returns quest
    return LoadQuestHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert questitem
function YDWESaveQuestItemByInteger takes integer pTable,integer pKey,questitem qi returns nothing
    call SaveQuestItemHandle(YDHT, pTable, pKey, qi)
endfunction
function YDWESaveQuestItemByString takes string pTable,string pKey,questitem qi returns nothing
    call SaveQuestItemHandle(YDHT, StringHash(pTable), StringHash(pKey), qi)
endfunction
function YDWEGetQuestItemByInteger takes integer pTable,integer pKey returns questitem
    return LoadQuestItemHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetQuestItemByString takes string pTable,string pKey returns questitem
    return LoadQuestItemHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
function YDWES2I takes string s returns integer
    return StringHash(s)
endfunction
function YDWESaveAbilityHandleBJ takes integer AbilityID,integer key,integer missionKey,hashtable table returns nothing
    call SaveInteger(table, missionKey, key, AbilityID)
endfunction
function YDWESaveAbilityHandle takes hashtable table,integer parentKey,integer childKey,integer AbilityID returns nothing
    call SaveInteger(table, parentKey, childKey, AbilityID)
endfunction
function YDWELoadAbilityHandleBJ takes integer key,integer missionKey,hashtable table returns integer
    return LoadInteger(table, missionKey, key)
endfunction
function YDWELoadAbilityHandle takes hashtable table,integer parentKey,integer childKey returns integer
    return LoadInteger(table, parentKey, childKey)
endfunction
//===========================================================================
//杩斿洖鍙傛暟
//===========================================================================
//鍦板浘杈圭晫鍒ゆ柇
function YDWECoordinateX takes real x returns real
    return RMinBJ(RMaxBJ(x, yd_MapMinX), yd_MapMaxX)
endfunction
function YDWECoordinateY takes real y returns real
    return RMinBJ(RMaxBJ(y, yd_MapMinY), yd_MapMaxY)
endfunction
//涓や釜鍗曚綅涔嬮棿鐨勮窛绂?
function YDWEDistanceBetweenUnits takes unit a,unit b returns real
    return SquareRoot(( GetUnitX(a) - GetUnitX(b) ) * ( GetUnitX(a) - GetUnitX(b) ) + ( GetUnitY(a) - GetUnitY(b) ) * ( GetUnitY(a) - GetUnitY(b) ))
endfunction
//涓や釜鍗曚綅涔嬮棿鐨勮搴?
function YDWEAngleBetweenUnits takes unit fromUnit,unit toUnit returns real
    return bj_RADTODEG * Atan2(GetUnitY(toUnit) - GetUnitY(fromUnit), GetUnitX(toUnit) - GetUnitX(fromUnit))
endfunction
//鐢熸垚鍖哄煙
function YDWEGetRect takes real x,real y,real width,real height returns rect
    return Rect(x - width * 0.5, y - height * 0.5, x + width * 0.5, y + height * 0.5)
endfunction
//===========================================================================
//璁剧疆鍗曚綅鍙互椋炶
//===========================================================================
function YDWEFlyEnable takes unit u returns nothing
    call UnitAddAbility(u, 'Amrf')
    call UnitRemoveAbility(u, 'Amrf')
endfunction
//===========================================================================
//瀛楃绐滀笌ID杞崲
//===========================================================================
function YDWEId2S takes integer value returns string
    local string charMap=bj_AllString
    local string result= ""
    local integer remainingValue= value
    local integer charValue
    local integer byteno
    set byteno=0
    loop
        set charValue=ModuloInteger(remainingValue, 256)
        set remainingValue=remainingValue / 256
        set result=SubString(charMap, charValue, charValue + 1) + result
        set byteno=byteno + 1
        exitwhen byteno == 4
    endloop
    return result
endfunction
function YDWES2Id takes string targetstr returns integer
    local string originstr=bj_AllString
    local integer strlength=StringLength(targetstr)
    local integer a=0
local integer b=0
local integer numx=1
local integer result=0
    loop
    exitwhen b > strlength - 1
        set numx=R2I(Pow(256, strlength - 1 - b))
        set a=1
        loop
            exitwhen a > 255
            if SubString(targetstr, b, b + 1) == SubString(originstr, a, a + 1) then
                set result=result + a * numx
                set a=256
            endif
            set a=a + 1
        endloop
        set b=b + 1
    endloop
    return result
endfunction
function YDWES2UnitId takes string targetstr returns integer
    return YDWES2Id(targetstr)
endfunction
function YDWES2ItemId takes string targetstr returns integer
    return YDWES2Id(targetstr)
endfunction
function GetLastAbilityCastingUnit takes nothing returns unit
    return bj_lastAbilityCastingUnit
endfunction
function GetLastAbilityTargetUnit takes nothing returns unit
    return bj_lastAbilityTargetUnit
endfunction
function YDWESetMapLimitCoordinate takes real MinX,real MaxX,real MinY,real MaxY returns nothing
    set yd_MapMaxX=MaxX
    set yd_MapMinX=MinX
    set yd_MapMaxY=MaxY
    set yd_MapMinY=MinY
endfunction
//===========================================================================
//===========================================================================
//鍦板浘鍒濆鍖?
//===========================================================================
//YDWE鐗规畩鎶€鑳界粨鏉熶簨浠?
function YDWESyStemAbilityCastingOverTriggerAction takes unit hero,integer index returns nothing
 local integer i= 0
    loop
        exitwhen i >= YDWEBase___AbilityCastingOverEventNumber
        if YDWEBase___AbilityCastingOverEventType[i] == index then
            set bj_lastAbilityCastingUnit=hero
			if YDWEBase___AbilityCastingOverEventQueue[i] != null and TriggerEvaluate(YDWEBase___AbilityCastingOverEventQueue[i]) and IsTriggerEnabled(YDWEBase___AbilityCastingOverEventQueue[i]) then
				call TriggerExecute(YDWEBase___AbilityCastingOverEventQueue[i])
			endif
		endif
        set i=i + 1
    endloop
endfunction
//===========================================================================  
//YDWE鎶€鑳芥崟鎹変簨浠?
//===========================================================================  
function YDWESyStemAbilityCastingOverRegistTrigger takes trigger trg,integer index returns nothing
	set YDWEBase___AbilityCastingOverEventQueue[YDWEBase___AbilityCastingOverEventNumber]=trg
	set YDWEBase___AbilityCastingOverEventType[YDWEBase___AbilityCastingOverEventNumber]=index
	set YDWEBase___AbilityCastingOverEventNumber=YDWEBase___AbilityCastingOverEventNumber + 1
endfunction 
//===========================================================================
//绯荤粺鍑芥暟瀹屽杽
//===========================================================================
function YDWECreateUnitPool takes nothing returns nothing
    set bj_lastCreatedUnitPool=CreateUnitPool()
endfunction
function YDWEPlaceRandomUnit takes unitpool up,player p,real x,real y,real face returns nothing
set bj_lastPoolAbstractedUnit=PlaceRandomUnit(up, p, x, y, face)
endfunction
function YDWEGetLastUnitPool takes nothing returns unitpool
    return bj_lastCreatedUnitPool
endfunction
function YDWEGetLastPoolAbstractedUnit takes nothing returns unit
    return bj_lastPoolAbstractedUnit
endfunction
function YDWECreateItemPool takes nothing returns nothing
    set bj_lastCreatedItemPool=CreateItemPool()
endfunction
function YDWEPlaceRandomItem takes itempool ip,real x,real y returns nothing
set bj_lastPoolAbstractedItem=PlaceRandomItem(ip, x, y)
endfunction
function YDWEGetLastItemPool takes nothing returns itempool
    return bj_lastCreatedItemPool
endfunction
function YDWEGetLastPoolAbstractedItem takes nothing returns item
    return bj_lastPoolAbstractedItem
endfunction
function YDWESetAttackDamageWeaponType takes attacktype at,damagetype dt,weapontype wt returns nothing
    set bj_lastSetAttackType=at
    set bj_lastSetDamageType=dt
    set bj_lastSetWeaponType=wt
endfunction
//unitpool bj_lastCreatedPool=null
//unit bj_lastPoolAbstractedUnit=null
function YDWEGetPlayerColorString takes player p,string s returns string
    return YDWEBase___yd_PlayerColor[GetHandleId(GetPlayerColor(p))] + s + "|r"
endfunction
//===========================================================================
//===========================================================================
//绯荤粺鍑芥暟琛ュ厖
//===========================================================================
//===========================================================================
function YDWEGetUnitItemSoftId takes unit hero,item it returns integer
    local integer i= 0
    loop
         exitwhen i > 5
         if UnitItemInSlot(hero, i) == it then
            return i + 1
         endif
         set i=i + 1
    endloop
    return 0
endfunction
//===========================================================================
//===========================================================================
//鍦板浘鍒濆鍖?
//===========================================================================
//===========================================================================
//鏄剧ず鐗堟湰
function YDWEVersion_Display takes nothing returns boolean
    call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 30, "|cFF1E90FF褰撳墠缂栬緫鍣ㄧ増鏈负锛?|r|cFF00FF00YDWE 1.26.9.617")
    return false
endfunction
function YDWEVersion_Init takes nothing returns nothing
    local trigger t= CreateTrigger()
    local integer i= 0
    loop
        exitwhen i == 12
        call TriggerRegisterPlayerChatEvent(t, Player(i), "YDWE Version", true)
        set i=i + 1
    endloop
    call TriggerAddCondition(t, Condition(function YDWEVersion_Display))
    set t=null
endfunction
function InitializeYD takes nothing returns nothing
     set YDHT=InitHashtable()
	//=================璁剧疆鍙橀噺=====================
	set yd_MapMinX=GetCameraBoundMinX() - GetCameraMargin(CAMERA_MARGIN_LEFT)
	set yd_MapMinY=GetCameraBoundMinY() - GetCameraMargin(CAMERA_MARGIN_BOTTOM)
	set yd_MapMaxX=GetCameraBoundMaxX() + GetCameraMargin(CAMERA_MARGIN_RIGHT)
	set yd_MapMaxY=GetCameraBoundMaxY() + GetCameraMargin(CAMERA_MARGIN_TOP)
	
    set YDWEBase___yd_PlayerColor[0]="|cFFFF0303"
    set YDWEBase___yd_PlayerColor[1]="|cFF0042FF"
    set YDWEBase___yd_PlayerColor[2]="|cFF1CE6B9"
    set YDWEBase___yd_PlayerColor[3]="|cFF540081"
    set YDWEBase___yd_PlayerColor[4]="|cFFFFFC01"
    set YDWEBase___yd_PlayerColor[5]="|cFFFE8A0E"
    set YDWEBase___yd_PlayerColor[6]="|cFF20C000"
    set YDWEBase___yd_PlayerColor[7]="|cFFE55BB0"
    set YDWEBase___yd_PlayerColor[8]="|cFF959697"
    set YDWEBase___yd_PlayerColor[9]="|cFF7EBFF1"
    set YDWEBase___yd_PlayerColor[10]="|cFF106246"
    set YDWEBase___yd_PlayerColor[11]="|cFF4E2A04"
    set YDWEBase___yd_PlayerColor[12]="|cFF282828"
    set YDWEBase___yd_PlayerColor[13]="|cFF282828"
    set YDWEBase___yd_PlayerColor[14]="|cFF282828"
    set YDWEBase___yd_PlayerColor[15]="|cFF282828"
    //=================鏄剧ず鐗堟湰=====================
    call YDWEVersion_Init()
endfunction

//library YDWEBase ends
//library YDWETriggerEvent:
	
//===========================================================================  
//任意单位伤害事件 
//===========================================================================
function YDWEAnyUnitDamagedTriggerAction takes nothing returns nothing
    local integer i= 0
    
    loop
        exitwhen i >= YDWETriggerEvent___DamageEventNumber
        if YDWETriggerEvent___DamageEventQueue[i] != null and IsTriggerEnabled(YDWETriggerEvent___DamageEventQueue[i]) and TriggerEvaluate(YDWETriggerEvent___DamageEventQueue[i]) then
            call TriggerExecute(YDWETriggerEvent___DamageEventQueue[i])
        endif
        set i=i + 1
    endloop
endfunction
function YDWEAnyUnitDamagedFilter takes nothing returns boolean
    if GetUnitAbilityLevel(GetFilterUnit(), 'Aloc') <= 0 then
        call TriggerRegisterUnitEvent(yd_DamageEventTrigger, GetFilterUnit(), EVENT_UNIT_DAMAGED)
    endif
    return false
endfunction
function YDWEAnyUnitDamagedEnumUnit takes nothing returns nothing
    local trigger t= CreateTrigger()
    local region r= CreateRegion()
    local group g= CreateGroup()
    call RegionAddRect(r, GetWorldBounds())
    call TriggerRegisterEnterRegion(t, r, Condition(function YDWEAnyUnitDamagedFilter))
    call GroupEnumUnitsInRect(g, GetWorldBounds(), Condition(function YDWEAnyUnitDamagedFilter))
    call DestroyGroup(g)
    set r=null
    set t=null
    set g=null
endfunction
	
function YDWESyStemAnyUnitDamagedRegistTrigger takes trigger trg returns nothing
    if trg == null then
        return
    endif
        
    if YDWETriggerEvent___DamageEventNumber == 0 then
        set yd_DamageEventTrigger=CreateTrigger()
        call TriggerAddAction(yd_DamageEventTrigger, function YDWEAnyUnitDamagedTriggerAction)
        call YDWEAnyUnitDamagedEnumUnit()
    endif
    
    set YDWETriggerEvent___DamageEventQueue[YDWETriggerEvent___DamageEventNumber]=trg
    set YDWETriggerEvent___DamageEventNumber=YDWETriggerEvent___DamageEventNumber + 1
endfunction
//===========================================================================  
//移动物品事件 
//===========================================================================  
function YDWESyStemItemUnmovableTriggerAction takes nothing returns nothing
    local integer i= 0
    
    if GetIssuedOrderId() >= 852002 and GetIssuedOrderId() <= 852007 then
		set bj_lastMovedItemInItemSlot=GetOrderTargetItem()
    	loop
        	exitwhen i >= YDWETriggerEvent___MoveItemEventNumber
        	if YDWETriggerEvent___MoveItemEventQueue[i] != null and IsTriggerEnabled(YDWETriggerEvent___MoveItemEventQueue[i]) and TriggerEvaluate(YDWETriggerEvent___MoveItemEventQueue[i]) then
        	    call TriggerExecute(YDWETriggerEvent___MoveItemEventQueue[i])
        	endif
        	set i=i + 1
    	endloop
	endif
endfunction
function YDWESyStemItemUnmovableRegistTrigger takes trigger trg returns nothing
    if trg == null then
        return
    endif
        
    if YDWETriggerEvent___MoveItemEventNumber == 0 then
        set YDWETriggerEvent___MoveItemEventTrigger=CreateTrigger()
        call TriggerAddAction(YDWETriggerEvent___MoveItemEventTrigger, function YDWESyStemItemUnmovableTriggerAction)
        call TriggerRegisterAnyUnitEventBJ(YDWETriggerEvent___MoveItemEventTrigger, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    endif
    
    set YDWETriggerEvent___MoveItemEventQueue[YDWETriggerEvent___MoveItemEventNumber]=trg
    set YDWETriggerEvent___MoveItemEventNumber=YDWETriggerEvent___MoveItemEventNumber + 1
endfunction
function GetLastMovedItemInItemSlot takes nothing returns item
    return bj_lastMovedItemInItemSlot
endfunction

//library YDWETriggerEvent ends
//library YDWETriggerRegisterEnterRectSimpleNull:
function YDWETriggerRegisterEnterRectSimpleNull takes trigger trig,rect r returns event
    local region rectRegion= CreateRegion()
    call RegionAddRect(rectRegion, r)
    set yd_NullTempRegion=rectRegion
    set rectRegion=null
    return TriggerRegisterEnterRegion(trig, yd_NullTempRegion, null)
endfunction

//library YDWETriggerRegisterEnterRectSimpleNull ends
//library YDWETriggerRegisterLeaveRectSimpleNull:
function YDWETriggerRegisterLeaveRectSimpleNull takes trigger trig,rect r returns event
    local region rectRegion= CreateRegion()
    call RegionAddRect(rectRegion, r)
    set yd_NullTempRegion=rectRegion
    set rectRegion=null
    return TriggerRegisterLeaveRegion(trig, yd_NullTempRegion, null)
endfunction

//library YDWETriggerRegisterLeaveRectSimpleNull ends
//library Attract:
    function AttractInit takes nothing returns nothing
        set katt=GetNewKey()
        set att2dthsn=0
        set ktrc=GetNewKey()
        set trc2dthsn=0
    endfunction
    function Att takes nothing returns nothing
        call sc__att2dth_move(att2dths[LoadInteger(ht, GetHandleId(GetExpiredTimer()), katt)])
    endfunction
    function Trc takes nothing returns nothing
        call sc__trc2dth_move(trc2dths[LoadInteger(ht, GetHandleId(GetExpiredTimer()), ktrc)])
    endfunction
    
        function s__att2dth_move takes integer this returns nothing
            local real dir
            if IsUnitDeadBJ(s__att2dth_s[this]) or IsUnitDeadBJ(s__att2dth_u[this]) then
                call sc__att2dth_deallocate(this)
            else
                set dir=Atan2(GetUnitY(s__att2dth_s[this]) - GetUnitY(s__att2dth_u[this]), GetUnitX(s__att2dth_s[this]) - GetUnitX(s__att2dth_u[this]))
                call AddVector(s__att2dth_u[this] , dir , s__att2dth_str[this])
                call BJDebugMsg("attract str is" + R2S(s__att2dth_str[this]))
            endif
        endfunction
        
        function s__att2dth_create takes unit s,unit u,real str returns integer
            local integer as=s__att2dth__allocate()
            set s__att2dth_s[as]=s
            set s__att2dth_u[as]=u
            set s__att2dth_str[as]=str
            set s__att2dth_t[as]=CreateTimer()
            set att2dths[att2dthsn]=as
            set s__att2dth_spot[as]=att2dthsn
            set att2dthsn=att2dthsn + 1
            call TimerStart(s__att2dth_t[as], 0.03, true, function Att)
            call SaveInteger(ht, GetHandleId(s__att2dth_t[as]), katt, s__att2dth_spot[as])
            return as
        endfunction
        
        function s__att2dth_onDestroy takes integer this returns nothing
            set att2dthsn=att2dthsn - 1
            set att2dths[s__att2dth_spot[this]]=att2dths[att2dthsn]
            set s__att2dth_spot[att2dths[att2dthsn]]=s__att2dth_spot[this]
            call RemoveSavedInteger(ht, GetHandleId(s__att2dth_t[this]), katt)
            call DestroyTimer(s__att2dth_t[this])
            set s__att2dth_t[this]=null
            set s__att2dth_u[this]=null
            set s__att2dth_s[this]=null
            call BJDebugMsg("att2dthsn " + I2S(att2dthsn))
        endfunction

//Generated destructor of att2dth
function s__att2dth_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__att2dth_V[this]!=-1) then
        return
    endif
    call s__att2dth_onDestroy(this)
    set si__att2dth_V[this]=si__att2dth_F
    set si__att2dth_F=this
endfunction
    
    
        function s__trc2dth_move takes integer this returns nothing
            local real dir
            local integer v
            local integer dec
            local integer i
            if IsUnitDeadBJ(s__trc2dth_s[this]) or IsUnitDeadBJ(s__trc2dth_u[this]) then
                call sc__trc2dth_deallocate(this)
            else
                set dir=Atan2(GetUnitY(s__trc2dth_s[this]) - GetUnitY(s__trc2dth_u[this]), GetUnitX(s__trc2dth_s[this]) - GetUnitX(s__trc2dth_u[this]))
                set dec=GetHandleId(s__trc2dth_u[this])
                if HaveSavedInteger(ht, dec, kvel) then
                    set v=s__vector_create(s__trc2dth_str[this] * Cos(dir) , s__trc2dth_str[this] * Sin(dir))
                    set i=LoadInteger(ht, dec, kvel)
                    if s__vector_getAngle(v , s__ball_v[balls[i]]) > s__trc2dth_tdir[this] and YDWEDistanceBetweenUnits(s__trc2dth_s[this] , s__trc2dth_u[this]) > s__trc2dth_trange[this] then
                        //call BJDebugMsg("trc - length"+R2S(YDWEDistanceBetweenUnits(s, u)))
                        call s__vector_subtractLength(s__ball_v[balls[i]],s__trc2dth_tstr[this])
                    endif
                endif
                call AddVector(s__trc2dth_u[this] , dir , s__trc2dth_str[this])
            endif
            call s__vector_deallocate(v)
        endfunction
        
        function s__trc2dth_create takes unit s,unit u,real str,real tdir,real tstr,real trange returns integer
            local integer as=s__trc2dth__allocate()
            set s__trc2dth_s[as]=s
            set s__trc2dth_u[as]=u
            set s__trc2dth_str[as]=str
            set s__trc2dth_tstr[as]=tstr
            set s__trc2dth_tdir[as]=tdir
            set s__trc2dth_t[as]=CreateTimer()
            set s__trc2dth_trange[as]=trange
            set trc2dths[trc2dthsn]=as
            set s__trc2dth_spot[as]=trc2dthsn
            set trc2dthsn=trc2dthsn + 1
            call TimerStart(s__trc2dth_t[as], 0.03, true, function Trc)
            call SaveInteger(ht, GetHandleId(s__trc2dth_t[as]), ktrc, s__trc2dth_spot[as])
            return as
        endfunction
        
        function s__trc2dth_onDestroy takes integer this returns nothing
            set trc2dthsn=trc2dthsn - 1
            set trc2dths[s__trc2dth_spot[this]]=trc2dths[trc2dthsn]
            set s__trc2dth_spot[trc2dths[trc2dthsn]]=s__trc2dth_spot[this]
            call RemoveSavedInteger(ht, GetHandleId(s__trc2dth_t[this]), katt)
            call DestroyTimer(s__trc2dth_t[this])
            set s__trc2dth_t[this]=null
            set s__trc2dth_u[this]=null
            set s__trc2dth_s[this]=null
            call BJDebugMsg("trc2dthsn " + I2S(trc2dthsn))
        endfunction

//Generated destructor of trc2dth
function s__trc2dth_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__trc2dth_V[this]!=-1) then
        return
    endif
    call s__trc2dth_onDestroy(this)
    set si__trc2dth_V[this]=si__trc2dth_F
    set si__trc2dth_F=this
endfunction
    
    

//library Attract ends
//library AutoIndex:

//library AutoIndex ends
//library Damage:
    //============================================================
    ////! external ObjectMerger w3a AIlz dprv anam "Life Bonus" ansf "(Damage System)" Ilif 1 500000 aite 0
    
    //============================================================
    
    
    function Damage_RegisterEvent takes trigger whichTrigger returns nothing
        call s__Event_register(Damage___OnDamageEvent,whichTrigger)
    endfunction
    
    function Damage_RegisterZeroEvent takes trigger whichTrigger returns nothing
        call s__Event_register(Damage___OnZeroDamageEvent,whichTrigger)
    endfunction
    
    function Damage_EnableEvent takes boolean enable returns nothing
        set Damage___EventEnabled=enable
    endfunction
    
    //============================================================
    
    function Damage_GetType takes nothing returns damagetype
        return Damage___TypeStackValue[Damage___TypeStackLevel]
    endfunction
    
    function Damage_IsAttack takes nothing returns boolean
        return Damage___TypeStackAttack[Damage___TypeStackLevel]
    endfunction
    
    function Damage_Block takes real amount returns nothing
        set Damage___ToBlock[Damage___TypeStackLevel]=Damage___ToBlock[Damage___TypeStackLevel] + amount
    endfunction
    
    function Damage_BlockAll takes nothing returns nothing
        set Damage___ToBlock[Damage___TypeStackLevel]=Damage___ToBlock[Damage___TypeStackLevel] + GetEventDamage()
    endfunction
    
    //============================================================
    
    //============================================================
    
    function Damage___RemoveBoostedTimerFunc takes nothing returns nothing
        loop
            exitwhen Damage___RemoveBoostedMax == 0
            set Damage___BoostedLifeUnit=Damage___RemoveBoosted[Damage___RemoveBoostedMax]
            set Damage___BoostedLifeTemp=GetWidgetLife(Damage___BoostedLifeUnit)
            call UnitRemoveAbility(Damage___BoostedLifeUnit, Damage___LIFE_BONUS_ABIL)
            if Damage___BoostedLifeTemp > 0.405 then
                call SetWidgetLife(Damage___BoostedLifeUnit, Damage___BoostedLifeTemp)
            endif
            set Damage___RemoveBoostedMax=Damage___RemoveBoostedMax - 1
        endloop
    endfunction
    
    //============================================================
    function Damage___OnDamageActions takes nothing returns boolean
        if Damage___EventEnabled then
            if GetEventDamage() == 0. then
                call s__Event_fire(Damage___OnZeroDamageEvent)
            else
                call s__Event_fire(Damage___OnDamageEvent)
            endif
            
            if Damage___ToBlock[Damage___TypeStackLevel] != 0. then
                //====================================================
                // Blocking
                set Damage___ForUnit=GetTriggerUnit()
                
                set Damage___NextHealth=GetEventDamage()
                if Damage___ToBlock[Damage___TypeStackLevel] >= Damage___NextHealth then
                    set Damage___NextHealth=GetWidgetLife(Damage___ForUnit) + Damage___NextHealth
                else
                    set Damage___NextHealth=GetWidgetLife(Damage___ForUnit) + Damage___ToBlock[Damage___TypeStackLevel]
                endif
                
                call SetWidgetLife(Damage___ForUnit, Damage___NextHealth)
                if GetWidgetLife(Damage___ForUnit) < Damage___NextHealth then
                    // NextHealth is over max health.
                    call UnitAddAbility(Damage___ForUnit, Damage___LIFE_BONUS_ABIL)
                    call SetWidgetLife(Damage___ForUnit, Damage___NextHealth)
                    
                    set Damage___RemoveBoostedMax=Damage___RemoveBoostedMax + 1
                    set Damage___RemoveBoosted[Damage___RemoveBoostedMax]=Damage___ForUnit
                    call ResumeTimer(Damage___RemoveBoostedTimer)
                endif
                //====================================================
                set Damage___ToBlock[Damage___TypeStackLevel]=0.
            endif
        endif
        return false
    endfunction
    
    //============================================================
    function UnitDamageTargetEx takes unit whichUnit,widget target,real amount,boolean attack,boolean ranged,attacktype attackType,damagetype damageType,weapontype weaponType returns boolean
        local boolean result
        set Damage___TypeStackLevel=Damage___TypeStackLevel + 1
        set Damage___TypeStackValue[Damage___TypeStackLevel]=damageType
        set Damage___TypeStackAttack[Damage___TypeStackLevel]=attack
        set result=UnitDamageTarget(whichUnit, target, amount, attack, ranged, attackType, damageType, weaponType)
        set Damage___TypeStackLevel=Damage___TypeStackLevel - 1
        return result
    endfunction
    
//textmacro instance: Damage__DealTypeFunc("Pure","DAMAGE_TYPE_UNIVERSAL")
        function Damage_Pure takes unit source,unit target,real amount returns boolean
            return UnitDamageTargetEx(source , target , amount , false , false , ATTACK_TYPE_NORMAL , DAMAGE_TYPE_UNIVERSAL , WEAPON_TYPE_WHOKNOWS)
        endfunction
        function Damage_IsPure takes nothing returns boolean
            return Damage_GetType() == DAMAGE_TYPE_UNIVERSAL
        endfunction
//end of: Damage__DealTypeFunc("Pure","DAMAGE_TYPE_UNIVERSAL")
//textmacro instance: Damage__DealTypeFunc("Spell","DAMAGE_TYPE_MAGIC")
        function Damage_Spell takes unit source,unit target,real amount returns boolean
            return UnitDamageTargetEx(source , target , amount , false , false , ATTACK_TYPE_NORMAL , DAMAGE_TYPE_MAGIC , WEAPON_TYPE_WHOKNOWS)
        endfunction
        function Damage_IsSpell takes nothing returns boolean
            return Damage_GetType() == DAMAGE_TYPE_MAGIC
        endfunction
//end of: Damage__DealTypeFunc("Spell","DAMAGE_TYPE_MAGIC")
    
    // Uses different stuff, but works much the same way.
    function Damage_Physical takes unit source,unit target,real amount,attacktype whichType,boolean attack,boolean ranged returns boolean
        return UnitDamageTargetEx(source , target , amount , attack , ranged , whichType , DAMAGE_TYPE_NORMAL , WEAPON_TYPE_WHOKNOWS)
    endfunction
    function Damage_IsPhysical takes nothing returns boolean
        return Damage_GetType() == DAMAGE_TYPE_NORMAL
    endfunction
    
    //============================================================
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the method are otherwise undefined.
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        
        //-----------------------------------------------------------------------
        function s__Damage___Detector__staticgetindex takes unit whichUnit returns integer
            return GetUnitId(whichUnit)
        endfunction
        
        function s__Damage___Detector__get_unit takes integer this returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Damage___Detector_AIDS_addLock takes integer this returns nothing
            call AIDS_AddLock(this)
        endfunction
        function s__Damage___Detector_AIDS_removeLock takes integer this returns nothing
            call AIDS_RemoveLock(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Damage___Detector_AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if s__AIDS_DEFAULT_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set s__Damage___Detector_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnit())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__Damage___Detector_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__Damage___Detector_AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if s__AIDS_DEFAULT_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set s__Damage___Detector_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnitAllocated())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__Damage___Detector_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__Damage___Detector_AIDS_onDeallocate takes nothing returns boolean
            if s__Damage___Detector_AIDS_instanciated[(AIDS_GetDecayingIndex())] then
                call sc__Damage___Detector_AIDS_onDestroy((AIDS_GetDecayingIndex()))
                // Unflag destruction on deallocation.
                set s__Damage___Detector_AIDS_instanciated[(AIDS_GetDecayingIndex())]=false
            endif
            
            return false
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Damage___Detector_onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Condition(function s__Damage___Detector_AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Condition(function s__Damage___Detector_AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Condition(function s__Damage___Detector_AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call sc__Damage___Detector_AIDS_onInit()
        endfunction
//end of: AIDS()

        
        
        function s__Damage___Detector_AIDS_onCreate takes integer this returns nothing
            set s__Damage___Detector_t[this]=CreateTrigger()
            call TriggerAddCondition(s__Damage___Detector_t[this], s__Damage___Detector_ACTIONS_COND)
            call TriggerRegisterUnitEvent(s__Damage___Detector_t[this], s__Damage___Detector__get_unit(this), EVENT_UNIT_DAMAGED)
        endfunction
        
        function s__Damage___Detector_AIDS_onDestroy takes integer this returns nothing
            call DestroyTrigger(s__Damage___Detector_t[this])
        endfunction
        
        function s__Damage___Detector_AIDS_onInit takes nothing returns nothing
            set s__Damage___Detector_ACTIONS_COND=Condition(function Damage___OnDamageActions)
        endfunction
    
    //============================================================
//Implemented from module Damage___InitModule:
        function s__Damage___InitStruct_Damage___InitModule__onInit takes nothing returns nothing
            local unit abilpreload=CreateUnit(Player(15), 'uloc', 0, 0, 0)
            call UnitAddAbility(abilpreload, Damage___LIFE_BONUS_ABIL)
            call RemoveUnit(abilpreload)
            set abilpreload=null
            
            set Damage___OnDamageEvent=s__Event_create()
            set Damage___OnZeroDamageEvent=s__Event_create()
            set Damage___TypeStackValue[Damage___TypeStackLevel]=DAMAGE_TYPE_NORMAL
            set Damage___TypeStackAttack[Damage___TypeStackLevel]=true
            call TimerStart(Damage___RemoveBoostedTimer, 0.0, false, function Damage___RemoveBoostedTimerFunc)
        endfunction
    
    function ChaosDamage takes unit su,unit tu,real d returns nothing
    call UnitDamageTarget(su, tu, d, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_ENHANCED, WEAPON_TYPE_WHOKNOWS)
endfunction
function rangeChaosDamage takes unit source,real x,real y,real radius,real damage,string efs returns nothing
    local group ydl_group
    local unit ydl_unit
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, radius, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if IsUnitAliveBJ(ydl_unit) == true and IsUnitEnemy(ydl_unit, GetOwningPlayer(source)) == true then
            call ChaosDamage(source , ydl_unit , damage)
        endif
        endloop
    call DestroyEffect(AddSpecialEffect(efs, x, y))
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
endfunction
function rangeOneTimeChaosRisDamage takes unit source,real x,real y,real radius,real damage,string efs,group gro,integer life returns integer
    local group ydl_group
    local unit ydl_unit
    local integer ris
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, radius, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if IsUnitAliveBJ(ydl_unit) and IsUnitEnemy(ydl_unit, GetOwningPlayer(source)) and ( not IsUnitInGroup(ydl_unit, gro) ) then
            call ChaosDamage(source , ydl_unit , damage)
            call GroupAddUnit(gro, ydl_unit)
            set ris=LoadInteger(ht, GetUnitTypeId(ydl_unit), kbulris)
            set life=life - ris
        endif
        endloop
    call DestroyEffect(AddSpecialEffect(efs, x, y))
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
    return life
endfunction
function throughDamage takes unit source,real x,real y,real radius,real damage,string efs,integer l,real dir,real kb,integer life returns integer
    local group ydl_group
    local unit ydl_unit
    local real m
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, radius, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if IsLiveEnemy(source , ydl_unit) and s__unitList_hasUnit(l,ydl_unit) == false then
            call Damage_Spell(source , ydl_unit , damage)
            call s__unitList_addUnit(l,ydl_unit)
            set m=LoadReal(ht, GetUnitTypeId(ydl_unit), km)
            set life=life - R2I(m)
            if kb / m > 50 then
                call BJDebugMsg(" Damage-throughDamage:kb/m>50")
            endif
            call AddVector(ydl_unit , dir , kb / m)
            call DestroyEffect(AddSpecialEffect(efs, x, y))
        endif
        endloop
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
    return life
endfunction
function bloomDamage takes unit source,real x,real y,real radius,real damage,string efs,real kb returns nothing
    local group ydl_group
    local unit ydl_unit
    local integer ris
    local real m
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, radius, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if IsLiveEnemy(source , ydl_unit) then
            call Damage_Spell(source , ydl_unit , damage)
            set m=LoadReal(ht, GetUnitTypeId(ydl_unit), km)
            call AddVector(ydl_unit , Atan2(GetUnitY(ydl_unit) - y, GetUnitX(ydl_unit) - x) , kb / m)
        endif
        endloop
    call DestroyEffect(AddSpecialEffect(efs, x, y))
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
endfunction

//library Damage ends
//library PUI:
    //===========================================================================
    //  Allowed PUI_PROPERTY TYPES are: unit, integer, real, boolean, string
    //  Do NOT put handles that need to be destroyed here (timer, trigger, ...)
    //  Instead put them in a struct and use PUI textmacro
    //===========================================================================
    //===========================================================================
    //  Never destroy PUI structs directly.
    //  Use .release() instead, will call .destroy()
    //===========================================================================

//library PUI ends
//library RegisterM:
    function InitRegisterM takes nothing returns nothing
        set km=GetNewKey()
    endfunction

//library RegisterM ends
//library VectorLib:

//library VectorLib ends
//library YDWEJumpTimer:
function YDWEJumpTimerLoop takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit hero=( YDWEGetUnitByString(I2S(YDWEH2I(t)) , "Hero") )
    local real angle=YDWEGetRealByString(I2S(YDWEH2I(t)) , "Angle")
    local integer steeps=YDWEGetIntegerByString(I2S(YDWEH2I(t)) , "steeps")
    local integer steepsMax=YDWEGetIntegerByString(I2S(YDWEH2I(t)) , "steepsMax")
    local real heightMax=YDWEGetRealByString(I2S(YDWEH2I(t)) , "heightMax")
    local real dist=YDWEGetRealByString(I2S(YDWEH2I(t)) , "dist")
    local real dheig=YDWEGetRealByString(I2S(YDWEH2I(t)) , "dheig")
    local real OriginHeight=YDWEGetRealByString(I2S(YDWEH2I(t)) , "OriginHeight")
    local real x=YDWEGetRealByString(I2S(YDWEH2I(t)) , "X")
    local real y=YDWEGetRealByString(I2S(YDWEH2I(t)) , "Y")
    local real x1=0
    local real y1=0
    local real height=0
    local integer lvJumpTimer=MoveMoreLevel_JumpTimer
    local integer lvUnitMove=YDWEGetIntegerByString(I2S(YDWEH2I(hero)) , "lvUnitMove")
    if steeps < steepsMax and lvJumpTimer >= lvUnitMove then
        set x1=x + steeps * dist * Cos(angle * 3.14159 / 180.0)
        set y1=y + steeps * dist * Sin(angle * 3.14159 / 180.0)
        set x1=YDWECoordinateX(x1)
        set y1=YDWECoordinateY(y1)
        call SetUnitX(hero, x1)
        call SetUnitY(hero, y1)
        set steeps=steeps + 1
        call YDWESaveIntegerByString(I2S(YDWEH2I(t)) , "steeps" , steeps)
        set height=( - ( 2 * I2R(steeps) * dheig - 1 ) * ( 2 * I2R(steeps) * dheig - 1 ) + 1 ) * heightMax + OriginHeight
        call SetUnitFlyHeight(hero, height, 99999)
        call SetUnitFacing(hero, angle)
      else
        call SetUnitFlyHeight(hero, OriginHeight, 99999)
        call SetUnitPathing(hero, true)
        call DestroyTimer(t)
        call YDWEFlushMissionByString(I2S(YDWEH2I(t)))
        call YDWESaveIntegerByString(I2S(YDWEH2I(hero)) , "lvUnitMove" , 0)
        call YDWESyStemAbilityCastingOverTriggerAction(hero , 2)
    endif
    set t=null
    set hero=null
endfunction
                            
function YDWEJumpTimer takes unit hero,real angle,real distance,real lasttime,real timeout,real heightMax returns nothing
    local timer t=null
    local real x=GetUnitX(hero)
    local real y=GetUnitY(hero)
    local integer steepsMax=R2I(lasttime / timeout)
    local integer steeps=0
    local real dist=distance / steepsMax
    local real dheig=1.0 / steepsMax
    local real OriginHeight=GetUnitFlyHeight(hero)
    local integer lvUnitMove=YDWEGetIntegerByString(I2S(YDWEH2I(hero)) , "lvUnitMove")
    if MoveMoreLevel_JumpTimer <= lvUnitMove then
        return
    endif
    set t=CreateTimer()
    call YDWESaveIntegerByString(I2S(YDWEH2I(hero)) , "lvUnitMove" , MoveMoreLevel_JumpTimer)
    call YDWEFlyEnable(hero)
    call SetUnitPathing(hero, false)
    call YDWESaveUnitByString(I2S(YDWEH2I(t)) , "Hero" , hero)
    call YDWESaveRealByString(I2S(YDWEH2I(t)) , "OriginHeight" , OriginHeight)
    call YDWESaveRealByString(I2S(YDWEH2I(t)) , "Angle" , angle)
    call YDWESaveRealByString(I2S(YDWEH2I(t)) , "dist" , dist)
    call YDWESaveRealByString(I2S(YDWEH2I(t)) , "heightMax" , heightMax)
    call YDWESaveRealByString(I2S(YDWEH2I(t)) , "dheig" , dheig)
    call YDWESaveRealByString(I2S(YDWEH2I(t)) , "X" , x)
    call YDWESaveRealByString(I2S(YDWEH2I(t)) , "Y" , y)
    call YDWESaveIntegerByString(I2S(YDWEH2I(t)) , "steeps" , steeps)
    call YDWESaveIntegerByString(I2S(YDWEH2I(t)) , "steepsMax" , steepsMax)
    call TimerStart(t, timeout, true, function YDWEJumpTimerLoop)
    set t=null
endfunction

//library YDWEJumpTimer ends
//library Velocity:
    
    function Velocity___MoveBalls takes nothing returns nothing
        local integer i=0
        loop
            exitwhen i >= ballNum
            call sc__ball_move(balls[i])
            set i=i + 1
        endloop
    endfunction
    
    
    
    function Velocity___Init takes nothing returns nothing
        local timer t=CreateTimer()
        set kvel=GetNewKey()
        set kctype=GetNewKey()
        set keff=GetNewKey()
        set kcrange=GetNewKey()
        set kkb=GetNewKey()
        set kfly=GetNewKey()
        set klife=GetNewKey()
        set kbrange=GetNewKey()
        call TimerStart(t, period, true, function Velocity___MoveBalls)
    endfunction
    
    
    
        
        function s__ball_through takes integer this returns nothing
            set s__ball_life[this]=throughDamage(s__ball_u[this] , GetUnitX(s__ball_u[this]) , GetUnitY(s__ball_u[this]) , s__ball_crange[this] , s__ball_dam[this] , s__ball_eff[this] , s__ball_l[this] , Atan2(s__vector_y[s__ball_v[this]] - 0, s__vector_x[s__ball_v[this]] - 0) , s__vector_getLength(s__ball_v[this]) * s__ball_m[this] , s__ball_life[this])
        endfunction
        
        function s__ball_updateList takes integer this returns nothing
            local integer i=0
            loop
                exitwhen i >= s__unitList_n[s__ball_l[this]]
                if YDWEDistanceBetweenUnits(s___unitList_a[s__unitList_a[s__ball_l[this]]+i] , s__ball_u[this]) > s__ball_crange[this] then
                    call s__unitList_removeUnit(s__ball_l[this],s___unitList_a[s__unitList_a[s__ball_l[this]]+i])
                endif
                set i=i + 1
            endloop
        endfunction
        
        function s__ball_bloom takes integer this returns nothing
            call bloomDamage(s__ball_u[this] , s__vector_x[s__ball_v[this]] , s__vector_y[s__ball_v[this]] , s__ball_brange[this] , s__ball_dam[this] , s__ball_eff[this] , s__ball_kb[this])
            call KillUnit(s__ball_u[this])
        endfunction
        
        function s__ball_move takes integer this returns nothing
            //move
            local real hflength=vf * s__ball_m[this] / 2
            if ( s__ball_life[this] > 0 and s__vector_getLength(s__ball_v[this]) >= hflength ) or ( s__ball_life[this] > 0 and ( s__vector_getLength(s__ball_v[this]) < hflength and s__ball_ctype[this] != CTYPE_NONE ) ) then
                if s__vector_getLength(s__ball_v[this]) > vmax then
                    call s__vector_setLength(s__ball_v[this],vmax)
                    call BJDebugMsg("vmax")
                endif
                if s__ball_fly[this] then
                    call SetUnitX(s__ball_u[this], GetUnitX(s__ball_u[this]) + s__vector_x[s__ball_v[this]])
                    call SetUnitY(s__ball_u[this], GetUnitY(s__ball_u[this]) + s__vector_y[s__ball_v[this]])
                else
                    call s__vector_setLength(s__ball_v[this],s__vector_getLength(s__ball_v[this]) - hflength)
                    call SetUnitX(s__ball_u[this], GetUnitX(s__ball_u[this]) + s__vector_x[s__ball_v[this]])
                    call SetUnitY(s__ball_u[this], GetUnitY(s__ball_u[this]) + s__vector_y[s__ball_v[this]])
                    call s__vector_setLength(s__ball_v[this],s__vector_getLength(s__ball_v[this]) - hflength)
                endif
                set s__ball_life[this]=s__ball_life[this] - 1
                
                //collision
                if s__ball_ctype[this] != CTYPE_NONE then
                    if HasLiveEnemyInRange(s__ball_u[this] , s__ball_crange[this]) then
                        if s__ball_ctype[this] == CTYPE_BLOOM then
                            call s__ball_bloom(this)
                        else
                            call s__ball_through(this)
                        endif
                    endif
                    if s__ball_ctype[this] == CTYPE_THROUGH then
                        call s__ball_updateList(this)
                    endif
                endif
            else
                if s__ball_ctype[this] == CTYPE_BLOOM then
                    call s__ball_bloom(this)
                elseif s__ball_life[this] <= 0 then
                    call KillUnit(s__ball_u[this])
                endif
                call sc__ball_deallocate(this)
            endif
        endfunction
        
        function s__ball_create takes unit u,real dam,real dir,real speed returns integer
            local integer v=s__ball__allocate()
            local integer dec=GetHandleId(u)
            local integer tdec=GetUnitTypeId(u)
            
            set s__ball_v[v]=s__vector_create(speed * Cos(dir) , speed * Sin(dir))
            set s__ball_u[v]=u
            set s__ball_dam[v]=dam
            set s__ball_l[v]=s__unitList_create()
            
            if HaveSavedReal(ht, tdec, km) then
                set s__ball_m[v]=LoadReal(ht, tdec, km)
            endif
            if HaveSavedInteger(ht, tdec, kctype) then
                set s__ball_ctype[v]=LoadInteger(ht, tdec, kctype)
            endif
            if HaveSavedString(ht, tdec, keff) then
                set s__ball_eff[v]=LoadStr(ht, tdec, keff)
            endif
            if HaveSavedReal(ht, tdec, kcrange) then
                set s__ball_crange[v]=LoadReal(ht, tdec, kcrange)
            endif
            if HaveSavedReal(ht, tdec, kbrange) then
                set s__ball_brange[v]=LoadReal(ht, tdec, kbrange)
            endif
            if HaveSavedReal(ht, tdec, kkb) then
                set s__ball_kb[v]=LoadReal(ht, tdec, kkb)
            endif
            if HaveSavedBoolean(ht, tdec, kfly) then
                set s__ball_fly[v]=LoadBoolean(ht, tdec, kfly)
            endif
            if HaveSavedInteger(ht, tdec, klife) then
                set s__ball_life[v]=LoadInteger(ht, tdec, klife)
            endif
            //call AskLock(ballLock)
            //call Lock(ballLock)
            //call BJDebugMsg("create")
            set balls[ballNum]=v
            set s__ball_spot[v]=ballNum
            set ballNum=ballNum + 1
            call SaveInteger(ht, dec, kvel, s__ball_spot[v])
            //call UnLock(ballLock)
            return v
        endfunction
        function s__ball_onDestroy takes integer this returns nothing
            call s__unitList_deallocate(s__ball_l[this])
            call s__vector_deallocate(s__ball_v[this])
            //call AskLock(ballLock)
            //call Lock(ballLock)
            set ballNum=ballNum - 1
            set balls[s__ball_spot[this]]=balls[ballNum]
            set s__ball_spot[balls[ballNum]]=s__ball_spot[this]
            //call UnLock(ballLock)
            call RemoveSavedInteger(ht, GetHandleId(s__ball_u[this]), kvel)
            set s__ball_u[this]=null
            //call BJDebugMsg("destroy one total: " +I2S(ballNum))
        endfunction

//Generated destructor of ball
function s__ball_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ball_V[this]!=-1) then
        return
    endif
    call s__ball_onDestroy(this)
    set si__ball_V[this]=si__ball_F
    set si__ball_F=this
endfunction
    

//library Velocity ends
//library Bullet:
    function NewBullet takes unit u,real dir,real speed,real dam returns nothing
        call s__ball_create(u , dam , dir , speed)
    endfunction

//library Bullet ends
//library Shooter:
    
    function ShooterInit takes nothing returns nothing
        set shooternum=0
        set ksspot=GetNewKey()
    endfunction
    function Createhooter takes integer spellid,real dir,unit hero returns nothing
        
        if spellid == gunsdq then
            call sc__shooter_create(hero , gunsdqid , 50 , 5 , 0.1 , 6 , 1 , 40 * bj_DEGTORAD , dir)
        endif
    endfunction
    
    function Shooter___Shoot takes nothing returns nothing
        local timer t=GetExpiredTimer()
        call sc__shooter_shoot(shooters[LoadInteger(ht, GetHandleId(t), ksspot)])
        set t=null
    endfunction
    
        
         function s__shooter_shoot takes integer this returns nothing
            local real d
            local unit u
            local integer i
    if LoadBoolean(ht, GetHandleId(s__shooter_hero[this]), kstand) then
        if s__shooter_total[this] <= 0 then
            call sc__shooter_deallocate(this)
        else
            set i=0
            
            loop
                exitwhen i >= s__shooter_sn[this]
                call SetUnitAnimationByIndex(s__shooter_hero[this], 2)
                call SetUnitFacing(s__shooter_hero[this], s__shooter_dir[this] * bj_RADTODEG)
                set d=s__shooter_dir[this] + GetRandomReal(0 - s__shooter_rdir[this] / 2, s__shooter_rdir[this] / 2)
                set u=CreateUnit(GetOwningPlayer(s__shooter_hero[this]), s__shooter_bid[this], GetUnitX(s__shooter_hero[this]), GetUnitY(s__shooter_hero[this]), d)
                call NewBullet(u , d , s__shooter_speed[this] , s__shooter_dam[this])
                set i=i + 1
            endloop
            set s__shooter_total[this]=s__shooter_total[this] - 1
        endif
    else
        call sc__shooter_deallocate(this)
    endif
        set u=null
        endfunction
        
        function s__shooter_create takes unit hero,integer bid,real speed,real dam,real sr,integer sn,integer total,real rdir,real dir returns integer
            local integer s=s__shooter__allocate()
            set s__shooter_hero[s]=hero
            set s__shooter_bid[s]=bid
            set s__shooter_speed[s]=speed
            set s__shooter_dam[s]=dam
            set s__shooter_sr[s]=sr
            set s__shooter_sn[s]=sn
            set s__shooter_total[s]=total
            set s__shooter_rdir[s]=rdir
            set s__shooter_dir[s]=dir
            set s__shooter_t[s]=CreateTimer()
            set shooters[shooternum]=s
            set s__shooter_spot[s]=shooternum
            set shooternum=shooternum + 1
            call SaveInteger(ht, GetHandleId(s__shooter_t[s]), ksspot, s__shooter_spot[s])
            call s__shooter_shoot(s)
            call TimerStart(s__shooter_t[s], sr, true, function Shooter___Shoot)
            return s
        endfunction
        
        function s__shooter_onDestroy takes integer this returns nothing
            set s__shooter_hero[this]=null
            call RemoveSavedInteger(ht, GetHandleId(s__shooter_t[this]), ksspot)
            call DestroyTimer(s__shooter_t[this])
            set shooternum=shooternum - 1
            set shooters[s__shooter_spot[this]]=shooters[shooternum]
            set s__shooter_spot[shooters[shooternum]]=s__shooter_spot[this]
            set s__shooter_t[this]=null
        endfunction

//Generated destructor of shooter
function s__shooter_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__shooter_V[this]!=-1) then
        return
    endif
    call s__shooter_onDestroy(this)
    set si__shooter_V[this]=si__shooter_F
    set si__shooter_F=this
endfunction
        

//library Shooter ends
//===========================================================================
// 
// 鏉€鎴┖闂磛1.0 娴嬭瘯鐗?
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Sun Sep 20 17:04:55 2020
//   Map Author: 鏈＋闃垮悏
// 
//===========================================================================
//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************
function InitGlobals takes nothing returns nothing
    local integer i= 0
    set i=0
    loop
        exitwhen ( i > 4 )
        set udg_camera[i]=false
        set i=i + 1
    endloop
    set i=0
    loop
        exitwhen ( i > 7200 )
        set udg_oriseq[i]=0
        set i=i + 1
    endloop
    set udg_oriid=0
    set udg_mtu=100
    set udg_maxm=60
    set udg_mti=300
endfunction
//***************************************************************************
//*
//*  Items
//*
//***************************************************************************
function CreateAllItems takes nothing returns nothing
    local integer itemID
    call CreateItem('I000', - 1237.4, - 1868.5)
    call CreateItem('I000', - 2283.8, - 310.6)
    call CreateItem('I000', 217.2, 66.4)
    call CreateItem('I000', 366.6, - 339.7)
    call CreateItem('I000', 173.0, - 614.9)
    call CreateItem('I000', - 2041.1, 298.0)
    call CreateItem('I000', - 946.1, 1012.2)
    call CreateItem('I000', 308.5, - 42.2)
    call CreateItem('I000', 482.7, - 110.1)
    call CreateItem('I000', 320.0, - 176.5)
    call CreateItem('I000', 562.7, - 455.9)
    call CreateItem('I000', 286.7, - 508.1)
    call CreateItem('I000', - 2152.7, - 487.5)
    call CreateItem('I000', - 328.7, - 2132.2)
    call CreateItem('I000', - 15.2, - 2177.9)
    call CreateItem('I000', 1354.1, - 1259.3)
    call CreateItem('I000', 1542.8, - 999.0)
    call CreateItem('I000', 1687.3, - 595.5)
    call CreateItem('I000', 233.9, 804.2)
    call CreateItem('I000', - 372.7, 1001.2)
    call CreateItem('I001', - 419.6, 112.0)
    call CreateItem('I002', - 306.3, 106.6)
    call CreateItem('I003', - 340.4, - 27.8)
    call CreateItem('I004', - 255.5, 40.2)
endfunction
//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************
//===========================================================================
function CreateUnitsForPlayer11 takes nothing returns nothing
    local player p= Player(11)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u=CreateUnit(p, 'u000', - 1441.2, - 247.6, 329.469)
    set u=CreateUnit(p, 'u000', - 1438.7, - 314.1, 341.234)
    set u=CreateUnit(p, 'u000', - 1438.2, - 364.6, 351.708)
    set u=CreateUnit(p, 'u000', - 1432.5, - 415.5, 2.930)
    set u=CreateUnit(p, 'u000', - 1412.3, - 479.0, 18.126)
    set u=CreateUnit(p, 'u000', - 1400.4, - 519.4, 27.779)
    set u=CreateUnit(p, 'u000', - 1505.4, - 608.1, 27.779)
    set u=CreateUnit(p, 'u000', - 1517.3, - 567.7, 18.126)
    set u=CreateUnit(p, 'u000', - 1537.5, - 504.2, 2.930)
    set u=CreateUnit(p, 'u000', - 1546.1, - 336.2, 329.469)
    set u=CreateUnit(p, 'u000', - 1543.6, - 402.8, 341.234)
    set u=CreateUnit(p, 'u000', - 1572.9, - 707.6, 27.779)
    set u=CreateUnit(p, 'u000', - 1584.8, - 667.2, 18.126)
    set u=CreateUnit(p, 'u000', - 1605.0, - 603.7, 2.930)
    set u=CreateUnit(p, 'u000', - 1613.7, - 435.8, 329.469)
    set u=CreateUnit(p, 'u000', - 1611.1, - 502.3, 341.234)
    set u=CreateUnit(p, 'u000', - 1637.7, - 537.2, 27.779)
    set u=CreateUnit(p, 'u000', - 1649.6, - 496.9, 18.126)
    set u=CreateUnit(p, 'u000', - 1669.8, - 433.3, 2.930)
    set u=CreateUnit(p, 'u000', - 1678.4, - 265.4, 329.469)
    set u=CreateUnit(p, 'u000', - 1675.9, - 332.0, 341.234)
    set u=CreateUnit(p, 'u000', - 1573.5, - 399.2, 27.779)
    set u=CreateUnit(p, 'u000', - 1585.4, - 358.8, 18.126)
    set u=CreateUnit(p, 'u000', - 1605.6, - 295.3, 2.930)
    set u=CreateUnit(p, 'u000', - 1614.2, - 127.4, 329.469)
    set u=CreateUnit(p, 'u000', - 1611.7, - 193.9, 341.234)
endfunction
//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
endfunction
//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer11()
endfunction
//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreatePlayerBuildings()
    call CreatePlayerUnits()
endfunction
//***************************************************************************
//*
//*  Regions
//*
//***************************************************************************
function CreateRegions takes nothing returns nothing
    local weathereffect we
    set gg_rct_techunit=Rect(- 3296.0, - 3552.0, - 2912.0, - 3296.0)
    set gg_rct_origin1=Rect(224.0, - 32.0, 288.0, 32.0)
    set gg_rct_origin3=Rect(224.0, - 544.0, 288.0, - 480.0)
    set gg_rct_origin2=Rect(- 288.0, - 544.0, - 224.0, - 480.0)
    set gg_rct_origin0=Rect(- 288.0, - 32.0, - 224.0, 32.0)
endfunction
//***************************************************************************
//*
//*  Custom Script Code
//*
//***************************************************************************
//TESH.scrollpos=358
//TESH.alwaysfold=0
function InitHashtables takes nothing returns nothing
    call FlushParentHashtable(ht)
    set ht=InitHashtable()
endfunction
function haveEnemyInRange takes unit source,real radius returns boolean
    local group ydl_group
    local unit ydl_unit
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, GetUnitX(source), GetUnitY(source), radius, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if ( ( IsUnitAliveBJ(ydl_unit) == true ) and ( IsUnitEnemy(ydl_unit, GetOwningPlayer(source)) == true ) ) then
          return true
        endif
        endloop
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
    return false
endfunction
function GetFirstEnemyInRange takes unit source,real radius returns unit
    local group ydl_group
    local unit ydl_unit
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, GetUnitX(source), GetUnitY(source), radius, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if ( ( IsUnitAliveBJ(ydl_unit) == true ) and ( IsUnitEnemy(ydl_unit, GetOwningPlayer(source)) == true ) ) then
          return ydl_unit
        endif
        endloop
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
    return null
endfunction
function haveEnemyInRangeXY takes unit source,real x,real y,real radius returns boolean
    local group ydl_group
    local unit ydl_unit
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, radius, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if ( ( IsUnitAliveBJ(ydl_unit) == true ) and ( IsUnitEnemy(ydl_unit, GetOwningPlayer(source)) == true ) ) then
          return true
        endif
        endloop
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
    return false
endfunction
function InitBulletSystem takes integer gk returns integer
        set kbuldir=gk + 1
        set kbullif=gk + 2
        set kbuldam=gk + 3
        set kbuldamran=gk + 4
        set kbulraneff=gk + 5
        set kbulspe=gk + 6
        set kbulsou=gk + 7
        set kbulsiz=gk + 8
        set kbullet=gk + 9
        set kbulgro=gk + 10
        set kbulris=gk + 11
        return kbulris
endfunction
function BulletMoveLoop takes nothing returns nothing
      local timer t= GetExpiredTimer()
      local unit bullet=LoadUnitHandle(ht, GetHandleId(t), kbullet)
      local integer buldec=GetHandleId(bullet)
      local real ux
      local real uy
      local real tx
      local real ty
      local real dir
      local real spe
      local integer life= LoadInteger(ht, buldec, kbullif)
      local unit source
      local real size=LoadReal(ht, buldec, kbulsiz)
      local real dam
      local group gro
      local real ran
      if life > 0 then
         set ux=GetUnitX(bullet)
         set uy=GetUnitY(bullet)
         if haveEnemyInRange(bullet , size) then
            set ran=LoadReal(ht, buldec, kbuldamran)
            set source=LoadUnitHandle(ht, buldec, kbulsou)
            set dam=LoadReal(ht, buldec, kbuldam)
            set gro=LoadGroupHandle(ht, buldec, kbulgro)
            set life=rangeOneTimeChaosRisDamage(source , ux , uy , ran , dam , "Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl" , gro , life)
         endif
         set dir=LoadReal(ht, buldec, kbuldir)
         set spe=LoadReal(ht, buldec, kbulspe)
         set life=life - 1
         call SaveInteger(ht, buldec, kbullif, life)
         set tx=ux + spe * Cos(dir)
         set ty=uy + spe * Sin(dir)
         call SetUnitX(bullet, tx)
         call SetUnitY(bullet, ty)
      else
            call DestroyGroup(LoadGroupHandle(ht, buldec, kbulgro))
            call FlushChildHashtable(ht, GetHandleId(t))
            call FlushChildHashtable(ht, buldec)
            call RemoveUnit(bullet)
            call DestroyTimer(t)
      endif
      set t=null
      set bullet=null
      set source=null
      set gro=null
endfunction
function Bullet takes unit source,integer bulletid,real dir,real dam,real size,real damran,string raneff,real speed,integer life returns nothing
    local timer t=CreateTimer()
    local unit bullet=CreateUnit(GetOwningPlayer(source), bulletid, GetUnitX(source), GetUnitY(source), dir)
    local integer buldec=GetHandleId(bullet)
    set life=R2I(I2R(life) * GetRandomReal(0.9, 1.1))
    call SaveReal(ht, buldec, kbuldir, dir)
    call SaveReal(ht, buldec, kbuldam, dam)
    call SaveReal(ht, buldec, kbulsiz, size)
    call SaveReal(ht, buldec, kbuldamran, damran)
    call SaveStr(ht, buldec, kbulraneff, raneff)
    call SaveReal(ht, buldec, kbulspe, speed)
    call SaveInteger(ht, buldec, kbullif, life)
    call SaveUnitHandle(ht, buldec, kbulsou, source)
    call SaveGroupHandle(ht, buldec, kbulgro, CreateGroup())
    call SaveUnitHandle(ht, GetHandleId(t), kbullet, bullet)
    call TimerStart(t, 0.03, true, function BulletMoveLoop)
    set t=null
    set bullet=null
endfunction
function RifleBullet takes unit source,real dir returns nothing
    call Bullet(source , 'e000' , dir , 50 , 75 , 75 , "" , 50 , 33)
endfunction 
function Change takes nothing returns nothing
    local unit u
    if GetSpellAbilityId() == ranger then
        set u=GetTriggerUnit()
        call IssueImmediateOrderById(u, 851972)
        call UnitRemoveAbility(u, ranger)
        call UnitAddAbility(u, meeler)
    elseif GetSpellAbilityId() == meeler then
        set u=GetTriggerUnit()
        call IssueImmediateOrderById(u, 851972)
        call UnitRemoveAbility(u, meeler)
        call UnitAddAbility(u, ranger)
    endif
    set u=null
endfunction
function InitChangeSystem takes nothing returns integer
    call TriggerAddCondition(gausctrg, Condition(function Change))
    return gk
endfunction
function InitDestroyTriggerAll takes integer gk returns integer
    set ktrgcon=gk + 1
    return ktrgcon
endfunction
function DestroyTriggerAll takes trigger trg returns nothing
         local integer dec=GetHandleId(trg)
         call TriggerRemoveCondition(trg, LoadTriggerConditionHandle(ht, dec, ktrgcon))
         call DestroyTrigger(trg)
         call FlushChildHashtable(ht, dec)
endfunction
function ShootTimerAction takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local integer tdec=GetHandleId(t)
    local unit u=LoadUnitHandle(ht, tdec, kshootu)
    local integer udec=GetHandleId(u)
    local real dir
    local integer n=LoadInteger(ht, udec, kshootnum)
    if LoadBoolean(ht, udec, kstand) then
        set dir=LoadReal(ht, udec, kshootdir)
        call SetUnitAnimationByIndex(u, 2)
        call SetUnitFacing(u, dir * bj_RADTODEG)
        set dir=dir + 0.3 * ( GetRandomReal(0, offrad) - minrad )
        call RifleBullet(u , dir)
        set n=n - 1
        call SaveInteger(ht, udec, kshootnum, n)
        if n <= 0 then
            call RemoveSavedHandle(ht, udec, kst)
            call FlushChildHashtable(ht, tdec)
            call DestroyTimer(t)
        endif
    else
        call FlushChildHashtable(ht, tdec)
        call DestroyTimer(t)
        call RemoveSavedHandle(ht, udec, kst)
    endif
    set t=null
    set u=null
endfunction
function Shoot takes unit u,real dir returns nothing
    local timer t
    local integer dec
    local integer udec
    local integer i
    set udec=GetHandleId(u)
    if HaveSavedHandle(ht, udec, kst) == false then
        set t=CreateTimer()
        set dec=GetHandleId(t)
        call SaveReal(ht, udec, kshootdir, dir)
        call SaveUnitHandle(ht, dec, kshootu, u)
        call SaveInteger(ht, udec, kshootnum, 4)
        call TimerStart(t, 0.15, true, function ShootTimerAction)
        call SaveTimerHandle(ht, udec, kst, t)
    endif
    set t=null
endfunction
function ShootCondition takes nothing returns nothing
    local unit u
    local real dir
    local real ux
    local real uy
    local real ox
    local real oy
    local integer dec
    local boolean gunshoot=false
    local integer spellId=GetSpellAbilityId()
    local integer i=0
    loop
        exitwhen i >= gunscount
        if guns[i] == spellId then
            set i=gunscount
            set gunshoot=true
        endif
        set i=i + 1
    endloop
    set u=GetTriggerUnit()
    set dec=GetHandleId(u)
    if gunshoot then
        set ux=GetUnitX(u)
        set uy=GetUnitY(u)
        set ox=GetSpellTargetX()
        set oy=GetSpellTargetY()
        call IssueImmediateOrderById(u, 851972)
        call PauseUnit(u, true)
        call PauseUnit(u, false)
        set dir=Atan2(oy - uy, ox - ux)
        call SaveBoolean(ht, dec, kstand, true)
        call CreateShooter(spellId , dir , u)
    else
        call SaveBoolean(ht, dec, kstand, false)
    endif
    set u=null
endfunction
function RegisterShootSystem takes unit u returns nothing
    local trigger trg=CreateTrigger()
    call SaveTriggerHandle(ht, GetHandleId(u), kshoottrg, trg)
    call SaveTriggerConditionHandle(ht, GetHandleId(trg), ktrgcon, TriggerAddCondition(trg, Condition(function ShootCondition)))
    call TriggerRegisterUnitEvent(trg, u, EVENT_UNIT_SPELL_EFFECT)
    call TriggerRegisterUnitEvent(trg, u, EVENT_UNIT_ISSUED_ORDER)
    call TriggerRegisterUnitEvent(trg, u, EVENT_UNIT_ISSUED_POINT_ORDER)
    call TriggerRegisterUnitEvent(trg, u, EVENT_UNIT_ISSUED_TARGET_ORDER)
    set trg=null
endfunction
function InitShootSystem takes integer gk returns integer
    set guns[0]=gunsdq
    set gunscount=1
    set kst=gk + 1
    set krecover=gk + 2
    set kweapon=gk + 3
    set kshootu=gk + 4
    set kshootdir=gk + 5
    set kshootnum=gk + 6
    set krecris=gk + 7
    set kautonum=gk + 8
    set kfirrat=gk + 9
    set krecoil=gk + 10
    set kmagsiz=gk + 11
    set krembul=gk + 12
    set kshoottrg=gk + 13
    set kstand=gk + 14
    return kstand
endfunction 
function RegisterLeapRecoder takes unit u returns nothing
    call TriggerRegisterUnitEvent(leaptrg, u, EVENT_UNIT_ISSUED_POINT_ORDER)
    call TriggerRegisterUnitEvent(leaptrg, u, EVENT_UNIT_ISSUED_TARGET_ORDER)
endfunction
function RecordLeap takes nothing returns nothing
    local unit u
    local integer dec
    if GetIssuedOrderIdBJ() == String2OrderIdBJ("smart") then
        set u=GetTriggerUnit()
        set dec=GetHandleId(u)
        call SaveReal(ht, dec, kleapx, GetOrderPointX())
        call SaveReal(ht, dec, kleapy, GetOrderPointY())
    endif
    set u=null
endfunction
function InitLeapSystem takes integer gk returns integer
    set leaptrg=CreateTrigger()
    call TriggerAddCondition(leaptrg, Condition(function RecordLeap))
    set kleapx=gk + 1
    set kleapy=gk + 2
    return kleapy
endfunction
function RandomXInRect takes rect rec returns real
    return GetRandomReal(GetRectMinX(rec), GetRectMaxX(rec))
endfunction
function RandomYInRect takes rect rec returns real
    return GetRandomReal(GetRectMinY(rec), GetRectMaxY(rec))
endfunction
function CountItemsAction takes nothing returns nothing
    if GetItemTypeId(GetEnumItem()) == itemid then
        set itemcount=itemcount + 1
    endif
endfunction
function CountItemsInRect takes rect rec,integer id returns integer
    set itemcount=0
    set itemid=id
    call EnumItemsInRectBJ(rec, function CountItemsAction)
    return itemcount
endfunction
function InitCountItemsSystem takes integer gk returns integer
    return gk
endfunction
function CreateItemsInRect takes rect rec,integer itmType,integer number returns nothing
    local integer i
    set i=1
    loop
        exitwhen i > number
        call CreateItem(itmType, RandomXInRect(rec), RandomXInRect(rec))
        set i=i + 1
    endloop
endfunction
function DropAction takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local integer dec=GetHandleId(t)
    local integer max=LoadInteger(ht, dec, kdimax)
    local rect rec=LoadRectHandle(ht, dec, kdirec)
    local integer num=LoadInteger(ht, dec, kdinum)
    local integer iid=LoadInteger(ht, dec, kdiid)
    if CountItemsInRect(rec , iid) < max then
        call CreateItemsInRect(rec , iid , num)
    endif
    set t=null
endfunction
function DropItem takes integer id,integer itemid,real rate,integer num,rect rec,integer max returns nothing
    local timer t
    local integer dec
    if HaveSavedHandle(ht, ddrop, id) == false then
        set t=CreateTimer()
        set dec=GetHandleId(t)
        call SaveInteger(ht, dec, kdiid, itemid)
        call SaveRectHandle(ht, dec, kdirec, rec)
        call SaveInteger(ht, dec, kdinum, num)
        call SaveInteger(ht, dec, kdimax, max)
        call TimerStart(t, rate, true, function DropAction)
        call SaveTimerHandle(ht, ddrop, id, t)
    endif
    set t=null
endfunction
function StopDrop takes integer id returns nothing
    local timer t
    if HaveSavedHandle(ht, ddrop, id) then
        set t=LoadTimerHandle(ht, ddrop, id)
        call FlushChildHashtable(ht, GetHandleId(t))
        call DestroyTimer(t)
    endif
    set t=null
endfunction
function InitDropSystem takes integer gk returns integer
    set ddrop='H001'
    set kdiid=gk + 1
    set kdinum=gk + 2
    set kdirec=gk + 3
    set kdimax=gk + 4
    set droene=1
    return kdimax
endfunction
function BloomDead takes player p,real x,real y returns nothing
    local group ydl_group
    local unit ydl_unit
    local real ux
    local real uy
    local real dir
    local real d
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, 300, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if IsUnitAliveBJ(ydl_unit) == false and IsUnitEnemy(ydl_unit, p) == true then
            set ux=GetUnitX(ydl_unit)
            set uy=GetUnitY(ydl_unit)
            set d=GetRandomReal(400, 800)
            set dir=Atan2(uy - y, ux - x)
            call YDWEJumpTimer(ydl_unit , dir * bj_RADTODEG , d , 2 , 0.03 , 500)
            if d < 600 then
                call DestroyEffect(AddSpecialEffect("Objects\\Spawnmodels\\Human\\HumanLargeDeathExplode\\HumanLargeDeathExplode.mdl", ux, uy))
            endif
        endif
        endloop
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
endfunction
function NadeBloom takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local integer dec=GetHandleId(t)
    local unit u=LoadUnitHandle(ht, dec, knadeu)
    local real x=GetUnitX(u)
    local real y=GetUnitY(u)
    call rangeChaosDamage(udg_hero[GetPlayerId(GetOwningPlayer(u))] , x , y , 300 , 250 , "Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl")
    call KillUnit(u)
    call BloomDead(GetOwningPlayer(u) , x , y)
    set t=null
    set u=null
endfunction
function Nade takes nothing returns nothing
    local unit u
    local timer t
    local real x
    local real y
    local real dis
    local real dir
    local real tx
    local real ty
    local unit n
    if GetSpellAbilityId() == nade then
        set u=GetTriggerUnit()
        set t=CreateTimer()
        set x=GetUnitX(u)
        set y=GetUnitY(u)
        set tx=GetSpellTargetX()
        set ty=GetSpellTargetY()
        set dir=Atan2(ty - y, tx - x)
        set dis=SquareRoot(Pow(ty - y, 2) + Pow(tx - x, 2))
        set n=CreateUnit(GetOwningPlayer(u), nadeu, x, y, dir * bj_RADTODEG)
        call YDWEJumpTimer(n , dir * bj_RADTODEG , dis , 1 , 0.03 , 300)
        call SaveUnitHandle(ht, GetHandleId(t), knadeu, n)
        call TimerStart(t, 1, false, function NadeBloom)
        set u=null
        set t=null
        set n=null
    endif
endfunction
function InitNade takes integer gk returns integer
    set knadeu=gk + 1
    call TriggerAddCondition(gausetrg, Condition(function Nade))
    return knadeu
endfunction
function CloseLiveTechForPlayer takes player p returns nothing
    call RemoveUnit(udg_techlive[GetPlayerId(p)])
endfunction
function OpenLiveTechForPlayer takes player p returns nothing
    call CloseLiveTechForPlayer(p)
    set udg_techlive[GetPlayerId(p)]=CreateUnit(p, 'e002', GetRectCenterX(turec), GetRectCenterY(turec), 0)
endfunction
function InitTechUnitSystem takes integer gk returns integer
    return gk
endfunction
function HealMana takes unit u,real d returns nothing
    call SetUnitState(u, UNIT_STATE_MANA, GetUnitState(u, UNIT_STATE_MANA) + d)
endfunction
function LostMana takes unit u,real d returns nothing
    call SetUnitState(u, UNIT_STATE_MANA, GetUnitState(u, UNIT_STATE_MANA) - d)
endfunction
function Heal takes unit u,real d returns nothing
    call SetUnitState(u, UNIT_STATE_LIFE, GetUnitState(u, UNIT_STATE_LIFE) + d)
endfunction
function Lost takes unit u,real d returns nothing
    if UnitHasBuffBJ(u, laydown2) == false then
        call SetUnitState(u, UNIT_STATE_LIFE, GetUnitState(u, UNIT_STATE_LIFE) - d)
    endif
endfunction
function SetEC takes unit u,real r returns nothing
    call SaveReal(ht, GetHandleId(u), kegycsu, r)
endfunction
function RegisterEnergyConsume takes unit u returns nothing
    call SaveReal(ht, GetHandleId(u), kegycsu, 1)
    call GroupAddUnit(egygro, u)
endfunction
function ECGA takes nothing returns nothing
    local unit u=GetEnumUnit()
    local integer dec=GetHandleId(u)
    call LostMana(u , LoadReal(ht, dec, kegycsu))
    set u=null
endfunction
function EnergyConsume takes nothing returns nothing
    call ForGroup(egygro, function ECGA)
endfunction
function InitEnergySystem takes integer gk returns integer
    set kegycsu=gk + 1
    set egygro=CreateGroup()
    set egytrg=CreateTrigger()
    call TriggerAddCondition(egytrg, Condition(function EnergyConsume))
    call TriggerRegisterTimerEventPeriodic(egytrg, 1.00)
    return kegycsu
endfunction
function RemoveLayDowmState takes unit u returns nothing
    call UnitRemoveAbility(u, laydown)
    call UnitRemoveAbility(u, laydown2)
endfunction
function AddLayDownState takes unit u returns nothing
    call UnitAddAbility(u, laydown)
endfunction
function LayDownSelf takes unit u returns nothing
    call UnitAddAbility(u, 'Avul')
    call UnitAddAbility(u, revive)
    call AddLayDownState(u)
    call SetEC(u , 0.5)
    call CloseLiveTechForPlayer(GetOwningPlayer(u))
    call PauseUnit(u, true)
    call SetUnitAnimationByIndex(u, 3)
    call PauseUnit(u, false)
endfunction
function LayDown takes nothing returns nothing
    local real dam=GetEventDamage()
    local unit u=GetTriggerUnit()
    local real l= GetUnitStateSwap(UNIT_STATE_LIFE, u)
    if dam > l then
        set l=dam + 1
        call UnitAddAbilityBJ(ninelife, u)
        call SetUnitLifeBJ(u, l)
        call GroupAddUnitSimple(u, revgro)
        call EnableTrigger(revtrg)
    endif
    set u=null
endfunction
function RegisterReviveSystem takes unit u returns nothing
    local trigger trg=CreateTrigger()
    call TriggerRegisterUnitEvent(trg, u, EVENT_UNIT_DAMAGED)
    call TriggerAddCondition(trg, Condition(function LayDown))
    set trg=null
endfunction
function RemoveNineLifeGroupAction takes nothing returns nothing
    local unit u=GetEnumUnit()
    local real l= GetUnitStateSwap(UNIT_STATE_LIFE, u)
    call UnitRemoveAbilityBJ(ninelife, u)
    call SetUnitLifeBJ(u, l)
    call GroupRemoveUnitSimple(u, revgro)
    //call LayDownSelf(u)
    set u=null
endfunction
function RemoveNineLife takes nothing returns nothing
    call DisableTrigger(GetTriggeringTrigger())
    call ForGroupBJ(revgro, function RemoveNineLifeGroupAction)
endfunction
function Revive takes nothing returns nothing
    local unit u
    if GetSpellAbilityId() == revive then
        set u=GetTriggerUnit()
        call UnitRemoveAbility(u, 'Avul')
        call OpenLiveTechForPlayer(GetOwningPlayer(u))
        call UnitRemoveAbility(u, revive)
        call SetEC(u , 1)
        call Heal(u , 50)
        call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl", GetUnitX(u), GetUnitY(u)))
        call RemoveLayDowmState(u)
    endif
    set u=null
endfunction
function InitReviveSystem takes integer gk returns integer
    set revgro=CreateGroup()
    set revtrg=CreateTrigger()
    call TriggerAddAction(revtrg, function RemoveNineLife)
    call TriggerRegisterTimerEventPeriodic(revtrg, 0.00)
    call TriggerAddCondition(gausetrg, Condition(function Revive))
    return gk
endfunction
function LostNotDie takes unit u,real d returns nothing
    call SetUnitState(u, UNIT_STATE_LIFE, RMaxBJ(GetUnitState(u, UNIT_STATE_LIFE) - d, 1))
endfunction
function SetLL takes unit u,real r returns nothing
    call SaveReal(ht, GetHandleId(u), kll, r)
endfunction
function RegisterLostLife takes unit u returns nothing
    call SaveReal(ht, GetHandleId(u), kll, 0)
    call GroupAddUnit(llgro, u)
endfunction
function LLGA takes nothing returns nothing
    local unit u=GetEnumUnit()
    local integer dec=GetHandleId(u)
    call LostNotDie(u , LoadReal(ht, dec, kll))
    set u=null
endfunction
function LostLife takes nothing returns nothing
    call ForGroup(llgro, function LLGA)
endfunction
function InitLostLifeSystem takes integer gk returns integer
    set kll=gk + 1
    set llgro=CreateGroup()
    set lltrg=CreateTrigger()
    call TriggerAddCondition(lltrg, Condition(function LostLife))
    call TriggerRegisterTimerEventPeriodic(lltrg, 1.00)
    return kll
endfunction
function RegisterLifeLow takes unit u returns nothing
    call TriggerRegisterUnitLifeEvent(lifelowtrg, u, LESS_THAN, 2)
endfunction
function LifeLow takes nothing returns nothing
    call LayDownSelf(GetTriggerUnit())
endfunction
function InitLifeLowSystem takes integer gk returns integer
    set lifelowtrg=CreateTrigger()
    call TriggerAddCondition(lifelowtrg, Condition(function LifeLow))
    return gk
endfunction
function RegisterEnergyLow takes unit u returns nothing
    call TriggerRegisterUnitManaEvent(eltrg, u, LESS_THAN, 0)
    call TriggerRegisterUnitManaEvent(eltrg, u, GREATER_THAN, 0.1)
endfunction
function EnergyLow takes nothing returns nothing
    local unit u=GetTriggerUnit()
    if IsUnitAliveBJ(u) then
        if GetUnitState(u, UNIT_STATE_MANA) == 0 then
            call UnitAddAbility(u, elability)
            call SetLL(u , 5)
        else
            call UnitRemoveAbility(u, elability)
            call UnitRemoveAbility(u, elbuff)
            call SetLL(u , 0)
        endif
    endif
    set u=null
endfunction
function InitEnergyLowSystem takes integer gk returns integer
    set eltrg=CreateTrigger()
    set elability='A003'
    set elability2='A004'
    set elbuff='B000'
    call TriggerAddCondition(eltrg, Condition(function EnergyLow))
    return gk
endfunction
function Speed takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local integer id=GetHandleId(t)
    local real v=LoadReal(ht, id, kjsdv)
    local real dir
    local unit u
    if v <= 0 then
        call FlushChildHashtable(ht, id)
        call DestroyTimer(t)
    else
        set u=LoadUnitHandle(ht, id, kjsdu)
        set dir=LoadReal(ht, id, kjsddir)
        call SetUnitX(u, GetUnitX(u) + v * Cos(dir))
        call SetUnitY(u, GetUnitY(u) + v * Sin(dir))
        call SaveReal(ht, id, kjsdv, v - gjsdf)
    endif
    set t=null
    set u=null
endfunction
function AddSpeed takes unit u,real dir,real v returns nothing
    local timer t=CreateTimer()
    local integer id=GetHandleId(t)
    call SaveUnitHandle(ht, id, kjsdu, u)
    call SaveReal(ht, id, kjsddir, dir)
    call SaveReal(ht, id, kjsdv, v)
    call TimerStart(t, 0.02, true, function Speed)
    set t=null
endfunction
function InitJiaSuDuSystem takes integer gk returns integer
    set kjsdu=gk + 1
    set kjsdv=gk + 2
    set kjsddir=gk + 3
    return kjsddir
endfunction
function RangeJiTui takes player p,real x,real y,real r,real v returns nothing
    local group ydl_group
    local unit ydl_unit
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, r, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if ( ( ( IsUnitType(ydl_unit, UNIT_TYPE_MAGIC_IMMUNE) == false ) and ( ( IsUnitAliveBJ(ydl_unit) == true ) and ( IsUnitEnemy(ydl_unit, p) == true ) ) ) ) then
            call AddSpeed(ydl_unit , Atan2(GetUnitY(ydl_unit) - y, GetUnitX(ydl_unit) - x) , v - LoadReal(ht, GetUnitTypeId(ydl_unit), kmris))
        endif
        endloop
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
endfunction
function BloodyChaosDamage takes unit source,real x,real y,real dir,real radius,real damage,string efs returns nothing
    local group ydl_group
    local unit ydl_unit
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, radius, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if IsUnitAliveBJ(ydl_unit) == true and IsUnitEnemy(ydl_unit, GetOwningPlayer(source)) == true then
            call ChaosDamage(source , ydl_unit , damage)
            call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl", ydl_unit, "chest"))
        endif
        endloop
    call DestroyEffect(AddSpecialEffect(efs, x, y))
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
endfunction
function Strike takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local integer tdec=GetHandleId(t)
    local integer count=LoadInteger(ht, tdec, kmc)
    local unit u=LoadUnitHandle(ht, tdec, kmu)
    local unit tu
    local real ux
    local real uy
    local real x
    local real y
    local real dir
    if count > 100 and GetUnitAbilityLevel(u, ranger) > 0 and IsUnitAliveBJ(u) and GetUnitAbilityLevel(u, revive) == 0 then
        set tu=GetFirstEnemyInRange(u , 300)
        if not ( tu == null ) then
            set ux=GetUnitX(u)
            set uy=GetUnitY(u)
            set dir=Atan2(GetUnitY(tu) - uy, GetUnitX(tu) - ux)
            set x=ux + 100 * Cos(dir)
            set y=uy + 100 * Sin(dir)
            call RangeJiTui(GetOwningPlayer(u) , x , y , 200 , 8)
            call CreateUnit(GetOwningPlayer(u), mid, x, y, dir)
            call BloodyChaosDamage(u , x , y , dir , 200 , 100 , "Objects\\Spawnmodels\\Human\\HumanBlood\\BloodElfSpellThiefBlood.mdl")
            set count=0
        endif
    endif
    set count=count + 1
    call SaveInteger(ht, tdec, kmc, count)
    set u=null
    set t=null
endfunction
function RegisterMelee takes unit u returns nothing
    local timer t
    local integer udec=GetHandleId(u)
    local integer tdec
    if HaveSavedHandle(ht, udec, kmt) == false then
        set t=CreateTimer()
        set tdec=GetHandleId(t)
        call SaveUnitHandle(ht, tdec, kmu, u)
        call SaveInteger(ht, tdec, kmc, 0)
        call TimerStart(t, 0.02, true, function Strike)
    endif
    set t=null
endfunction
function InitMeleeSystem takes integer gk returns integer
    set kmt=gk + 1
    set kmu=gk + 2
    set kmc=gk + 3
    set kmris=gk + 4
    return kmris
endfunction
function Lose takes nothing returns nothing
    call CustomDefeatBJ(Player(0), "TRIGSTR_145")
    call CustomDefeatBJ(Player(1), "TRIGSTR_145")
    call CustomDefeatBJ(Player(2), "TRIGSTR_145")
    call CustomDefeatBJ(Player(3), "TRIGSTR_145")
endfunction
function Win takes nothing returns nothing
    call CustomVictoryBJ(Player(0), true, true)
    call CustomVictoryBJ(Player(1), true, true)
    call CustomVictoryBJ(Player(2), true, true)
    call CustomVictoryBJ(Player(3), true, true)
endfunction
function LoseCondition takes nothing returns nothing
    local boolean lose=true
    local integer i=0
    loop
    exitwhen i > 3
    if IsUnitAliveBJ(udg_hero[i]) then
        if GetUnitAbilityLevel(udg_hero[i], revive) > 0 and GetUnitState(udg_hero[i], UNIT_STATE_MANA) < 60.00 then
        else
            set lose=false
        endif
    endif
    set i=i + 1
    endloop
    if lose then
        call Lose()
    endif
endfunction
function InitLoseCondition takes nothing returns nothing
    call TriggerAddCondition(gg_trg_Lose, Condition(function LoseCondition))
endfunction
function MonsterTechUp takes nothing returns nothing
    call AddPlayerTechResearched(Player(11), 'R003', 1)
    call AddPlayerTechResearched(Player(11), 'R004', 1)
endfunction
function Spawn takes integer id,integer num returns nothing
    local integer ri
    local real x
    local real y
    local integer n=0
    loop
        exitwhen n >= num
        set n=n + 1
        set ri=GetRandomInt(1, 4)
        if ri == 1 then
            set x=minx
            set y=GetRandomReal(miny, maxy)
        elseif ri == 2 then
            set x=maxx
            set y=GetRandomReal(miny, maxy)
        elseif ri == 3 then
            set x=GetRandomReal(minx, maxy)
            set y=miny
        elseif ri == 4 then
            set x=GetRandomReal(minx, maxy)
            set y=maxy
        endif
        call CreateUnit(Player(11), id, x, y, 0)
    endloop
endfunction
function OriginalSequence takes nothing returns nothing
    if GetPlayerState(Player(11), PLAYER_STATE_RESOURCE_FOOD_USED) < udg_maxm then
        call Spawn(udg_oriseq[udg_oriid * 2] , udg_oriseq[udg_oriid * 2 + 1])
        set udg_oriid=udg_oriid + 1
        if udg_oriid > udg_mtu then
            set udg_mtu=udg_mtu + 100
            set udg_maxm=udg_maxm + 10
        endif
        if udg_oriid > udg_mti then
            set udg_mti=udg_mti + 300
            call MonsterTechUp()
        endif
        if udg_oriid > 1500 then
            call DestroyTimer(GetExpiredTimer())
        endif
    endif
endfunction
function StartOriginalSequence takes nothing returns nothing
    local timer t=CreateTimer()
    call TimerStart(t, 1, true, function OriginalSequence)
    set t=null
endfunction
function SeqAddSimple takes integer i,integer uid,integer n returns integer
    set udg_oriseq[i * 2]=uid
    set udg_oriseq[i * 2 + 1]=n
    return i + 1
endfunction
function SeqRest takes integer i returns integer
    return SeqAddSimple(i , 0 , 0)
endfunction
function InitOriginSequeuce takes nothing returns nothing
    local integer i=0
    local integer j=0
    loop
    exitwhen j > 1
    loop
        exitwhen i > 60 + j * 600
        set i=SeqAddSimple(i , 'u000' , 1)
    endloop
    loop
        exitwhen i > 120 + j * 600
        set i=SeqAddSimple(i , 'u000' , 2)
    endloop
    loop
        exitwhen i > 180 + j * 600
        set i=SeqAddSimple(i , 'u000' , 1)
        set i=SeqAddSimple(i , 'z000' , 1)
    endloop
    loop
        exitwhen i > 240 + j * 600
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'z000' , 1)
    endloop
    loop
        exitwhen i > 300 + j * 600
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'z000' , 2)
    endloop
    loop
        exitwhen i > 400 + j * 600
        set i=SeqRest(i)
    endloop
    loop
        exitwhen i > 500 + j * 600
        if ModuloInteger(i, 20) < 2 then
            set i=SeqAddSimple(i , 'u001' , 1)
        else
            set i=SeqAddSimple(i , 'u000' , 2)
            set i=SeqAddSimple(i , 'z000' , 2)
        endif
    endloop
    loop
        exitwhen i > 600 + j * 600
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'z000' , 2)
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'z000' , 2)
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'z000' , 2)
        set i=SeqAddSimple(i , 'z001' , 2)
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'z000' , 2)
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'z000' , 2)
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'z000' , 2)
        set i=SeqAddSimple(i , 'z001' , 2)
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'z000' , 2)
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'z000' , 2)
        set i=SeqAddSimple(i , 'u000' , 2)
        set i=SeqAddSimple(i , 'u001' , 1)
    endloop
    set j=j + 1
    endloop
    loop
        exitwhen i > 1500
            set i=SeqAddSimple(i , 'u001' , 1)
            set i=SeqAddSimple(i , 'z000' , 2)
            set i=SeqAddSimple(i , 'z001' , 1)
    endloop
    
endfunction
function InitSpawnSystem takes integer gk returns integer
    set minx=GetRectMinX(GetPlayableMapRect())
    set maxx=GetRectMaxX(GetPlayableMapRect())
    set miny=GetRectMinY(GetPlayableMapRect())
    set maxy=GetRectMaxY(GetPlayableMapRect())
    return gk
endfunction
function GetNearEnemy takes unit u returns unit
    local integer i=0
    local integer r=10
    local real t=99999999
    local real d
    loop
        exitwhen i > 3
        if not ( udg_hero[i] == null ) and IsUnitAliveBJ(udg_hero[i]) and GetUnitAbilityLevel(udg_hero[i], revive) == 0 then
            set d=YDWEDistanceBetweenUnits(u , udg_hero[i])
            if d < t then
                set t=d
                set r=i
            endif
        endif
        set i=i + 1
    endloop
    return udg_hero[r]
endfunction
function ApproachGA takes nothing returns nothing
    local unit u=GetEnumUnit()
    local unit tu=GetNearEnemy(u)
    local real d=YDWEDistanceBetweenUnits(u , tu)
    local real dir
    local real r
    local real x
    local real y
    if d <= 1000 then
        call GroupRemoveUnit(appgro, u)
        call GroupAddUnit(attgro, u)
    else
        set dir=GetRandomReal(0, 3.1416)
        set r=GetRandomReal(0, d / 2)
        set x=GetUnitX(tu) + r * Cos(dir)
        set y=GetUnitY(tu) + r * Sin(dir)
        call IssuePointOrderById(u, 851986, x, y)
    endif
    set u=null
    set tu=null
endfunction
function AIApproach takes nothing returns nothing
    call ForGroupBJ(appgro, function ApproachGA)
endfunction
function AIDispatch takes nothing returns nothing
    local unit u=GetTriggerUnit()
    if IsUnitOwnedByPlayer(u, Player(11)) then
        if IsUnitInGroup(u, appgro) == false then
            call GroupAddUnit(appgro, u)
        endif
    endif
    set u=null
endfunction
function AIAttackGA takes nothing returns nothing
    local unit u=GetEnumUnit()
    local unit tu=GetNearEnemy(u)
    local real r=YDWEDistanceBetweenUnits(u , tu)
    if r > 1000 then
        call GroupRemoveUnit(attgro, u)
        call GroupAddUnit(appgro, u)
    else
        call IssuePointOrderById(u, 851983, GetUnitX(tu), GetUnitY(tu))
    endif
    if IsUnitDeadBJ(u) then
        call GroupRemoveUnit(attgro, u)
        call GroupRemoveUnit(appgro, u)
    endif
    set u=null
    set tu=null
endfunction
function AIAttack takes nothing returns nothing
    call ForGroupBJ(attgro, function AIAttackGA)
endfunction
function InitAI takes integer gk returns integer
    set appt=CreateTimer()
    set attt=CreateTimer()
    set appgro=CreateGroup()
    set attgro=CreateGroup()
    set aitrg=CreateTrigger()
    call YDWETriggerRegisterEnterRectSimpleNull(aitrg , GetPlayableMapRect())
    call TimerStart(appt, 5, true, function AIApproach)
    call TimerStart(attt, 5, true, function AIAttack)
    call TriggerAddCondition(aitrg, Condition(function AIDispatch))
    return gk
endfunction
function AfterSpell takes nothing returns nothing
    if GetSpellAbilityId() == 'A00C' then
        call IssuePointOrderById(GetTriggerUnit(), 851983, GetSpellTargetX(), GetSpellTargetY())
    endif
endfunction
function InitAfterSpell takes integer gk returns integer
    set astrg=CreateTrigger()
    call TriggerRegisterPlayerUnitEventSimple(astrg, Player(11), EVENT_PLAYER_UNIT_SPELL_FINISH)
    call TriggerAddCondition(astrg, Condition(function AfterSpell))
    return gk
endfunction
function Dis takes real x,real y,real tx,real ty returns real
    return SquareRoot(Pow(ty - y, 2) + Pow(tx - x, 2))
endfunction
function SpellAI takes nothing returns nothing
    local unit u=GetTriggerUnit()
    if GetUnitTypeId(u) == 'u001' then
        if Dis(GetOrderPointX() , GetOrderPointY() , GetUnitX(u) , GetUnitY(u)) <= 700 then
            call DisableTrigger(GetTriggeringTrigger())
            call IssuePointOrderById(u, 852580, GetOrderPointX(), GetOrderPointY())
            call EnableTrigger(GetTriggeringTrigger())
        endif
    endif
    set u=null
endfunction
function InitSpellAI takes integer gk returns integer
    set saitrg=CreateTrigger()
    call TriggerRegisterPlayerUnitEventSimple(saitrg, Player(11), EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
    call TriggerAddCondition(saitrg, Condition(function SpellAI))
    return gk
endfunction
function Poison takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=LoadUnitHandle(ht, GetHandleId(t), kpoiu)
    local integer dec=GetHandleId(u)
    local integer sec=LoadInteger(ht, dec, kpoisec)
    local real dam=LoadReal(ht, dec, kpoidam)
    if sec < 1 then
        call UnitRemoveAbility(u, poibuff1)
        call UnitRemoveAbility(u, poibuff2)
        call DestroyTimer(t)
        call FlushChildHashtable(ht, GetHandleId(t))
        call RemoveSavedHandle(ht, dec, kpoit)
    else
        call LostNotDie(u , dam)
        set sec=sec - 1
        call SaveInteger(ht, dec, kpoisec, sec)
    endif
    set t=null
    set u=null
endfunction
function RemovePoison takes unit u returns nothing
endfunction
function AddPoison takes unit u,integer sec,real dam returns nothing
    local timer t
    local integer udec=GetHandleId(u)
    if HaveSavedHandle(ht, udec, kpoit) then
        call SaveInteger(ht, udec, kpoisec, LoadInteger(ht, udec, kpoisec) + sec)
        call SaveReal(ht, udec, kpoidam, ( LoadReal(ht, udec, kpoidam) + dam ) / 2)
    else
        set t=CreateTimer()
        call SaveInteger(ht, udec, kpoisec, sec)
        call SaveReal(ht, udec, kpoidam, dam)
        call SaveTimerHandle(ht, udec, kpoit, t)
        call SaveUnitHandle(ht, GetHandleId(t), kpoiu, u)
        call TimerStart(t, 1, true, function Poison)
        call UnitAddAbility(u, poibuff1)
    endif
    set t=null
endfunction
function RangeAddPoison takes unit s,real x,real y,real r,integer sec,real dam returns nothing
    local group ydl_group
    local unit ydl_unit
    local timer t
    local integer udec
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, r, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if IsUnitAliveBJ(ydl_unit) == true and IsUnitEnemy(ydl_unit, GetOwningPlayer(s)) == true and UnitHasBuffBJ(ydl_unit, laydown2) == false then
            set udec=GetHandleId(ydl_unit)
            if HaveSavedHandle(ht, udec, kpoit) then
                call SaveInteger(ht, udec, kpoisec, LoadInteger(ht, udec, kpoisec) + sec)
                call SaveReal(ht, udec, kpoidam, ( LoadReal(ht, udec, kpoidam) + dam ) / 2)
            else
                set t=CreateTimer()
                call SaveInteger(ht, udec, kpoisec, sec)
                call SaveReal(ht, udec, kpoidam, dam)
                call SaveTimerHandle(ht, udec, kpoit, t)
                call SaveUnitHandle(ht, GetHandleId(t), kpoiu, ydl_unit)
                call TimerStart(t, 1, true, function Poison)
                call UnitAddAbility(ydl_unit, poibuff1)
            endif
        endif
        endloop
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
    set t=null
endfunction
function InitPoisonBuff takes integer gk returns integer
    set kpoisec=gk + 1
    set kpoidam=gk + 2
    set kpoit=gk + 3
    set kpoiu=gk + 4
    return kpoiu
endfunction
function PoisonAbility takes nothing returns nothing
    local unit u=GetEventDamageSource()
    if GetUnitTypeId(u) == 'u001' then
        call AddPoison(GetTriggerUnit() , 10 , 2)
    endif
    set u=null
endfunction
function InitPoisonAbility takes nothing returns nothing
    set poitrg=CreateTrigger()
    call YDWESyStemAnyUnitDamagedRegistTrigger(poitrg)
    call TriggerAddCondition(poitrg, Condition(function PoisonAbility))
endfunction
function PoisonBreath takes nothing returns nothing
    local unit u
    local real ux
    local real uy
    local real tx
    local real ty
    local real x
    local real y
    local real dir
    local real d
    if GetSpellAbilityId() == 'A00C' then
        set u=GetTriggerUnit()
        set ux=GetUnitX(u)
        set uy=GetUnitY(u)
        set tx=GetSpellTargetX()
        set ty=GetSpellTargetY()
        set dir=Atan2(ty - uy, tx - ux)
        set d=350
        set x=ux + d * Cos(dir)
        set y=uy + d * Sin(dir)
        call rangeChaosDamage(u , x , y , d , 10 , "")
        call RangeAddPoison(u , x , y , d , 10 , 2)
    endif
    set u=null
endfunction
function InitPoisonBreath takes integer gk returns integer
    call TriggerAddCondition(gausetrg, Condition(function PoisonBreath))
    return gk
endfunction
function SynState takes nothing returns nothing
endfunction
function CreatePortrait takes player p returns nothing
    local timer t=CreateTimer()
    set udg_portrait[GetPlayerId(p)]=CreateUnit(p, 'H003', 0, 0, 0)
    call TimerStart(t, 0.2, true, function SynState)
    set t=null
endfunction
function RefreshUpDialogLabel takes integer i returns nothing
    local integer e=GetPlayerTechCountSimple(energy, Player(i)) * 20 + 50
    local integer s=GetPlayerTechCountSimple(stamina, Player(i)) * 20 + 50
    local integer p=GetPlayerTechCountSimple(speed, Player(i)) * 20 + 50
    call DialogClear(td[i])
    set upenergy[i]=DialogAddButton(td[i], egylbl + I2S(e) + food, 0)
    set upstamina[i]=DialogAddButton(td[i], stmlbl + I2S(s) + food, 0)
    set upspeed[i]=DialogAddButton(td[i], spelbl + I2S(p) + food, 0)
    set cancel[i]=DialogAddButton(td[i], "鍙栨秷", 0)
endfunction
function CreateUpDialogLabel takes integer i returns nothing
    local integer e=GetPlayerTechCountSimple(energy, Player(i)) * 20 + 50
    local integer s=GetPlayerTechCountSimple(stamina, Player(i)) * 20 + 50
    local integer p=GetPlayerTechCountSimple(speed, Player(i)) * 20 + 50
    set upenergy[i]=DialogAddButton(td[i], egylbl + I2S(e) + food, 0)
    set upstamina[i]=DialogAddButton(td[i], stmlbl + I2S(s) + food, 0)
    set upspeed[i]=DialogAddButton(td[i], spelbl + I2S(p) + food, 0)
    set cancel[i]=DialogAddButton(td[i], "鍙栨秷", 0)
endfunction
function TechUp takes nothing returns nothing
    local button b=GetClickedButtonBJ()
    local dialog d=GetClickedDialogBJ()
    local integer i=0
    local integer expned
    loop
        exitwhen td[i] == d or i > 3
        set i=i + 1
    endloop
    if b == upenergy[i] then
        set expned=GetPlayerTechCountSimple(energy, Player(i)) * 20 + 50
        if GetPlayerState(Player(i), PLAYER_STATE_RESOURCE_FOOD_USED) >= expned then
            call AddPlayerTechResearched(Player(i), energy, 1)
            call AdjustPlayerStateBJ(- expned, Player(i), PLAYER_STATE_RESOURCE_FOOD_USED)
            call RefreshUpDialogLabel(i)
            call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Levelup\\LevelupCaster.mdl", GetUnitX(udg_hero[i]), GetUnitY(udg_hero[i])))
        else
            call DisplayTextToPlayer(Player(i), 0, 0, failmsg)
        endif
    elseif b == upstamina[i] then
        set expned=GetPlayerTechCountSimple(stamina, Player(i)) * 20 + 50
        if GetPlayerState(Player(i), PLAYER_STATE_RESOURCE_FOOD_USED) >= expned then
            call AddPlayerTechResearched(Player(i), stamina, 1)
            call AdjustPlayerStateBJ(- expned, Player(i), PLAYER_STATE_RESOURCE_FOOD_USED)
            call RefreshUpDialogLabel(i)
            call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Levelup\\LevelupCaster.mdl", GetUnitX(udg_hero[i]), GetUnitY(udg_hero[i])))
        else
            call DisplayTextToPlayer(Player(i), 0, 0, failmsg)
        endif
    elseif b == upspeed[i] then
        set expned=GetPlayerTechCountSimple(speed, Player(i)) * 20 + 50
        if GetPlayerState(Player(i), PLAYER_STATE_RESOURCE_FOOD_USED) >= expned then
            call AddPlayerTechResearched(Player(i), speed, 1)
            call AdjustPlayerStateBJ(- expned, Player(i), PLAYER_STATE_RESOURCE_FOOD_USED)
            call RefreshUpDialogLabel(i)
            call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Levelup\\LevelupCaster.mdl", GetUnitX(udg_hero[i]), GetUnitY(udg_hero[i])))
        else
            call DisplayTextToPlayer(Player(i), 0, 0, failmsg)
        endif
    endif
    call DialogDisplay(Player(i), d, true)
    if b == cancel[i] then
        call DialogDisplay(Player(i), d, false)
    endif
    set d=null
    set b=null
endfunction
function InitTechDialog takes integer gk returns integer
    local integer i=0
    set uptrg=CreateTrigger()
    call TriggerAddCondition(uptrg, Condition(function TechUp))
    loop
        exitwhen i > 3
        set td[i]=DialogCreate()
        call CreateUpDialogLabel(i)
        call TriggerRegisterDialogEvent(uptrg, td[i])
        set i=i + 1
    endloop
    return gk
endfunction
function RegisterExp takes integer typid,integer exp returns nothing
    call SaveInteger(ht, typid, kexp, exp)
    
endfunction
function RegisterExpSystem takes player p returns nothing
endfunction
function AddExp takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local integer dec=GetUnitTypeId(u)
    local integer exp=LoadInteger(ht, dec, kexp)
    local player p=GetOwningPlayer(GetKillingUnitBJ())
    call AdjustPlayerStateBJ(exp, p, PLAYER_STATE_RESOURCE_FOOD_USED)
    set u=null
    set p=null
endfunction
function InitExpSystem takes integer gk returns integer
    set exptrg=CreateTrigger()
    call TriggerAddCondition(exptrg, Condition(function AddExp))
    call TriggerRegisterPlayerUnitEventSimple(exptrg, Player(11), EVENT_PLAYER_UNIT_DEATH)
    set kexp=gk + 1
    return kexp
endfunction
    
//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************
//===========================================================================
// Trigger: initialize
//===========================================================================
//TESH.scrollpos=72
//TESH.alwaysfold=0
 function TypeDataInit takes nothing returns nothing
        //鏁ｅ脊鏋?
        call SaveInteger(ht, gunsdqid, kctype, CTYPE_THROUGH)
        call SaveReal(ht, gunsdqid, kcrange, 50)
        call SaveBoolean(ht, gunsdqid, kfly, true)
        call SaveInteger(ht, gunsdqid, klife, 30)
        call SaveReal(ht, gunsdqid, km, 5)
        call SaveStr(ht, gunsdqid, keff, "Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl")
        //鍥炴棆闀?
        call SaveInteger(ht, gunhlbid, kctype, CTYPE_THROUGH)
        call SaveReal(ht, gunhlbid, kcrange, 75)
        call SaveBoolean(ht, gunhlbid, kfly, true)
        call SaveInteger(ht, gunhlbid, klife, 500)
        call SaveReal(ht, gunhlbid, km, 7.5)
        call SaveStr(ht, gunhlbid, keff, "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl")
        //鍓ョ毊鑰?
        call SaveReal(ht, mbpz, km, 20)
        //鍣瓊鍏?
        call SaveReal(ht, mshs, km, 20)
        //娼滀紡鑰?
        call SaveReal(ht, mqfz, km, 20)
    endfunction
function Trig_initializeActions takes nothing returns nothing
    local integer i=0
    call InitHashtables()
    set gk=InitBulletSystem(gk)
    set gk=InitDestroyTriggerAll(gk)
    set gk=InitShootSystem(gk)
    set gk=InitLeapSystem(gk)
    set gk=InitCountItemsSystem(gk)
    set gk=InitDropSystem(gk)
    call DropItem(droene , 'I000' , 10 , 1 , GetPlayableMapRect() , 8)
    set gk=InitEnergyLowSystem(gk)
    set gk=InitNade(gk)
    set gk=InitReviveSystem(gk)
    set gk=InitTechUnitSystem(gk)
    set gk=InitChangeSystem()
    set gk=InitMeleeSystem(gk)
    set gk=InitJiaSuDuSystem(gk)
    set gk=InitSpawnSystem(gk)
    call InitOriginSequeuce()
    set gk=InitAI(gk)
    set gk=InitSpellAI(gk)
    set gk=InitAfterSpell(gk)
    set gk=InitPoisonBuff(gk)
    //call InitPoisonAbility()
    set gk=InitPoisonBreath(gk)
    set gk=InitTechDialog(gk)
    set gk=InitExpSystem(gk)
    set gk=InitEnergySystem(gk)
    set gk=InitLostLifeSystem(gk)
    set gk=InitLifeLowSystem(gk)
    call InitLoseCondition()
    
    call CreateFogModifierRectBJ(true, Player(11), FOG_OF_WAR_VISIBLE, GetPlayableMapRect())
    call SaveInteger(ht, 'u000', kbulris, 6)
    call SaveInteger(ht, 'z000', kbulris, 3)
    call SaveInteger(ht, 'z001', kbulris, 10)
    call SaveInteger(ht, 'u001', kbulris, 20)
    call SaveReal(ht, 'u001', kmris, 10)
    call RegisterExp('u000' , 2)
    call RegisterExp('u001' , 10)
    call RegisterExp('z000' , 2)
    call RegisterExp('z001' , 10)
    
    set udg_orirct[0]=gg_rct_origin0
    set udg_orirct[1]=gg_rct_origin1
    set udg_orirct[2]=gg_rct_origin2
    set udg_orirct[3]=gg_rct_origin3
    
    call TypeDataInit()
    
    loop
    exitwhen i > 3
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
        call SetCameraFieldForPlayer(Player(i), CAMERA_FIELD_TARGET_DISTANCE, 2500.00, 0.50)
        call CreateFogModifierRectBJ(true, Player(i), FOG_OF_WAR_VISIBLE, GetPlayableMapRect())
        set udg_hero[i]=CreateUnit(Player(i), 'h000', GetRectCenterX(udg_orirct[i]), GetRectCenterY(udg_orirct[i]), 0)
        call RegisterShootSystem(udg_hero[i])
        call RegisterLeapRecoder(udg_hero[i])
        call RegisterEnergyLow(udg_hero[i])
        call RegisterLifeLow(udg_hero[i])
        call RegisterReviveSystem(udg_hero[i])
        call AddPlayerTechResearched(Player(i), 'R000', 1)
        call OpenLiveTechForPlayer(Player(i))
        call RegisterMelee(udg_hero[i])
        call RegisterExpSystem(Player(i))
        call RegisterEnergyConsume(udg_hero[i])
        call RegisterLostLife(udg_hero[i])
        call TriggerRegisterUnitEvent(gg_trg_cantmove, udg_hero[i], EVENT_UNIT_ISSUED_TARGET_ORDER)
        call TriggerRegisterUnitEvent(gg_trg_cantmove, udg_hero[i], EVENT_UNIT_ISSUED_POINT_ORDER)
    endif
    set i=i + 1
    endloop
    
    call StartOriginalSequence()
    
endfunction
//===========================================================================
function InitTrig_initialize takes nothing returns nothing
    set gg_trg_initialize=CreateTrigger()
    call TriggerAddAction(gg_trg_initialize, function Trig_initializeActions)
endfunction
//===========================================================================
// Trigger: camera
//===========================================================================
function Trig_cameraActions takes nothing returns nothing
    call SetCameraFieldForPlayer(GetTriggerPlayer(), CAMERA_FIELD_TARGET_DISTANCE, 2500.00, 0.50)
endfunction
//===========================================================================
function InitTrig_camera takes nothing returns nothing
    set gg_trg_camera=CreateTrigger()
    call TriggerRegisterPlayerChatEvent(gg_trg_camera, Player(0), ".c1", true)
    call TriggerRegisterPlayerChatEvent(gg_trg_camera, Player(1), ".c1", true)
    call TriggerRegisterPlayerChatEvent(gg_trg_camera, Player(2), ".c1", true)
    call TriggerRegisterPlayerChatEvent(gg_trg_camera, Player(3), ".c1", true)
    call TriggerAddAction(gg_trg_camera, function Trig_cameraActions)
endfunction
//===========================================================================
// Trigger: AnyUnitSpellEffectTrg
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: bordercontrol
//===========================================================================
function Trig_bordercontrolActions takes nothing returns nothing
    call RemoveUnit(GetTriggerUnit())
endfunction
//===========================================================================
function InitTrig_bordercontrol takes nothing returns nothing
    set gg_trg_bordercontrol=CreateTrigger()
    call YDWETriggerRegisterLeaveRectSimpleNull(gg_trg_bordercontrol , GetPlayableMapRect())
    call TriggerAddAction(gg_trg_bordercontrol, function Trig_bordercontrolActions)
endfunction
//===========================================================================
// Trigger: EnemyBugSystem2
//===========================================================================
function Trig_EnemyBugSystem2Conditions takes nothing returns boolean
    return ( ( IsUnitEnemy(GetTriggerUnit(), Player(0)) == true ) )
endfunction
function Trig_EnemyBugSystem2Actions takes nothing returns nothing
    call UnitAddAbility(GetTriggerUnit(), 'Aloc')
    call ShowUnitHide(GetTriggerUnit())
    call UnitRemoveAbility(GetTriggerUnit(), 'Aloc')
    call ShowUnitShow(GetTriggerUnit())
endfunction
//===========================================================================
function InitTrig_EnemyBugSystem2 takes nothing returns nothing
    set gg_trg_EnemyBugSystem2=CreateTrigger()
    call YDWETriggerRegisterEnterRectSimpleNull(gg_trg_EnemyBugSystem2 , GetPlayableMapRect())
    call TriggerAddCondition(gg_trg_EnemyBugSystem2, Condition(function Trig_EnemyBugSystem2Conditions))
    call TriggerAddAction(gg_trg_EnemyBugSystem2, function Trig_EnemyBugSystem2Actions)
endfunction
//===========================================================================
// Trigger: cantmove
//===========================================================================
function Trig_cantmoveConditions takes nothing returns boolean
    return ( ( ( GetIssuedOrderIdBJ() == String2OrderIdBJ("smart") ) or ( GetIssuedOrderIdBJ() == String2OrderIdBJ("move") ) or ( GetIssuedOrderIdBJ() == String2OrderIdBJ("patrol") ) ) and ( GetUnitAbilityLevel(GetTriggerUnit(), 'A008') >= 1 ) )
endfunction
function Trig_cantmoveActions takes nothing returns nothing
    call IssueImmediateOrderById(GetTriggerUnit(), 851972)
    call PauseUnit(GetTriggerUnit(), true)
    call PauseUnit(GetTriggerUnit(), false)
endfunction
//===========================================================================
function InitTrig_cantmove takes nothing returns nothing
    set gg_trg_cantmove=CreateTrigger()
    call TriggerAddCondition(gg_trg_cantmove, Condition(function Trig_cantmoveConditions))
    call TriggerAddAction(gg_trg_cantmove, function Trig_cantmoveActions)
endfunction
//===========================================================================
// Trigger: DeathEffect
//===========================================================================
function Trig_DeathEffectActions takes nothing returns nothing
    call DestroyEffect(AddSpecialEffect("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodFootman.mdl", GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit())))
endfunction
//===========================================================================
function InitTrig_DeathEffect takes nothing returns nothing
    set gg_trg_DeathEffect=CreateTrigger()
    call TriggerRegisterPlayerUnitEventSimple(gg_trg_DeathEffect, Player(11), EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddAction(gg_trg_DeathEffect, function Trig_DeathEffectActions)
endfunction
//===========================================================================
// Trigger: UpDialog
//===========================================================================
function Trig_UpDialogActions takes nothing returns nothing
    local integer id=GetPlayerId(GetTriggerPlayer())
    call DialogDisplay(GetTriggerPlayer(), td[id], true)
endfunction
//===========================================================================
function InitTrig_UpDialog takes nothing returns nothing
    set gg_trg_UpDialog=CreateTrigger()
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_UpDialog, Player(0))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_UpDialog, Player(1))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_UpDialog, Player(2))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_UpDialog, Player(3))
    call TriggerAddAction(gg_trg_UpDialog, function Trig_UpDialogActions)
endfunction
//===========================================================================
// Trigger: Lose
//===========================================================================
function Trig_LoseActions takes nothing returns nothing
endfunction
//===========================================================================
function InitTrig_Lose takes nothing returns nothing
    set gg_trg_Lose=CreateTrigger()
    call TriggerRegisterTimerEventPeriodic(gg_trg_Lose, 10.00)
    call TriggerAddAction(gg_trg_Lose, function Trig_LoseActions)
endfunction
//===========================================================================
// Trigger: Win
//===========================================================================
function Trig_WinConditions takes nothing returns boolean
    return ( ( GetPlayerState(Player(11), PLAYER_STATE_RESOURCE_FOOD_USED) == 0 ) and ( udg_oriid > 1500 ) )
endfunction
function Trig_WinActions takes nothing returns nothing
    call Win()
endfunction
//===========================================================================
function InitTrig_Win takes nothing returns nothing
    set gg_trg_Win=CreateTrigger()
    call TriggerRegisterTimerEventPeriodic(gg_trg_Win, 10.00)
    call TriggerAddCondition(gg_trg_Win, Condition(function Trig_WinConditions))
    call TriggerAddAction(gg_trg_Win, function Trig_WinActions)
endfunction
//===========================================================================
// Trigger: Leave
//===========================================================================
function Trig_LeaveActions takes nothing returns nothing
    local integer i=0
    local integer id=GetPlayerId(GetTriggerPlayer())
    call RemoveUnit(udg_hero[id])
    loop
    exitwhen i > 3
    call DisplayTextToPlayer(Player(i), 0, 0, GetPlayerName(GetTriggerPlayer()) + " 绂诲紑浜嗘父鎴?")
    set i=i + 1
    endloop
endfunction
//===========================================================================
function InitTrig_Leave takes nothing returns nothing
    set gg_trg_Leave=CreateTrigger()
    call TriggerRegisterPlayerEventLeave(gg_trg_Leave, Player(0))
    call TriggerRegisterPlayerEventLeave(gg_trg_Leave, Player(1))
    call TriggerRegisterPlayerEventLeave(gg_trg_Leave, Player(2))
    call TriggerRegisterPlayerEventLeave(gg_trg_Leave, Player(3))
    call TriggerAddAction(gg_trg_Leave, function Trig_LeaveActions)
endfunction
//===========================================================================
// Trigger: Vector
//===========================================================================
//TESH.scrollpos=142
//TESH.alwaysfold=0
// Trigger: Velocity
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: HashKeyManager
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: TargetFliter
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: RegisterM
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Damage
//===========================================================================
//TESH.scrollpos=355
//TESH.alwaysfold=0
//     |   \ /_\   /  |/  | /_\ /  _\|  __|   ||      D E A L   I T ,      ||
//     | |) / _ \ / / | / |/ _ \| |/||  __|   ||    D E T E C T   I T ,    ||
//     |___/_/ \_/_/|__/|_|_/ \_\___/|____|   ||     B L O C K   I T .     ||
//                            By Jesus4Lyf    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//                                                                    v 1.0.5
//      What is Damage?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Damage is a damage dealing, detection and blocking system. It implements
//          all such functionality. It also provides a means to detect what type
//          of damage was dealt, so long as all damage in your map is dealt using
//          this system's deal damage functions (except for basic attacks).
//
//          It is completely recursively defined, meaning if you deal damage on
//          taking damage, the type detection and other features like blocking
//          will not malfunction.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Create a new trigger object called Damage, go to 'Edit -> Convert to
//          Custom Text', and replace everything that's there with this script.
//
//          At the top of the script, there is a '//! external ObjectMerger' line.
//          Save your map, close your map, reopen your map, and then comment out this
//          line. Damage is now implemented. This line creates a dummy ability used
//          in the system in some circumstances with damage blocking.
//
//      Functions:
//     藟藟藟藟藟藟藟藟藟藟藟藟
//          function Damage_RegisterEvent takes trigger whichTrigger returns nothing
//              - This registers a special "any unit takes damage" event.
//              - This event supports dynamic trigger use.
//              - Only triggers registered on this event may block damage.
//              - Only fires when the damage dealt is not 0.
//
//          function Damage_RegisterZeroEvent takes trigger whichTrigger returns nothing
//              - The same as Damage_RegisterEvent, but for only zero damage events
//                (which are excluded from Damage_RegisterEvent).
//              - Note that getting the damage type may be unreliable, since spells
//                like faerie fire trigger 0 damage, but it will count as an attack.
//
//          function Damage_GetType takes nothing returns damagetype
//              - This will get the type of damage dealt, like an event response,
//                for when using a unit takes damage event (or the special event above).
//
//          function Damage_IsPhysical takes nothing returns boolean
//          function Damage_IsSpell takes nothing returns boolean
//          function Damage_IsPure takes nothing returns boolean
//              - Wrappers to simply check if Damage_GetType is certain types.
//
//          function Damage_IsAttack takes nothing returns boolean
//              - Checks if the damage is from a physical attack (so you can deal
//                physical damage without it being registered as an actual attack).
//
//          function Damage_Block takes real amount returns nothing
//          function Damage_BlockAll takes nothing returns nothing
//              - For use only with Damage_RegisterEvent.
//              - Blocks 'amount' of the damage dealt.
//              - Multiple blocks at once work correctly.
//              - Blocking more than 100% of the damage will block 100% instead.
//              - Damage_BlockAll blocks 100% of the damage being dealt.
//
//          function Damage_EnableEvent takes boolean enable returns nothing
//              - For disabling and re-enabling the special event.
//              - Use it to deal damage which you do not want to be detected by
//                the special event.
//
//          function UnitDamageTargetEx takes lots of things returns boolean
//              - Replaces UnitDamageTarget in your map, with the same arguments.
//
//          function Damage_Physical takes unit source, unit target, real amount,
//            attacktype whichType, boolean attack, boolean ranged returns boolean
//              - A clean wrapper for physical damage.
//              - 'attack' determines if this is to be treated as a real physical
//                attack or just physical type damage.
//              - 'ranged' determines if this is to be treated as a ranged or melee
//                attack.
//
//          function Damage_Spell takes unit source, unit target, real amount returns boolean
//              - A clean wrapper for spell damage.
//
//          function Damage_Pure takes unit source, unit target, real amount returns boolean
//              - A clean wrapper for pure type damage (universal type, 100% damage).
//          
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for helping me find a better way to think about damage blocking.
//
// Trigger: VectorManager
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: UnitList
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Bullet
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Shooter
//===========================================================================
//TESH.scrollpos=6
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterType
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Guns
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Attract
//===========================================================================
//TESH.scrollpos=109
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Concurrent
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIDS
//
// Default melee game initialization for all players
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//  
//        _   ___ ___  ___    _______________________________________________
//       /_\ |_ _|   \/ __|   ||     A D V A N C E D   I N D E X I N G     ||
//      / _ \ | || |) \__ \   ||                  A N D                    ||
//     /_/ \_\___|___/|___/   ||         D A T A   S T O R A G E           ||                      
//            By Jesus4Lyf    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//                                                                    v 1.0.3
//      What is AIDS?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          AIDS assigns unique integers between 1 and 8191 to units which enter
//          the map. These can be used for arrays and data attaching.
//          
//          AIDS also allows you to define structs which are created automatically
//          when units enter the map, and filtering which units should be indexed
//          as well as for which units these structs should be created.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Simply create a new trigger object called AIDS, go to 'Edit -> Convert
//          to Custom Text', and replace everything that's there with this script.
//
//          At the top of the script, there is a 'UnitIndexingFilter' constant
//          function. If the function returns true for the unit, then that unit
//          will be automatically indexed. Setting this to true will automatically
//          index all units. Setting it to false will disable automatic indexing.
//
//      Functions:
//     藟藟藟藟藟藟藟藟藟藟藟藟
//          function GetUnitId takes unit u returns integer
//              - This returns the index of an indexed unit. This will return 0
//                if the unit has not been indexed.
//              - This function inlines. It does not check if the unit needs an
//                index. This function is for the speed freaks.
//              - Always use this if 'UnitIndexingFilter' simply returns true.
//
//          function GetUnitIndex takes unit u returns integer
//              - This will return the index of a unit if it has one, or assign
//                an index if the unit doesn't have one (and return the new index).
//              - Use this if 'UnitIndexingFilter' doesn't return true.
//
//          function GetIndexUnit takes integer index returns unit
//              - This returns the unit which has been assigned the 'index'.
//
//      AIDS Structs:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - Insert: //! runtextmacro AIDS() at the top of a struct to make it
//            an AIDS struct.
//          - AIDS structs cannot be created or destroyed manually. Instead, they
//            are automatically created when an appropriate unit enters the map.
//          - You cannot give members default values in their declaration.
//            (eg: private integer i=5 is not allowed)
//          - You cannot use array members.
//          - AIDS structs must "extend array". This will remove some unused
//            functions and enforce the above so there will be no mistakes.
//          - There are four optional methods you can use in AIDS structs:
//              - AIDS_onCreate takes nothing returns nothing
//                  - This is called when the struct is 'created' for the unit.
//                  - In here you can assign members their default values, which
//                    you would usually assign in their declarations.
//                    (eg: set this.i=5)
//              - AIDS_onDestroy takes nothing returns nothing
//                  - This is called when the struct is 'destroyed' for the unit.
//                  - This is your substitute to the normal onDestroy method.
//              - AIDS_filter takes unit u returns boolean
//                  - This is similar to the constant filter in the main system.
//                  - Each unit that enters the map will be tested by each AIDS
//                    struct filter. If it returns true for that unit, that unit
//                    will be indexed if it was not already, the AIDS struct will
//                    have its AIDS_onCreate method called, and later have its
//                    AIDS_onDestroy method called when the index is recycled.
//                  - Not declaring this will use the default AIDS filter instead.
//              - AIDS_onInit takes nothing returns nothing
//                  - This is because I stole your onInit function with my textmacro.
//          - You can use '.unit' from any AIDS struct to get the unit for which
//            the struct is for.
//          - The structs id will be the units index, so getting the struct for
//            a unit inlines to a single native call, and you can typecast between
//            different AIDS structs. This is the premise of AIDS.
//          - Never create or destroy AIDS structs directly.
//          - You can call .AIDS_addLock() and AIDS_removeLock() to increase or
//            decrease the lock level on the struct. If a struct's lock level is
//            not 0, it will not be destroyed until it is reduced to 0. Locks just
//            put off AIDS struct destruction in case you wish to attach to a timer
//            or something which must expire before the struct data disappears.
//            Hence, not freeing all locks will leak the struct (and index).
//
//      PUI and AutoIndex:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - AIDS includes the PUI textmacros and the AutoIndex module, because
//            these systems are not compatible with AIDS but have valid and distinct
//            uses.
//          - The PUI textmacros are better to use for spells than AIDS structs,
//            because they are not created for all units, just those targetted by
//            the spell (or whatever else is necessary).
//          - The AutoData module is good for very simple array syntax for data
//            attachment (although I don't recommend that people actually use it,
//            it's here mostly for compatability). Note that unlike the PUI textmacros,
//            units must pass the AIDS filter in order for this module to work with
//            them. This is exactly as the same as in AutoIndex itself (AutoIndex
//            has a filter too).
//          
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for writing 90% of this user documentation, challenging my
//            interface, doing some testing, suggesting improvements and inspiring
//            me to re-do my code to include GetUnitIndex as non-inlining.
//          - grim001, for writing the AutoData module, and AutoIndex. I used the
//            on-enter-map method that he used. Full credits for the AutoData module.
//          - Cohadar, for writing his PUI textmacros. Full credits to him for these,
//            except for my slight optimisations for this system.
//            Also, I have used an optimised version of his PeriodicRecycler from
//            PUI in this system to avoid needing a RemoveUnitEx function.
//          - Vexorian, for helping Cohadar on the PUI textmacro.
//          - Larcenist, for suggesting the AIDS acronym. Originally he suggested
//            'Alternative Index Detection System', but obviously I came up with
//            something better. In fact, I'd say it looks like the acronym was
//            an accident. Kinda neat, don't you think? :P
//
//      Final Notes:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - With most systems, I wouldn't usually add substitutes for alternative
//            systems. However, UnitData systems are an exception, because they
//            are incompatible with eachother. Since using this system forbids
//            people from using the real PUI or AutoIndex, and a lot of resources
//            use either of these, it made sense not to break them all.
//
//          - If this documentation confused you as to how to use the system, just
//            leave everything as default and use GetUnitId everywhere.
//
//          - To use this like PUI (if you don't like spamming indices) simply
//            make the AIDS filter return false, and use GetUnitIndex.
//
//===========================================================================
// Trigger: Event
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  ~~    Event     ~~    By Jesus4Lyf    ~~    Version 1.02    ~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  What is Event?
//         - Event simulates Warcraft III events. They can be created,
//           registered for, fired and also destroyed.
//         - Event, therefore, can also be used like a trigger "group".
//         - This was created when there was an influx of event style systems 
//           emerging that could really benefit from a standardised custom
//           events snippet. Many users were trying to achieve the same thing
//           and making the same kind of errors. This snippet aims to solve that.
//
//  Functions:
//         - Event.create()     --> Creates a new Event.
//         - .chainDestroy()    --> Destroys an Event.
//                                  DO NOT use .destroy().
//         - .fire()            --> Fires all triggers which have been
//                                  registered on this Event.
//         - .register(trigger) --> Registers another trigger on this Event.
//
//  Details:
//         - Event is extremely efficient and lightweight.
//         - It is safe to use with dynamic triggers.
//         - Internally, it is just a singularly linked list. Very simple.
//
//  How to import:
//         - Create a trigger named Event.
//         - Convert it to custom text and replace the whole trigger text with this.
//
//  Thanks:
//         - Builder Bob for the trigger destroy detection method.
//         - Azlier for inspiring this by ripping off my dodgier code.
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//===========================================================================
// Trigger: BulletSpell
//===========================================================================
//TESH.scrollpos=6
//TESH.alwaysfold=0
// scope BulletSpell begins
    function BulletSpellMove takes nothing returns nothing
        local unit b
        local unit hero
        local real x
        local real y
        local real ox
        local real oy
        local real dir
        set hero=GetTriggerUnit()
        set x=GetUnitX(hero)
        set y=GetUnitY(hero)
        set ox=GetSpellTargetX()
        set oy=GetSpellTargetY()
        set dir=Atan2(oy - y, ox - x)
        if GetSpellAbilityId() == gunhlb then
            set b=CreateUnit(GetOwningPlayer(hero), gunhlbid, x, y, dir)
            call NewBullet(b , dir , 50 , 5)
            call s__trc2dth_create(hero , b , 1.5 , 3.1416 / 3 , 1 , 600)
        endif
        set b=null
        set hero=null
    endfunction
    function BulletSpellInit takes nothing returns nothing
        call TriggerAddCondition(gausetrg, Condition(function BulletSpellMove))
    endfunction
    
// scope BulletSpell ends
//===========================================================================
// Trigger: GravityClash
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
// scope GravityClash begins
    
    function GravityClash takes nothing returns nothing
        local unit hero
        local group g
        local unit u
        local real x
        local real y
        local real m
        if GetSpellAbilityId() == sgc then
            set hero=GetTriggerUnit()
            set x=GetUnitX(hero)
            set y=GetUnitY(hero)
            set g=CreateGroup()
            call GroupEnumUnitsInRange(g, x, y, 600, null)
            call DestroyEffect(AddSpecialEffect(sgc_eff, x, y))
            loop
                set u=FirstOfGroup(g)
                exitwhen u == null
                call GroupRemoveUnit(g, u)
                if IsLiveEnemy(hero , u) then
                set m=LoadReal(ht, GetUnitTypeId(u), km)
                call AddVector(u , Atan2(GetUnitY(u) - y, GetUnitX(u) - x) , sgc_kb / m)
                call Damage_Spell(hero , u , sgc_dam)
                endif
            endloop
        endif
        set hero=null
        set u=null
        set g=null
    endfunction
    function GravityClashInit takes nothing returns nothing
        call TriggerAddCondition(gausetrg, Condition(function GravityClash))
    endfunction
// scope GravityClash ends
//===========================================================================
// Trigger: leap
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_leapConditions takes nothing returns boolean
    return ( ( GetSpellAbilityId() == 'A000' ) )
endfunction
function Trig_leapActions takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local integer dec=GetHandleId(u)
    local real lx=LoadReal(ht, dec, kleapx)
    local real ly=LoadReal(ht, dec, kleapy)
    local real dir=Atan2(ly - GetUnitY(u), lx - GetUnitX(u))
    call YDWEJumpTimer(u , dir * bj_RADTODEG , 400.00 , 0.50 , 0.03 , 150.00)
    set u=null
endfunction
//===========================================================================
function InitTrig_leap takes nothing returns nothing
    set gg_trg_leap=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_leap, EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(gg_trg_leap, Condition(function Trig_leapConditions))
    call TriggerAddAction(gg_trg_leap, function Trig_leapActions)
endfunction
//===========================================================================
// Trigger: energy
//===========================================================================
function Trig_energyConditions takes nothing returns boolean
    return ( ( GetItemTypeId(GetManipulatedItem()) == 'I000' ) )
endfunction
function Trig_energyActions takes nothing returns nothing
    call RemoveItem(GetManipulatedItem())
endfunction
//===========================================================================
function InitTrig_energy takes nothing returns nothing
    set gg_trg_energy=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_energy, EVENT_PLAYER_UNIT_PICKUP_ITEM)
    call TriggerAddCondition(gg_trg_energy, Condition(function Trig_energyConditions))
    call TriggerAddAction(gg_trg_energy, function Trig_energyActions)
endfunction
//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_initialize()
    call InitTrig_camera()
    //Function not found: call InitTrig_AnyUnitSpellEffectTrg()
    call InitTrig_bordercontrol()
    call InitTrig_EnemyBugSystem2()
    call InitTrig_cantmove()
    call InitTrig_DeathEffect()
    call InitTrig_UpDialog()
    call InitTrig_Lose()
    call InitTrig_Win()
    call InitTrig_Leave()
    //Function not found: call InitTrig_Vector()
    //Function not found: call InitTrig_Velocity()
    //Function not found: call InitTrig_HashKeyManager()
    //Function not found: call InitTrig_TargetFliter()
    //Function not found: call InitTrig_RegisterM()
    //Function not found: call InitTrig_Damage()
    //Function not found: call InitTrig_VectorManager()
    //Function not found: call InitTrig_UnitList()
    //Function not found: call InitTrig_Bullet()
    //Function not found: call InitTrig_Shooter()
    //Function not found: call InitTrig_MonsterType()
    //Function not found: call InitTrig_Guns()
    //Function not found: call InitTrig_Attract()
    //Function not found: call InitTrig_Concurrent()
    //Function not found: call InitTrig_AIDS()
    //Function not found: call InitTrig_Event()
    //Function not found: call InitTrig_BulletSpell()
    //Function not found: call InitTrig_GravityClash()
    call InitTrig_leap()
    call InitTrig_energy()
endfunction
//===========================================================================
function RunInitializationTriggers takes nothing returns nothing
    call ConditionalTriggerExecute(gg_trg_initialize)
endfunction
//***************************************************************************
//*
//*  Players
//*
//***************************************************************************
function InitCustomPlayerSlots takes nothing returns nothing
    // Player 0
    call SetPlayerStartLocation(Player(0), 0)
    call ForcePlayerStartLocation(Player(0), 0)
    call SetPlayerColor(Player(0), ConvertPlayerColor(0))
    call SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(0), false)
    call SetPlayerController(Player(0), MAP_CONTROL_USER)
    // Player 1
    call SetPlayerStartLocation(Player(1), 1)
    call ForcePlayerStartLocation(Player(1), 1)
    call SetPlayerColor(Player(1), ConvertPlayerColor(1))
    call SetPlayerRacePreference(Player(1), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(1), false)
    call SetPlayerController(Player(1), MAP_CONTROL_USER)
    // Player 2
    call SetPlayerStartLocation(Player(2), 2)
    call ForcePlayerStartLocation(Player(2), 2)
    call SetPlayerColor(Player(2), ConvertPlayerColor(2))
    call SetPlayerRacePreference(Player(2), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(2), false)
    call SetPlayerController(Player(2), MAP_CONTROL_USER)
    // Player 3
    call SetPlayerStartLocation(Player(3), 3)
    call ForcePlayerStartLocation(Player(3), 3)
    call SetPlayerColor(Player(3), ConvertPlayerColor(3))
    call SetPlayerRacePreference(Player(3), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(3), false)
    call SetPlayerController(Player(3), MAP_CONTROL_USER)
    // Player 11
    call SetPlayerStartLocation(Player(11), 4)
    call SetPlayerColor(Player(11), ConvertPlayerColor(11))
    call SetPlayerRacePreference(Player(11), RACE_PREF_UNDEAD)
    call SetPlayerRaceSelectable(Player(11), false)
    call SetPlayerController(Player(11), MAP_CONTROL_COMPUTER)
endfunction
function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_072
    call SetPlayerTeam(Player(0), 0)
    call SetPlayerTeam(Player(1), 0)
    call SetPlayerTeam(Player(2), 0)
    call SetPlayerTeam(Player(3), 0)
    //   Allied
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(2), true)
    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(2), true)
    // Force: TRIGSTR_073
    call SetPlayerTeam(Player(11), 1)
endfunction
function InitAllyPriorities takes nothing returns nothing
    call SetStartLocPrioCount(0, 3)
    call SetStartLocPrio(0, 0, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrioCount(1, 3)
    call SetStartLocPrio(1, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrioCount(2, 3)
    call SetStartLocPrio(2, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrioCount(3, 3)
    call SetStartLocPrio(3, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 2, 2, MAP_LOC_PRIO_HIGH)
endfunction
//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************
//===========================================================================
function main takes nothing returns nothing
    local weathereffect we
    call SetCameraBounds(- 7424.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), - 8192.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 7424.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 6656.0 - GetCameraMargin(CAMERA_MARGIN_TOP), - 7424.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 6656.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 7424.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), - 8192.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
    call SetDayNightModels("Environment\\DNC\\DNCDalaran\\DNCDalaranTerrain\\DNCDalaranTerrain.mdl", "Environment\\DNC\\DNCDalaran\\DNCDalaranUnit\\DNCDalaranUnit.mdl")
    call SetTerrainFogEx(0, 0.0, 10000.0, 0.100, 0.000, 0.000, 0.000)
    set we=AddWeatherEffect(Rect(- 8192.0, - 8704.0, 8192.0, 7680.0), 'RAhr')
    call EnableWeatherEffect(we, true)
    call NewSoundEnvironment("Default")
    call SetAmbientDaySound("DalaranDay")
    call SetAmbientNightSound("DalaranNight")
    call SetMapMusic("Music", true, 0)
    call CreateRegions()
    call CreateAllItems()
    call CreateAllUnits()
    call InitBlizzard()

call ExecuteFunc("jasshelper__initstructs21600818")
call ExecuteFunc("AIDS___InitAIDS")
call ExecuteFunc("AnyUnitSpellEffectTrgInit")
call ExecuteFunc("InitializeYD")
call ExecuteFunc("AttractInit")
call ExecuteFunc("InitRegisterM")
call ExecuteFunc("Velocity___Init")
call ExecuteFunc("ShooterInit")
call BulletSpellInit()
call GravityClashInit()

    call InitGlobals()
    call InitCustomTriggers()
    call RunInitializationTriggers()
endfunction
//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************
function config takes nothing returns nothing
    call SetMapName("TRIGSTR_010")
    call SetMapDescription("TRIGSTR_012")
    call SetPlayers(5)
    call SetTeams(5)
    call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)
    call DefineStartLocation(0, 0.0, - 256.0)
    call DefineStartLocation(1, 0.0, - 256.0)
    call DefineStartLocation(2, 0.0, - 256.0)
    call DefineStartLocation(3, 0.0, - 256.0)
    call DefineStartLocation(4, 0.0, - 256.0)
    // Player setup
    call InitCustomPlayerSlots()
    call InitCustomTeams()
    call InitAllyPriorities()
endfunction
//===========================================================================  
//===========================================================================  
//自定义事件 
//===========================================================================
//===========================================================================   
//===========================================================================
//跳跃系统 
//===========================================================================




//Struct method generated initializers/callers:
function sa__shooter_shoot takes nothing returns boolean
local integer this=f__arg_this
            local real d
            local unit u
            local integer i
    if LoadBoolean(ht, GetHandleId(s__shooter_hero[this]), kstand) then
        if s__shooter_total[this] <= 0 then
            call sc__shooter_deallocate(this)
        else
            set i=0
            loop
                exitwhen i >= s__shooter_sn[this]
                call SetUnitAnimationByIndex(s__shooter_hero[this], 2)
                call SetUnitFacing(s__shooter_hero[this], s__shooter_dir[this] * bj_RADTODEG)
                set d=s__shooter_dir[this] + GetRandomReal(0 - s__shooter_rdir[this] / 2, s__shooter_rdir[this] / 2)
                set u=CreateUnit(GetOwningPlayer(s__shooter_hero[this]), s__shooter_bid[this], GetUnitX(s__shooter_hero[this]), GetUnitY(s__shooter_hero[this]), d)
                call NewBullet(u , d , s__shooter_speed[this] , s__shooter_dam[this])
                set i=i + 1
            endloop
            set s__shooter_total[this]=s__shooter_total[this] - 1
        endif
    else
        call sc__shooter_deallocate(this)
    endif
        set u=null
   return true
endfunction
function sa__shooter_create takes nothing returns boolean
    set f__result_integer=s__shooter_create(f__arg_unit1,f__arg_integer1,f__arg_real1,f__arg_real2,f__arg_real3,f__arg_integer2,f__arg_integer3,f__arg_real4,f__arg_real5)
   return true
endfunction
function sa__shooter_onDestroy takes nothing returns boolean
local integer this=f__arg_this
            set s__shooter_hero[this]=null
            call RemoveSavedInteger(ht, GetHandleId(s__shooter_t[this]), ksspot)
            call DestroyTimer(s__shooter_t[this])
            set shooternum=shooternum - 1
            set shooters[s__shooter_spot[this]]=shooters[shooternum]
            set s__shooter_spot[shooters[shooternum]]=s__shooter_spot[this]
            set s__shooter_t[this]=null
   return true
endfunction
function sa__ball_move takes nothing returns boolean
local integer this=f__arg_this
            local real hflength=vf * s__ball_m[this] / 2
            if ( s__ball_life[this] > 0 and s__vector_getLength(s__ball_v[this]) >= hflength ) or ( s__ball_life[this] > 0 and ( s__vector_getLength(s__ball_v[this]) < hflength and s__ball_ctype[this] != CTYPE_NONE ) ) then
                if s__vector_getLength(s__ball_v[this]) > vmax then
                    call s__vector_setLength(s__ball_v[this],vmax)
                    call BJDebugMsg("vmax")
                endif
                if s__ball_fly[this] then
                    call SetUnitX(s__ball_u[this], GetUnitX(s__ball_u[this]) + s__vector_x[s__ball_v[this]])
                    call SetUnitY(s__ball_u[this], GetUnitY(s__ball_u[this]) + s__vector_y[s__ball_v[this]])
                else
                    call s__vector_setLength(s__ball_v[this],s__vector_getLength(s__ball_v[this]) - hflength)
                    call SetUnitX(s__ball_u[this], GetUnitX(s__ball_u[this]) + s__vector_x[s__ball_v[this]])
                    call SetUnitY(s__ball_u[this], GetUnitY(s__ball_u[this]) + s__vector_y[s__ball_v[this]])
                    call s__vector_setLength(s__ball_v[this],s__vector_getLength(s__ball_v[this]) - hflength)
                endif
                set s__ball_life[this]=s__ball_life[this] - 1
                if s__ball_ctype[this] != CTYPE_NONE then
                    if HasLiveEnemyInRange(s__ball_u[this] , s__ball_crange[this]) then
                        if s__ball_ctype[this] == CTYPE_BLOOM then
                            call s__ball_bloom(this)
                        else
                            call s__ball_through(this)
                        endif
                    endif
                    if s__ball_ctype[this] == CTYPE_THROUGH then
                        call s__ball_updateList(this)
                    endif
                endif
            else
                if s__ball_ctype[this] == CTYPE_BLOOM then
                    call s__ball_bloom(this)
                elseif s__ball_life[this] <= 0 then
                    call KillUnit(s__ball_u[this])
                endif
                call sc__ball_deallocate(this)
            endif
   return true
endfunction
function sa__ball_create takes nothing returns boolean
    set f__result_integer=s__ball_create(f__arg_unit1,f__arg_real1,f__arg_real2,f__arg_real3)
   return true
endfunction
function sa__ball_onDestroy takes nothing returns boolean
local integer this=f__arg_this
            call s__unitList_deallocate(s__ball_l[this])
            call s__vector_deallocate(s__ball_v[this])
            set ballNum=ballNum - 1
            set balls[s__ball_spot[this]]=balls[ballNum]
            set s__ball_spot[balls[ballNum]]=s__ball_spot[this]
            call RemoveSavedInteger(ht, GetHandleId(s__ball_u[this]), kvel)
            set s__ball_u[this]=null
   return true
endfunction
function sa__Damage___Detector_AIDS_onCreate takes nothing returns boolean
local integer this=f__arg_this
            set s__Damage___Detector_t[this]=CreateTrigger()
            call TriggerAddCondition(s__Damage___Detector_t[this], s__Damage___Detector_ACTIONS_COND)
            call TriggerRegisterUnitEvent(s__Damage___Detector_t[this], s__Damage___Detector__get_unit(this), EVENT_UNIT_DAMAGED)
   return true
endfunction
function sa__Damage___Detector_AIDS_onDestroy takes nothing returns boolean
local integer this=f__arg_this
            call DestroyTrigger(s__Damage___Detector_t[this])
   return true
endfunction
function sa__Damage___Detector_AIDS_onInit takes nothing returns boolean

            set s__Damage___Detector_ACTIONS_COND=Condition(function Damage___OnDamageActions)
   return true
endfunction
function sa__trc2dth_move takes nothing returns boolean
local integer this=f__arg_this
            local real dir
            local integer v
            local integer dec
            local integer i
            if IsUnitDeadBJ(s__trc2dth_s[this]) or IsUnitDeadBJ(s__trc2dth_u[this]) then
                call sc__trc2dth_deallocate(this)
            else
                set dir=Atan2(GetUnitY(s__trc2dth_s[this]) - GetUnitY(s__trc2dth_u[this]), GetUnitX(s__trc2dth_s[this]) - GetUnitX(s__trc2dth_u[this]))
                set dec=GetHandleId(s__trc2dth_u[this])
                if HaveSavedInteger(ht, dec, kvel) then
                    set v=s__vector_create(s__trc2dth_str[this] * Cos(dir) , s__trc2dth_str[this] * Sin(dir))
                    set i=LoadInteger(ht, dec, kvel)
                    if s__vector_getAngle(v , s__ball_v[balls[i]]) > s__trc2dth_tdir[this] and YDWEDistanceBetweenUnits(s__trc2dth_s[this] , s__trc2dth_u[this]) > s__trc2dth_trange[this] then
                        call s__vector_subtractLength(s__ball_v[balls[i]],s__trc2dth_tstr[this])
                    endif
                endif
                call AddVector(s__trc2dth_u[this] , dir , s__trc2dth_str[this])
            endif
            call s__vector_deallocate(v)
   return true
endfunction
function sa__trc2dth_onDestroy takes nothing returns boolean
local integer this=f__arg_this
            set trc2dthsn=trc2dthsn - 1
            set trc2dths[s__trc2dth_spot[this]]=trc2dths[trc2dthsn]
            set s__trc2dth_spot[trc2dths[trc2dthsn]]=s__trc2dth_spot[this]
            call RemoveSavedInteger(ht, GetHandleId(s__trc2dth_t[this]), katt)
            call DestroyTimer(s__trc2dth_t[this])
            set s__trc2dth_t[this]=null
            set s__trc2dth_u[this]=null
            set s__trc2dth_s[this]=null
            call BJDebugMsg("trc2dthsn " + I2S(trc2dthsn))
   return true
endfunction
function sa__att2dth_move takes nothing returns boolean
local integer this=f__arg_this
            local real dir
            if IsUnitDeadBJ(s__att2dth_s[this]) or IsUnitDeadBJ(s__att2dth_u[this]) then
                call sc__att2dth_deallocate(this)
            else
                set dir=Atan2(GetUnitY(s__att2dth_s[this]) - GetUnitY(s__att2dth_u[this]), GetUnitX(s__att2dth_s[this]) - GetUnitX(s__att2dth_u[this]))
                call AddVector(s__att2dth_u[this] , dir , s__att2dth_str[this])
                call BJDebugMsg("attract str is" + R2S(s__att2dth_str[this]))
            endif
   return true
endfunction
function sa__att2dth_onDestroy takes nothing returns boolean
local integer this=f__arg_this
            set att2dthsn=att2dthsn - 1
            set att2dths[s__att2dth_spot[this]]=att2dths[att2dthsn]
            set s__att2dth_spot[att2dths[att2dthsn]]=s__att2dth_spot[this]
            call RemoveSavedInteger(ht, GetHandleId(s__att2dth_t[this]), katt)
            call DestroyTimer(s__att2dth_t[this])
            set s__att2dth_t[this]=null
            set s__att2dth_u[this]=null
            set s__att2dth_s[this]=null
            call BJDebugMsg("att2dthsn " + I2S(att2dthsn))
   return true
endfunction
function sa__vector_setLength takes nothing returns boolean
local integer this=f__arg_this
local real length=f__arg_real1
            local real l= SquareRoot(s__vector_x[this] * s__vector_x[this] + s__vector_y[this] * s__vector_y[this])
            if l == 0.0 then
return true
            endif
            set l=length / l
            set s__vector_x[this]=s__vector_x[this] * l
            set s__vector_y[this]=s__vector_y[this] * l
   return true
endfunction
function sa__unitList_onDestroy takes nothing returns boolean
local integer this=f__arg_this
            local integer i=0
            loop
                exitwhen i >= s__unitList_n[this]
                set s___unitList_a[s__unitList_a[this]+i]=null
                set i=i + 1
            endloop
   return true
endfunction

function jasshelper__initstructs21600818 takes nothing returns nothing
    set st__shooter_shoot=CreateTrigger()
    call TriggerAddCondition(st__shooter_shoot,Condition( function sa__shooter_shoot))
    set st__shooter_create=CreateTrigger()
    call TriggerAddCondition(st__shooter_create,Condition( function sa__shooter_create))
    set st__shooter_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__shooter_onDestroy,Condition( function sa__shooter_onDestroy))
    set st__ball_move=CreateTrigger()
    call TriggerAddCondition(st__ball_move,Condition( function sa__ball_move))
    set st__ball_create=CreateTrigger()
    call TriggerAddCondition(st__ball_create,Condition( function sa__ball_create))
    set st__ball_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__ball_onDestroy,Condition( function sa__ball_onDestroy))
    set st__Damage___Detector_AIDS_onCreate=CreateTrigger()
    call TriggerAddCondition(st__Damage___Detector_AIDS_onCreate,Condition( function sa__Damage___Detector_AIDS_onCreate))
    set st__Damage___Detector_AIDS_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__Damage___Detector_AIDS_onDestroy,Condition( function sa__Damage___Detector_AIDS_onDestroy))
    set st__Damage___Detector_AIDS_onInit=CreateTrigger()
    call TriggerAddCondition(st__Damage___Detector_AIDS_onInit,Condition( function sa__Damage___Detector_AIDS_onInit))
    set st__trc2dth_move=CreateTrigger()
    call TriggerAddCondition(st__trc2dth_move,Condition( function sa__trc2dth_move))
    set st__trc2dth_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__trc2dth_onDestroy,Condition( function sa__trc2dth_onDestroy))
    set st__att2dth_move=CreateTrigger()
    call TriggerAddCondition(st__att2dth_move,Condition( function sa__att2dth_move))
    set st__att2dth_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__att2dth_onDestroy,Condition( function sa__att2dth_onDestroy))
    set st__vector_setLength=CreateTrigger()
    call TriggerAddCondition(st__vector_setLength,Condition( function sa__vector_setLength))
    set st__unitList_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__unitList_onDestroy,Condition( function sa__unitList_onDestroy))










call ExecuteFunc("s__Damage___InitStruct_Damage___InitModule__onInit")



    call ExecuteFunc("s__Damage___Detector_onInit")
endfunction
